{"meta":{"title":"博客","subtitle":null,"description":null,"author":"vcpu","url":"https://vcpu.github.io"},"pages":[{"title":"标签","date":"2017-06-05T04:50:47.000Z","updated":"2017-06-05T04:51:50.000Z","comments":false,"path":"tags/index.html","permalink":"https://vcpu.github.io/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2017-06-05T04:59:19.000Z","updated":"2017-06-05T05:00:31.000Z","comments":false,"path":"categories/index.html","permalink":"https://vcpu.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"socket()实现源码分析","slug":"socket","date":"2017-06-09T10:03:12.000Z","updated":"2017-06-09T10:03:12.000Z","comments":true,"path":"2017/06/09/socket/","link":"","permalink":"https://vcpu.github.io/2017/06/09/socket/","excerpt":"socket()内核版本：3.10.0-514.16.1.el7.x86_64 1234#include &lt;sys/types.h&gt; /* See NOTES */#include &lt;sys/socket.h&gt;int socket(int domain, int type, int protocol);fd=socket(PF_INET,SOCK_STREAM,0","text":"socket()内核版本：3.10.0-514.16.1.el7.x86_64 1234#include &lt;sys/types.h&gt; /* See NOTES */#include &lt;sys/socket.h&gt;int socket(int domain, int type, int protocol);fd=socket(PF_INET,SOCK_STREAM,0 (1).接口说明：按照顺序可传入如下参数： PF_INEAT SOCK_STREAM,SOCK_DGRAM,SOCK_RAW IPPROTO_TCP,IPPROTO_UDP,IPPROTO_IP 返回值说明 EAFNOSUPPORT 不支持地址类型 EMFILE 进程文件表溢出 ENFILE 核心内存不足无法建立新的socket EINVAL 参数domain/type/protocol不合法 EACCES 权限不允许 ENOBUFS/ENOMEM 内存不足 EPROTONOSUPPORT domain指定的类型不支持参数type或者protocol (2).内核调用栈 (3).结构体说明 struct socket 面向用户态的结构体基于虚拟文件系统创建创建socket时最先创建的结构体 struct sock 网络层socket struct inet_sock INET域socket表示提供INET域的一些属性，TTL、 组播、 地址 、端口 struct raw_socket、struct udp—sock、 struct inet_connection_sock 是对struct inet_sock的扩展struct raw_socket要处理ICMPstruct udp_sock udp协议socketstruct inet_connection_sock面向连接socketstruct tcp_sock TCP协议socket ，对inet_connection_sock扩展，增加了滑动窗口等拥塞控制属性struct inet_timewait_sock网络层超时控制使用struct tcp_timewait_sock TCP协议超时控制使用 (4).struct socket创建源码分析(4.1).sock_alloc函数123456789101112131415161718192021static struct socket *sock_alloc(void)&#123; struct inode *inode; struct socket *sock; inode = new_inode_pseudo(sock_mnt-&gt;mnt_sb); if (!inode) return NULL; sock = SOCKET_I(inode); kmemcheck_annotate_bitfield(sock, type); inode-&gt;i_ino = get_next_ino(); inode-&gt;i_mode = S_IFSOCK | S_IRWXUGO; inode-&gt;i_uid = current_fsuid(); inode-&gt;i_gid = current_fsgid(); inode-&gt;i_op = &amp;sockfs_inode_ops; this_cpu_add(sockets_in_use, 1); return sock;&#125; 一起申请两块内存struct socket和struct inode 两块内存用struct socket_alloc联系起来 inode是linux用来刻画一个存放在内存中的文件的 socket是一种网络文件类型，可以通过文件描述符使用read和write等文件操作函数操作socket 有了inode就支持了虚拟文件系统的操作 (4.2).sock_alloc-&gt;new_inode_pseudo-&gt;alloc_inode12345678910111213141516171819202122232425262728293031323334struct inode *new_inode_pseudo(struct super_block *sb)&#123; struct inode *inode = alloc_inode(sb); if (inode) &#123; spin_lock(&amp;inode-&gt;i_lock); inode-&gt;i_state = 0; spin_unlock(&amp;inode-&gt;i_lock); INIT_LIST_HEAD(&amp;inode-&gt;i_sb_list); &#125; return inode;&#125;static struct inode *alloc_inode(struct super_block *sb)&#123; struct inode *inode; if (sb-&gt;s_op-&gt;alloc_inode) inode = sb-&gt;s_op-&gt;alloc_inode(sb); else inode = kmem_cache_alloc(inode_cachep, GFP_KERNEL); if (!inode) return NULL; if (unlikely(inode_init_always(sb, inode))) &#123; if (inode-&gt;i_sb-&gt;s_op-&gt;destroy_inode) inode-&gt;i_sb-&gt;s_op-&gt;destroy_inode(inode); else kmem_cache_free(inode_cachep, inode); return NULL; &#125; return inode;&#125; alloc_inode获取内存有两种方式 1.通过自己alloc_inode分配 2.从高速缓存中分配 (4.3).alloc_inode -&gt; sock_alloc_inode12345678910111213141516171819202122232425static struct inode *sock_alloc_inode(struct super_block *sb)&#123; struct socket_alloc *ei; struct socket_wq *wq; ei = kmem_cache_alloc(sock_inode_cachep, GFP_KERNEL); if (!ei) return NULL; wq = kmalloc(sizeof(*wq), GFP_KERNEL); if (!wq) &#123; kmem_cache_free(sock_inode_cachep, ei); return NULL; &#125; init_waitqueue_head(&amp;wq-&gt;wait); wq-&gt;fasync_list = NULL; RCU_INIT_POINTER(ei-&gt;socket.wq, wq); ei-&gt;socket.state = SS_UNCONNECTED; ei-&gt;socket.flags = 0; ei-&gt;socket.ops = NULL; ei-&gt;socket.sk = NULL; ei-&gt;socket.file = NULL; return &amp;ei-&gt;vfs_inode;&#125; socket结构体最终会调用上述函数申请内存 该函数会在sock_init中被注册和挂载到系统上 (4.4).sock_init 中sock_allok_inode挂载过程123456789101112131415161718192021222324err = register_filesystem(&amp;sock_fs_type); if (err) goto out_fs; sock_mnt = kern_mount(&amp;sock_fs_type); if (IS_ERR(sock_mnt)) &#123; err = PTR_ERR(sock_mnt); goto out_mount; ... static struct file_system_type sock_fs_type = &#123; .name = \"sockfs\", .mount = sockfs_mount, .kill_sb = kill_anon_super,&#125;;static struct dentry *sockfs_mount(struct file_system_type *fs_type, int flags, const char *dev_name, void *data)&#123; return mount_pseudo(fs_type, \"socket:\", &amp;sockfs_ops, &amp;sockfs_dentry_operations, SOCKFS_MAGIC);&#125;static const struct super_operations sockfs_ops = &#123; .alloc_inode = sock_alloc_inode, .destroy_inode = sock_destroy_inode, .statfs = simple_statfs,&#125;; sock_init -&gt; register mount -&gt; sock_fs_type-&gt;sockfs_mount-&gt;sockfs_ops-&gt;sock_alloc_node (4.5).pf-&gt;create 即TCP／IP协议族的创建函数inet_create初始化步骤(4.5.1).PF_INET协议族的create函数inet_create会被组册1234567(void)sock_register(&amp;inet_family_ops);static const struct net_proto_family inet_family_ops = &#123; .family = PF_INET, .create = inet_create, .owner = THIS_MODULE,&#125;; (4.5.2).注册过程123456789101112131415161718192021int sock_register(const struct net_proto_family *ops)&#123; int err; if (ops-&gt;family &gt;= NPROTO) &#123; printk(KERN_CRIT \"protocol %d &gt;= NPROTO(%d)\\n\", ops-&gt;family, NPROTO); return -ENOBUFS; &#125; spin_lock(&amp;net_family_lock); if (rcu_dereference_protected(net_families[ops-&gt;family], lockdep_is_held(&amp;net_family_lock))) err = -EEXIST; else &#123; rcu_assign_pointer(net_families[ops-&gt;family], ops); err = 0; &#125; spin_unlock(&amp;net_family_lock); printk(KERN_INFO \"NET: Registered protocol family %d\\n\", ops-&gt;family); return err;&#125; 协议族选项ops会根基协议族类型PF_INET被放置到net_families系统全局变量中 (4.5.3).__sock_create使用过程1234567891011121314151617181920socket.c/__sock_create...rcu_read_lock(); pf = rcu_dereference(net_families[family]); err = -EAFNOSUPPORT; if (!pf) goto out_release; /* * We will call the -&gt;create function, that possibly is in a loadable * module, so we have to bump that loadable module refcnt first. */ if (!try_module_get(pf-&gt;owner)) goto out_release; /* Now protected by module ref count */ rcu_read_unlock(); err = pf-&gt;create(net, sock, protocol, kern); if (err &lt; 0) goto out_module_put; 根据socket传输过来的协议族PF_INET查找全局变量net_families获取ops 通过ops-&gt;create调用inet_create根据具体协议创建网络层socket struct sock (4.6).inet_create都干了什么？123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140static int inet_create(struct net *net, struct socket *sock, int protocol, int kern)&#123; struct sock *sk; struct inet_protosw *answer; struct inet_sock *inet; struct proto *answer_prot; unsigned char answer_flags; int try_loading_module = 0; int err; if (protocol &lt; 0 || protocol &gt;= IPPROTO_MAX) return -EINVAL; sock-&gt;state = SS_UNCONNECTED;//步骤1:设置socket状态SS_UNCONNECTED /* Look for the requested type/protocol pair. */lookup_protocol: err = -ESOCKTNOSUPPORT; rcu_read_lock();／／步骤2:根据socket协议找到inet处理函数 connect、bind、accept、listen、等 list_for_each_entry_rcu(answer, &amp;inetsw[sock-&gt;type], list) &#123; err = 0; /* Check the non-wild match. */ if (protocol == answer-&gt;protocol) &#123; if (protocol != IPPROTO_IP) break; &#125; else &#123; /* Check for the two wild cases. */ if (IPPROTO_IP == protocol) &#123; protocol = answer-&gt;protocol; break; &#125; if (IPPROTO_IP == answer-&gt;protocol) break; &#125; err = -EPROTONOSUPPORT; &#125; if (unlikely(err)) &#123; if (try_loading_module &lt; 2) &#123; rcu_read_unlock(); /* * Be more specific, e.g. net-pf-2-proto-132-type-1 * (net-pf-PF_INET-proto-IPPROTO_SCTP-type-SOCK_STREAM) */ if (++try_loading_module == 1) request_module(\"net-pf-%d-proto-%d-type-%d\", PF_INET, protocol, sock-&gt;type); /* * Fall back to generic, e.g. net-pf-2-proto-132 * (net-pf-PF_INET-proto-IPPROTO_SCTP) */ else request_module(\"net-pf-%d-proto-%d\", PF_INET, protocol); goto lookup_protocol; &#125; else goto out_rcu_unlock; &#125; err = -EPERM; if (sock-&gt;type == SOCK_RAW &amp;&amp; !kern &amp;&amp; !ns_capable(net-&gt;user_ns, CAP_NET_RAW)) goto out_rcu_unlock;／／步骤3: 把协协议的inet操作集合赋值给socket结构的ops sock-&gt;ops = answer-&gt;ops; answer_prot = answer-&gt;prot; answer_flags = answer-&gt;flags; rcu_read_unlock(); WARN_ON(answer_prot-&gt;slab == NULL); err = -ENOBUFS; ／／步骤4:申请struct sock结构体，并切把协议操作集合赋值给sock结构体 ／／sk-&gt;sk_prot = sk-&gt;sk_prot_creator =协议操作集合; sk = sk_alloc(net, PF_INET, GFP_KERNEL, answer_prot); if (sk == NULL) goto out; err = 0; if (INET_PROTOSW_REUSE &amp; answer_flags) sk-&gt;sk_reuse = SK_CAN_REUSE;／／步骤5：inet_sock进行相关初始化 inet = inet_sk(sk); inet-&gt;is_icsk = (INET_PROTOSW_ICSK &amp; answer_flags) != 0; inet-&gt;nodefrag = 0; if (SOCK_RAW == sock-&gt;type) &#123; inet-&gt;inet_num = protocol; if (IPPROTO_RAW == protocol) inet-&gt;hdrincl = 1; &#125; if (net-&gt;sysctl_ip_no_pmtu_disc) inet-&gt;pmtudisc = IP_PMTUDISC_DONT; else inet-&gt;pmtudisc = IP_PMTUDISC_WANT; inet-&gt;inet_id = 0; sock_init_data(sock, sk); sk-&gt;sk_destruct = inet_sock_destruct; sk-&gt;sk_protocol = protocol; sk-&gt;sk_backlog_rcv = sk-&gt;sk_prot-&gt;backlog_rcv; inet-&gt;uc_ttl = -1; inet-&gt;mc_loop = 1; inet-&gt;mc_ttl = 1; inet-&gt;mc_all = 1; inet-&gt;mc_index = 0; inet-&gt;mc_list = NULL; inet-&gt;rcv_tos = 0; sk_refcnt_debug_inc(sk); if (inet-&gt;inet_num) &#123; /* It assumes that any protocol which allows * the user to assign a number at socket * creation time automatically * shares. */ inet-&gt;inet_sport = htons(inet-&gt;inet_num); /* Add to protocol hash chains. */ sk-&gt;sk_prot-&gt;hash(sk); &#125;／／步骤6:调用协议层初始化函数tcp_v4_init_sock()进行始化 if (sk-&gt;sk_prot-&gt;init) &#123; err = sk-&gt;sk_prot-&gt;init(sk); if (err) sk_common_release(sk); &#125;out: return err;out_rcu_unlock: rcu_read_unlock(); goto out;&#125; 设置socket状态SS_UNCONNECTED 根据协议类型找到具体的协议类型操作集合，例如协议处理函数tcp_proc和inet层处理函数集合inet_stream_ops socket-&gt;ops 获得协议操作集合inet_stream_ops 申请sock，并把tcp_proc赋值给它 sk-&gt;sk_prot = sk-&gt;sk_prot_creator=tcp_proc 把申请的sock和inet_sock进行初始化 sk-&gt;sk_prot-&gt;init(sk) 调用tcp_proc深度初始化TCP相关信息 尽管流程主要干了上述的事情，仍需要深入探究的问题是：a. inet_protosw inet_protosw初始化过程如何？b. inet_sock和sock是什么关系？c. 从inet_protosw获取的prot和ops哪些结构体上会记录使用？ (4.6.1).inet_protosw初始化过程如何？12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485static struct inet_protosw inetsw_array[] =&#123; &#123; .type = SOCK_STREAM, .protocol = IPPROTO_TCP, .prot = &amp;tcp_prot, .ops = &amp;inet_stream_ops, .flags = INET_PROTOSW_PERMANENT | INET_PROTOSW_ICSK, &#125;, &#123; .type = SOCK_DGRAM, .protocol = IPPROTO_UDP, .prot = &amp;udp_prot, .ops = &amp;inet_dgram_ops, .flags = INET_PROTOSW_PERMANENT, &#125;, &#123; .type = SOCK_DGRAM, .protocol = IPPROTO_ICMP, .prot = &amp;ping_prot, .ops = &amp;inet_dgram_ops, .flags = INET_PROTOSW_REUSE, &#125;, &#123; .type = SOCK_RAW, .protocol = IPPROTO_IP, /* wild card */ .prot = &amp;raw_prot, .ops = &amp;inet_sockraw_ops, .flags = INET_PROTOSW_REUSE, &#125;&#125;;//inet_init for (q = inetsw_array; q &lt; &amp;inetsw_array[INETSW_ARRAY_LEN]; ++q) inet_register_protosw(q); //inet_protosw放入全局inetsw管理void inet_register_protosw(struct inet_protosw *p)&#123; struct list_head *lh; struct inet_protosw *answer; int protocol = p-&gt;protocol; struct list_head *last_perm; spin_lock_bh(&amp;inetsw_lock); if (p-&gt;type &gt;= SOCK_MAX) goto out_illegal; /* If we are trying to override a permanent protocol, bail. */ answer = NULL; last_perm = &amp;inetsw[p-&gt;type]; list_for_each(lh, &amp;inetsw[p-&gt;type]) &#123; answer = list_entry(lh, struct inet_protosw, list); /* Check only the non-wild match. */ if (INET_PROTOSW_PERMANENT &amp; answer-&gt;flags) &#123; if (protocol == answer-&gt;protocol) break; last_perm = lh; &#125; answer = NULL; &#125; if (answer) goto out_permanent; /* Add the new entry after the last permanent entry if any, so that * the new entry does not override a permanent entry when matched with * a wild-card protocol. But it is allowed to override any existing * non-permanent entry. This means that when we remove this entry, the * system automatically returns to the old behavior. */ list_add_rcu(&amp;p-&gt;list, last_perm);out: spin_unlock_bh(&amp;inetsw_lock); return;out_permanent: pr_err(\"Attempt to override permanent protocol %d\\n\", protocol); goto out;out_illegal: pr_err(\"Ignoring attempt to register invalid socket type %d\\n\", p-&gt;type); goto out;&#125; inet_init 会把inet_protosw方式inet_sw中 inet_protosw很重要，其含有协议的具体操作函数tcp_close,tcp_v4_connect,tcp_recvmsg等 inet_protosw，内还包含inet层操作函数 inet_bind,inet_accept,inet_bind,inet_listen等 (4.6.2). inet_sock和sock是什么关系？123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566struct sock *sk_alloc(struct net *net, int family, gfp_t priority, struct proto *prot)&#123; struct sock *sk; sk = sk_prot_alloc(prot, priority | __GFP_ZERO, family); if (sk) &#123; sk-&gt;sk_family = family; /* * See comment in struct sock definition to understand * why we need sk_prot_creator -acme */ sk-&gt;sk_prot = sk-&gt;sk_prot_creator = prot; sock_lock_init(sk); sock_net_set(sk, get_net(net)); atomic_set(&amp;sk-&gt;sk_wmem_alloc, 1); sock_update_classid(sk); sock_update_netprioidx(sk); &#125; return sk;&#125;static struct sock *sk_prot_alloc(struct proto *prot, gfp_t priority, int family)&#123; struct sock *sk; struct kmem_cache *slab; slab = prot-&gt;slab; if (slab != NULL) &#123; sk = kmem_cache_alloc(slab, priority &amp; ~__GFP_ZERO); if (!sk) return sk; if (priority &amp; __GFP_ZERO) &#123; if (prot-&gt;clear_sk) prot-&gt;clear_sk(sk, prot-&gt;obj_size); else sk_prot_clear_nulls(sk, prot-&gt;obj_size); &#125; &#125; else sk = kmalloc(prot-&gt;obj_size, priority);//申请内存大小为prot的objsize if (sk != NULL) &#123; kmemcheck_annotate_bitfield(sk, flags); if (security_sk_alloc(sk, family, priority)) goto out_free; if (!try_module_get(prot-&gt;owner)) goto out_free_sec; sk_tx_queue_clear(sk); &#125; return sk;out_free_sec: security_sk_free(sk);out_free: if (slab != NULL) kmem_cache_free(slab, sk); else kfree(sk); return NULL;&#125; 从上述sk_alloc -&gt; sk_prot_alloc -&gt; obj_size 12345678910111213141516171819202122232425262728293031323334353637383940414243444546struct proto tcp_prot = &#123; .name = \"TCP\", .owner = THIS_MODULE, .close = tcp_close, .connect = tcp_v4_connect, .disconnect = tcp_disconnect, .accept = inet_csk_accept, .ioctl = tcp_ioctl, .init = tcp_v4_init_sock, .destroy = tcp_v4_destroy_sock, .shutdown = tcp_shutdown, .setsockopt = tcp_setsockopt, .getsockopt = tcp_getsockopt, .recvmsg = tcp_recvmsg, .sendmsg = tcp_sendmsg, .sendpage = tcp_sendpage, .backlog_rcv = tcp_v4_do_rcv, .release_cb = tcp_release_cb, .hash = inet_hash, .unhash = inet_unhash, .get_port = inet_csk_get_port, .enter_memory_pressure = tcp_enter_memory_pressure, .stream_memory_free = tcp_stream_memory_free, .sockets_allocated = &amp;tcp_sockets_allocated, .orphan_count = &amp;tcp_orphan_count, .memory_allocated = &amp;tcp_memory_allocated, .memory_pressure = &amp;tcp_memory_pressure, .sysctl_wmem = sysctl_tcp_wmem, .sysctl_rmem = sysctl_tcp_rmem, .max_header = MAX_TCP_HEADER, .obj_size = sizeof(struct tcp_sock), .slab_flags = SLAB_DESTROY_BY_RCU, .twsk_prot = &amp;tcp_timewait_sock_ops, .rsk_prot = &amp;tcp_request_sock_ops, .h.hashinfo = &amp;tcp_hashinfo, .no_autobind = true,#ifdef CONFIG_COMPAT .compat_setsockopt = compat_tcp_setsockopt, .compat_getsockopt = compat_tcp_getsockopt,#endif#ifdef CONFIG_MEMCG_KMEM .init_cgroup = tcp_init_cgroup, .destroy_cgroup = tcp_destroy_cgroup, .proto_cgroup = tcp_proto_cgroup,#endif&#125;; struct tcp_sock 包含strcut inet_sock 包含 struct sock 上述结构体为互相包含的关系 实际上在申请sock时候，申请内存大小为tcp_sock大小，也就是说三个结构体共同诞生了 (4.6.3). 从inet_protosw获取的prot和ops哪些结构体上会记录使用？ struct socket会在inet_create函数中获取到ops sock-&gt;ops = answer-&gt;ops;struct sock在sk_allloc函数中获取pro sk-&gt;sk_prot = sk-&gt;sk_prot_creator = prot; (5).socket与文件系统socket与文件系统关联通过sock_map_fd完成 其步骤如下： 1:获取fd get_unused_fd_flags 该函数从当前进程管理的files获取可用的fd 2:申请file sock_alloc_file 将struct socket放到file的private_data管理 file-&gt;private_data = sock 3:将file根据当前fd安装到current-&gt;files中 files有一个指针fdtfdt-&gt;fd是一个类型为file指针的数组，数组下标为fdrcu_assign_pointer(fdt-&gt;fd[fd], file); 将file安装fd为数组下标放到current-&gt;files管理","categories":[{"name":"socket","slug":"socket","permalink":"https://vcpu.github.io/categories/socket/"}],"tags":[{"name":"socket","slug":"socket","permalink":"https://vcpu.github.io/tags/socket/"},{"name":"tcp/ip","slug":"tcp-ip","permalink":"https://vcpu.github.io/tags/tcp-ip/"},{"name":"kernel3.10.0-514.16.1","slug":"kernel3-10-0-514-16-1","permalink":"https://vcpu.github.io/tags/kernel3-10-0-514-16-1/"}]},{"title":"systemtap使用调试记录（一）","slug":"systemtap使用调试记录（一）","date":"2017-06-05T10:15:52.000Z","updated":"2017-06-05T10:15:52.000Z","comments":true,"path":"2017/06/05/systemtap使用调试记录（一）/","link":"","permalink":"https://vcpu.github.io/2017/06/05/systemtap使用调试记录（一）/","excerpt":"systemtap使用调试记录（一）一、调试环境介绍Linux 3.10.0-514.16.1.el7.x86_64 kernel-devel-3.10.0-514.16.1.el7.x86_64.rpm 同版本的开发头文件 kernel-debuginfo-common-x86_64-3.10.0-514.16.1.el7.x86_64.rpm kernel-debuginfo-3.10.0-514.16.1.el7.x86_64.rpm 同版本调试数据包 linux-3.10.0-514.16.1.el7.tar.xz 同版本的源码 kernel开发头文件下载地址kernel调试包下载地址kernel调试common包下载地址根据当前虚拟机获取内核代码的方法","text":"systemtap使用调试记录（一）一、调试环境介绍Linux 3.10.0-514.16.1.el7.x86_64 kernel-devel-3.10.0-514.16.1.el7.x86_64.rpm 同版本的开发头文件 kernel-debuginfo-common-x86_64-3.10.0-514.16.1.el7.x86_64.rpm kernel-debuginfo-3.10.0-514.16.1.el7.x86_64.rpm 同版本调试数据包 linux-3.10.0-514.16.1.el7.tar.xz 同版本的源码 kernel开发头文件下载地址kernel调试包下载地址kernel调试common包下载地址根据当前虚拟机获取内核代码的方法 二、centos7安装方法yum install *.rpm 安装上述3个（debugifo,devel,debuginfo-common）rpm包 yum install systemtap stap -ve &apos;probe begin { log(&quot;hello world&quot;) exit() }&apos; 测试正常结果如下： [root@localhost qinlong]# stap -ve ‘probe begin { log(“hello world”) exit() }’Pass 1: parsed user script and 120 library scripts using 227352virt/40488res/3260shr/37400data kb, in 260usr/30sys/338real ms.Pass 2: analyzed script: 1 probe, 2 functions, 0 embeds, 0 globals using 228540virt/41804res/3420shr/38588data kb, in 10usr/0sys/6real ms.Pass 3: translated to C into “/tmp/stap5CqHmN/stap_f7a5084b8a638f5ce64a31271684ef1f_1133_src.c” using 228672virt/42408res/3996shr/38720data kb, in 0usr/0sys/0real ms.Pass 4: compiled C into “stap_f7a5084b8a638f5ce64a31271684ef1f_1133.ko” in 1000usr/330sys/1247real ms.Pass 5: starting run.hello worldPass 5: run completed in 10usr/40sys/362real ms. 三、通用案例1.函数调用栈打印123456789[root@localhost stp]# cat bt.stp probe kernel.function(@1)&#123; print(&quot;----------------START-------------------------\\n&quot;) printf(&quot;In process [%s]\\n&quot;, execname()) print_regs() print_backtrace() print(&quot;----------------END-------------------------\\n&quot;) exit() &#125; 打印内核函数的调用栈 [root@localhost stp]# stap bt.stp tcp_sendmsg—————-START————————-In process [sshd]RIP: ffffffff815c1ee0RSP: ffff88003d217d28 EFLAGS: 00000202RAX: ffffffff81aa20a0 RBX: ffff88003d217e38 RCX: 0000000000000024RDX: ffff88003d217da8 RSI: ffff88003b3b87c0 RDI: ffff88003d217e38RBP: ffff88003d217d50 R08: 0000000000000000 R09: 0000000000000000R10: ffff88003d217da8 R11: 0000000000000000 R12: ffff88003d217e38R13: 0000000000000001 R14: ffff88003d217e28 R15: ffff8800274d3480FS: 00007f03e5514840(0000) GS:ffff88003fd00000(0000) knlGS:0000000000000000CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033CR2: 00007f19c6dc8000 CR3: 0000000035a5c000 CR4: 00000000000406e0 0xffffffff815c1ee0 : tcp_sendmsg+0x0/0xc40 [kernel] 0xffffffff815ed254 : inet_sendmsg+0x64/0xb0 [kernel] 0xffffffff81554e07 : sock_aio_write+0x157/0x180 [kernel] 0xffffffff811fdf3d : do_sync_write+0x8d/0xd0 [kernel] 0xffffffff811fe8a5 : vfs_write+0x1b5/0x1e0 [kernel] 0xffffffff811ff2cf : sys_write+0x7f/0xe0 [kernel] 0xffffffff81697189 : system_call_fastpath+0x16/0x1b [kernel]—————-END————————- 2.函数的调用过程1234567[root@localhost stp]# cat socket-trace.stpprobe kernel.function(&quot;*@net/socket.c&quot;).call&#123; printf(&quot;%s -&gt; %s\\n&quot;,thread_indent(1),ppfunc())&#125;probe kernel.function(&quot;*@net/socket.c&quot;).return&#123; printf(&quot;%s&lt;-%s\\n&quot;,thread_indent(-1),ppfunc())&#125; thread_indent(1) 打印程序名称（线程id）ppfunc() 打印出执行函数符号 kernel.function(“@net/socket.c”).call调用net/socket.c 文件中函数时候会触发函数体执行打印动作kernel.function(“@net/socket.c”).return调用net/socket.c文件中函数执行完成返回后会触发函数体打印动作 [root@localhost stp]# stap socket-trace.stp 0 dndX11(3295): -&gt; SyS_recvmsg 0 dndX11(3295): -&gt; sys_recvmsg 0 dndX11(3295): -&gt; sockfd_lookup_light 0 dndX11(3295):&lt;-sockfd_lookuplight 1 dndX11(3295): -&gt; sys_recvmsg 3 dndX11(3295): -&gt; sock_recvmsg 7 dndX11(3295):&lt;-sock_recvmsg 8 dndX11(3295):&lt;-_sys_recvmsg 9 dndX11(3295):&lt;-sys_recvmsg 10 dndX11(3295):&lt;-SyS_recvmsg25274 dndX11(3295): -&gt; SyS_recvmsg25279 dndX11(3295): -&gt; sys_recvmsg25281 dndX11(3295): -&gt; sockfd_lookup_light25284 dndX11(3295):&lt;-sockfd_lookuplight25285 dndX11(3295): -&gt; sys_recvmsg25288 dndX11(3295): -&gt; sock_recvmsg25291 dndX11(3295):&lt;-sock_recvmsgx 3.打印协议栈函数中某一行数据/home/qinlong/rpmbuild/SOURCES/linux-3.10.0-514.16.1.el7/net/ipv4/tcp.c局部源码如下：12345678910111213141065 int tcp_sendmsg(struct kiocb *iocb, struct sock *sk, struct msghdr *msg,1066 size_t size)1067 &#123;1068 struct iovec *iov;1069 struct tcp_sock *tp = tcp_sk(sk);1070 struct sk_buff *skb;1071 int iovlen, flags, err, copied = 0;1072 int mss_now = 0, size_goal, copied_syn = 0, offset = 0;1073 bool sg;1074 long timeo;10751076 lock_sock(sk);10771078 flags = msg-&gt;msg_flags; 12[root@localhost ~]# stap -L &apos;kernel.statement(&quot;*@net/ipv4/tcp.c:1078&quot;)&apos;kernel.statement(&quot;tcp_sendmsg@net/ipv4/tcp.c:1078&quot;) $iocb:struct kiocb* $sk:struct sock* $msg:struct msghdr* $size:size_t $copied:int $mss_now:int $size_goal:int $copied_syn:int $offset:int $timeo:long int 执行上述函数，可确代码具体的函数局部变量12345678910$iocb:struct kiocb* $sk:struct sock* $msg:struct msghdr* $size:size_t $copied:int$mss_now:int $size_goal:int $copied_syn:int $offset:int $timeo:long int 根据以上变量打印出size值123[root@localhost ~]# stap -e &apos;probe kernel.statement(&quot;*@net/ipv4/tcp.c:1078&quot;) &#123;printf(&quot;size %d \\n&quot;,$size)&#125;&apos;size 36size 44","categories":[{"name":"linux kernel","slug":"linux-kernel","permalink":"https://vcpu.github.io/categories/linux-kernel/"}],"tags":[{"name":"systemtap","slug":"systemtap","permalink":"https://vcpu.github.io/tags/systemtap/"}]},{"title":"Hello World","slug":"hello-world","date":"2017-05-27T08:57:02.000Z","updated":"2017-05-27T08:57:02.000Z","comments":true,"path":"2017/05/27/hello-world/","link":"","permalink":"https://vcpu.github.io/2017/05/27/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[{"name":"tags","slug":"tags","permalink":"https://vcpu.github.io/tags/tags/"}]}]}