<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>博客</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://vcpu.github.io/"/>
  <updated>2017-06-09T10:59:10.000Z</updated>
  <id>https://vcpu.github.io/</id>
  
  <author>
    <name>vcpu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>connect()实现源码分析</title>
    <link href="https://vcpu.github.io/2017/06/09/connect/"/>
    <id>https://vcpu.github.io/2017/06/09/connect/</id>
    <published>2017-06-09T10:59:10.000Z</published>
    <updated>2017-06-09T10:59:10.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="connect"><a href="#connect" class="headerlink" title="connect()"></a>connect()</h1><p>内核版本：3.10.0-514.16.1.el7.x86_64<br>下述源码分析均以tcp socket为背景</p>
<h2 id="用户态函数"><a href="#用户态函数" class="headerlink" title="用户态函数"></a>用户态函数</h2><p>int connect(int sockfd, const struct sockaddr *addr,socklen_t addrlen);<br>参数：</p>
<blockquote>
<p>socketfd socket文件描述索引下标<br>addr 要连接的服务端的地址<br>addrlen addr的长度</p>
</blockquote>
<p>实例:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">remote_addr</span>;</span></div><div class="line"><span class="built_in">memset</span>(&amp;remote_addr,<span class="number">0</span>,<span class="keyword">sizeof</span>(remote_addr));</div><div class="line">remote_addr.sin_family=AF_INET;</div><div class="line">remote_addr.sin_addr.s_addr=inet_addr(<span class="string">"180.97.33.108"</span>);</div><div class="line">remote_addr.sin_port = htons(<span class="number">80</span>);</div><div class="line">connect(fd,(struct sockaddr*)&amp;remote_addr,<span class="keyword">sizeof</span>(struct sockaddr)</div></pre></td></tr></table></figure></p>
<a id="more"></a>
<h2 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">SYSCALL_DEFINE2(socketcall, <span class="keyword">int</span>, call, <span class="keyword">unsigned</span> <span class="keyword">long</span> __user *, args)</div><div class="line">&#123;</div><div class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> a[AUDITSC_ARGS];</div><div class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> a0, a1;</div><div class="line">	<span class="keyword">int</span> err;</div><div class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> len;</div><div class="line"></div><div class="line">	<span class="keyword">if</span> (call &lt; <span class="number">1</span> || call &gt; SYS_SENDMMSG)</div><div class="line">		<span class="keyword">return</span> -EINVAL;</div><div class="line"></div><div class="line">	len = nargs[call];</div><div class="line">	<span class="keyword">if</span> (len &gt; <span class="keyword">sizeof</span>(a))</div><div class="line">		<span class="keyword">return</span> -EINVAL;</div><div class="line"></div><div class="line">	<span class="comment">/* copy_from_user should be SMP safe. */</span></div><div class="line">	<span class="keyword">if</span> (copy_from_user(a, args, len))</div><div class="line">		<span class="keyword">return</span> -EFAULT;</div><div class="line"></div><div class="line">	err = audit_socketcall(nargs[call] / <span class="keyword">sizeof</span>(<span class="keyword">unsigned</span> <span class="keyword">long</span>), a);</div><div class="line">	<span class="keyword">if</span> (err)</div><div class="line">		<span class="keyword">return</span> err;</div><div class="line"></div><div class="line">	a0 = a[<span class="number">0</span>];</div><div class="line">	a1 = a[<span class="number">1</span>];</div><div class="line"></div><div class="line">	<span class="keyword">switch</span> (call) &#123;</div><div class="line">	<span class="keyword">case</span> SYS_SOCKET:</div><div class="line">		err = sys_socket(a0, a1, a[<span class="number">2</span>]);</div><div class="line">		<span class="keyword">break</span>;</div><div class="line">	<span class="keyword">case</span> SYS_BIND:</div><div class="line">		err = sys_bind(a0, (struct sockaddr __user *)a1, a[<span class="number">2</span>]);</div><div class="line">		<span class="keyword">break</span>;</div><div class="line">	<span class="keyword">case</span> SYS_CONNECT:</div><div class="line">		err = sys_connect(a0, (struct sockaddr __user *)a1, a[<span class="number">2</span>]);</div><div class="line">		<span class="keyword">break</span>;</div><div class="line">	...</div><div class="line">	</div><div class="line">	<span class="keyword">default</span>:</div><div class="line">		err = -EINVAL;</div><div class="line">		<span class="keyword">break</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> err;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>系统调用sys_socketcall会携带（fd,serveraddr,serveraddrlen）参数</li>
<li>系统中断处理函数sys_socketcall会将参数从用户态考入到内核态局部变量a中</li>
<li>调用sys_connect函数 sys_connect(a0, (struct sockaddr __user *)a1, a[2]);</li>
</ul>
<h2 id="sys-connect执行入口分析"><a href="#sys-connect执行入口分析" class="headerlink" title="sys_connect执行入口分析"></a>sys_connect执行入口分析</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">SYSCALL_DEFINE3(connect, <span class="keyword">int</span>, fd, struct sockaddr __user *, uservaddr,<span class="keyword">int</span>,addrlen)</div><div class="line">&#123;</div><div class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">socket</span> *<span class="title">sock</span>;</span></div><div class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_storage</span> <span class="title">address</span>;</span></div><div class="line">	<span class="keyword">int</span> err, fput_needed;</div><div class="line"></div><div class="line">	sock = sockfd_lookup_light(fd, &amp;err, &amp;fput_needed);</div><div class="line">	<span class="keyword">if</span> (!sock)</div><div class="line">		<span class="keyword">goto</span> out;</div><div class="line">	err = move_addr_to_kernel(uservaddr, addrlen, &amp;address);</div><div class="line">	<span class="keyword">if</span> (err &lt; <span class="number">0</span>)</div><div class="line">		<span class="keyword">goto</span> out_put;</div><div class="line"></div><div class="line">	err =</div><div class="line">	    security_socket_connect(sock, (struct sockaddr *)&amp;address, addrlen);</div><div class="line">	<span class="keyword">if</span> (err)</div><div class="line">		<span class="keyword">goto</span> out_put;</div><div class="line"></div><div class="line">	err = sock-&gt;ops-&gt;connect(sock, (struct sockaddr *)&amp;address, addrlen,</div><div class="line">				 sock-&gt;file-&gt;f_flags);</div><div class="line">out_put:</div><div class="line">	fput_light(sock-&gt;file, fput_needed);</div><div class="line">out:</div><div class="line">	<span class="keyword">return</span> err;</div></pre></td></tr></table></figure>
<ul>
<li>根据fd描述符号从当前进程current的files指针中的struct fd_table中的fd成员取出file</li>
<li>fdt-&gt;fd是一个数组用来管理当前进程的file指针</li>
<li>从file中privatedata中获取到socket变量</li>
<li>把connect连接的服务端地址存入内核空间中move_addr_to_kernel</li>
<li>sock-&gt;ops-&gt;connect 以tco为例，此处会调用inet_stream_connect 函数集合中的inet_stream_connect</li>
</ul>
<h3 id="inet-stream-connect分析"><a href="#inet-stream-connect分析" class="headerlink" title="inet_stream_connect分析"></a>inet_stream_connect分析</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">inet_stream_connect</span><span class="params">(struct socket *sock, struct sockaddr *uaddr,</span></span></div><div class="line">			<span class="keyword">int</span> addr_len, <span class="keyword">int</span> flags)</div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span> err;</div><div class="line"></div><div class="line">	lock_sock(sock-&gt;sk);</div><div class="line">	err = __inet_stream_connect(sock, uaddr, addr_len, flags);</div><div class="line">	release_sock(sock-&gt;sk);</div><div class="line">	<span class="keyword">return</span> err;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>inet_stream_connect() 为tcp socket时候connect动作调用的函数<br>改函数会调用__inet_stream_connect函数</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> __inet_stream_connect(struct socket *sock, struct sockaddr *uaddr,</div><div class="line">			  <span class="keyword">int</span> addr_len, <span class="keyword">int</span> flags)</div><div class="line">&#123;</div><div class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *<span class="title">sk</span> = <span class="title">sock</span>-&gt;<span class="title">sk</span>;</span></div><div class="line">	<span class="keyword">int</span> err;</div><div class="line">	<span class="keyword">long</span> timeo;</div><div class="line"></div><div class="line">	<span class="comment">//socket地址长度检查，不合法返回</span></div><div class="line">	<span class="keyword">if</span> (addr_len &lt; <span class="keyword">sizeof</span>(uaddr-&gt;sa_family))</div><div class="line">		<span class="keyword">return</span> -EINVAL;</div><div class="line">   <span class="comment">// 地址协议族检查，如果不合法则关闭连接</span></div><div class="line">	<span class="keyword">if</span> (uaddr-&gt;sa_family == AF_UNSPEC) &#123;</div><div class="line">		err = sk-&gt;sk_prot-&gt;disconnect(sk, flags);</div><div class="line">		sock-&gt;state = err ? SS_DISCONNECTING : SS_UNCONNECTED;</div><div class="line">		<span class="keyword">goto</span> out;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	</div><div class="line">	<span class="keyword">switch</span> (sock-&gt;state) &#123;</div><div class="line">	<span class="comment">//非法参数</span></div><div class="line">	<span class="keyword">default</span>:</div><div class="line">		err = -EINVAL;</div><div class="line">		<span class="keyword">goto</span> out;</div><div class="line">	<span class="comment">//该socket和对端连接已经建立</span></div><div class="line">	<span class="keyword">case</span> SS_CONNECTED:</div><div class="line">		err = -EISCONN;</div><div class="line">		<span class="keyword">goto</span> out;</div><div class="line">	<span class="comment">//该socket和对端连接建立中</span></div><div class="line">	<span class="keyword">case</span> SS_CONNECTING:</div><div class="line">		err = -EALREADY;</div><div class="line">		<span class="comment">/* Fall out of switch with err, set for this state */</span></div><div class="line">		<span class="keyword">break</span>;</div><div class="line">	<span class="comment">//该socket和对未连接</span></div><div class="line">	<span class="keyword">case</span> SS_UNCONNECTED:</div><div class="line">		err = -EISCONN;</div><div class="line">		<span class="comment">//如果未连接，但是socket还不是TCP_CLOSE状态错误返回</span></div><div class="line">		<span class="keyword">if</span> (sk-&gt;sk_state != TCP_CLOSE)</div><div class="line">			<span class="keyword">goto</span> out;</div><div class="line">		<span class="comment">//tcp调用tcp_v4_connect，发送syn</span></div><div class="line">		err = sk-&gt;sk_prot-&gt;connect(sk, uaddr, addr_len);</div><div class="line">		<span class="keyword">if</span> (err &lt; <span class="number">0</span>)</div><div class="line">			<span class="keyword">goto</span> out;</div><div class="line"></div><div class="line">		<span class="comment">//发送syn后sock状态从未连接更新为连接中</span></div><div class="line">		sock-&gt;state = SS_CONNECTING;</div><div class="line"></div><div class="line">		<span class="comment">/* Just entered SS_CONNECTING state; the only</span></div><div class="line">		 * difference is that return value in non-blocking</div><div class="line">		 * case is EINPROGRESS, rather than EALREADY.</div><div class="line">		 */</div><div class="line">		err = -EINPROGRESS;</div><div class="line">		<span class="keyword">break</span>;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">//默认情况下未设置非阻塞socket标志，timeo不为0，设置非阻塞，该值为0</span></div><div class="line">	timeo = sock_sndtimeo(sk, flags &amp; O_NONBLOCK);</div><div class="line"></div><div class="line">	<span class="comment">//发送syn后等待后续握手完成</span></div><div class="line">	<span class="comment">/*</span></div><div class="line">	* 阻塞socket</div><div class="line">	* inet_wait_for_connect 会等待协议栈层的处理</div><div class="line">	* 1.等待超过timeo，connect返回EINPROGRESS 表明正在处理</div><div class="line">	* 2.收到信号 </div><div class="line">	* 3.正常完成握手，返回0</div><div class="line">	* 非阻塞socket</div><div class="line">	* 直接退出connect函数并返回EINPROGRESS，表明协议栈正在处理</div><div class="line">	*/</div><div class="line">	<span class="keyword">if</span> ((<span class="number">1</span> &lt;&lt; sk-&gt;sk_state) &amp; (TCPF_SYN_SENT | TCPF_SYN_RECV)) &#123;</div><div class="line">		<span class="keyword">int</span> writebias = (sk-&gt;sk_protocol == IPPROTO_TCP) &amp;&amp;</div><div class="line">				tcp_sk(sk)-&gt;fastopen_req &amp;&amp;</div><div class="line">				tcp_sk(sk)-&gt;fastopen_req-&gt;data ? <span class="number">1</span> : <span class="number">0</span>;</div><div class="line"></div><div class="line">		<span class="comment">/* Error code is set above */</span></div><div class="line">		<span class="keyword">if</span> (!timeo || !inet_wait_for_connect(sk, timeo, writebias))</div><div class="line">			<span class="keyword">goto</span> out;</div><div class="line"></div><div class="line">		err = sock_intr_errno(timeo);</div><div class="line">		<span class="keyword">if</span> (signal_pending(current))</div><div class="line">			<span class="keyword">goto</span> out;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">/* Connection was closed by RST, timeout, ICMP error</span></div><div class="line">	 * or another process disconnected us.</div><div class="line">	 */</div><div class="line">	<span class="keyword">if</span> (sk-&gt;sk_state == TCP_CLOSE)</div><div class="line">		<span class="keyword">goto</span> sock_error;</div><div class="line"></div><div class="line">	<span class="comment">/* sk-&gt;sk_err may be not zero now, if RECVERR was ordered by user</span></div><div class="line">	 * and error was received after socket entered established state.</div><div class="line">	 * Hence, it is handled normally after connect() return successfully.</div><div class="line">	 */</div><div class="line">	<span class="comment">//TCP握手完成，连接已经建立</span></div><div class="line">	sock-&gt;state = SS_CONNECTED;</div><div class="line">	err = <span class="number">0</span>;</div><div class="line">out:</div><div class="line">	<span class="keyword">return</span> err;</div><div class="line"></div><div class="line"><span class="comment">//异常处理，关闭连接</span></div><div class="line">sock_error:</div><div class="line">	err = sock_error(sk) ? : -ECONNABORTED;</div><div class="line">	sock-&gt;state = SS_UNCONNECTED;</div><div class="line">	<span class="keyword">if</span> (sk-&gt;sk_prot-&gt;disconnect(sk, flags))</div><div class="line">		sock-&gt;state = SS_DISCONNECTING;</div><div class="line">	<span class="keyword">goto</span> out;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>__inet_stream_connect检查地址长度和协议族</li>
<li>检查sock状态，正常情况下状态为SS_UNCONNECTED</li>
<li>sk-&gt;sk_prot-&gt;connect tcp_v4_connect来发送syn</li>
<li>在syn包发完以后会有两种处理情况</li>
</ul>
<blockquote>
<p>情况1:立即返回，针对于非阻塞socket，此时协议栈正在处理握手connect会返回-EINPROGRESS<br>情况2:阻塞运行</p>
<blockquote>
<p>阻塞时间超时后，connect返回-EINPROGRESS<br>收到信号，connect返回-ERESTARTSYS,-EINTR</p>
</blockquote>
</blockquote>
<h3 id="inet-wait-for-connect函数分析"><a href="#inet-wait-for-connect函数分析" class="headerlink" title="inet_wait_for_connect函数分析"></a>inet_wait_for_connect函数分析</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">long</span> <span class="title">inet_wait_for_connect</span><span class="params">(struct sock *sk, <span class="keyword">long</span> timeo, <span class="keyword">int</span> writebias)</span></span></div><div class="line">&#123;</div><div class="line">	DEFINE_WAIT(wait);</div><div class="line"></div><div class="line">	prepare_to_wait(sk_sleep(sk), &amp;wait, TASK_INTERRUPTIBLE);</div><div class="line">	sk-&gt;sk_write_pending += writebias;</div><div class="line"></div><div class="line">	<span class="comment">/* Basic assumption: if someone sets sk-&gt;sk_err, he _must_</span></div><div class="line">	 * change state of the socket from TCP_SYN_*.</div><div class="line">	 * Connect() does not allow to get error notifications</div><div class="line">	 * without closing the socket.</div><div class="line">	 */</div><div class="line">	<span class="keyword">while</span> ((<span class="number">1</span> &lt;&lt; sk-&gt;sk_state) &amp; (TCPF_SYN_SENT | TCPF_SYN_RECV)) &#123;</div><div class="line">		release_sock(sk);<span class="comment">/*等下要睡眠了释放sk锁*/</span></div><div class="line">		</div><div class="line">		</div><div class="line">		timeo = schedule_timeout(timeo);</div><div class="line">		<span class="comment">/*</span></div><div class="line">		* 调用schedule_timeout sleep until timeout</div><div class="line">		* 收到信号后，timeout值返回剩余等待时间</div><div class="line">		* 超时timeout后，返回0</div><div class="line">		*/</div><div class="line">		</div><div class="line">		<span class="comment">/*进程被唤醒后新上sk锁*/</span></div><div class="line">		lock_sock(sk);</div><div class="line">		</div><div class="line">		<span class="comment">/*进程有带处理信号，或者睡眠超时，推出循环*/</span></div><div class="line">		<span class="keyword">if</span> (signal_pending(current) || !timeo)</div><div class="line">			<span class="keyword">break</span>;</div><div class="line">		prepare_to_wait(sk_sleep(sk), &amp;wait, TASK_INTERRUPTIBLE);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="comment">/*等待结束后，将进程从等待队列删除，标记为TASK_RUNNING*/</span></div><div class="line">	finish_wait(sk_sleep(sk), &amp;wait);</div><div class="line">	sk-&gt;sk_write_pending -= writebias;</div><div class="line">	<span class="keyword">return</span> timeo;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>睡眠前进程被设置成TASK_INTERRUPTIBLE状态</li>
<li>SO_SNDTIMEO选项对上述的睡眠非常重要</li>
<li>SO_SNDTIMEO被设置，则睡眠时间会安装设置值</li>
<li>SO_SNDTIMEO没有被设置，则在没有收到信号前一只阻塞</li>
<li>睡眠结束，进程从睡眠队列中删除，并标记为TASK_RUNNING</li>
</ul>
<h3 id="prepare-to-wait实现分析"><a href="#prepare-to-wait实现分析" class="headerlink" title="prepare_to_wait实现分析"></a>prepare_to_wait实现分析</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">prepare_to_wait</span><span class="params">(<span class="keyword">wait_queue_head_t</span> *q, <span class="keyword">wait_queue_t</span> *wait, <span class="keyword">int</span> state)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</div><div class="line"></div><div class="line">	wait-&gt;flags &amp;= ~WQ_FLAG_EXCLUSIVE;</div><div class="line">	spin_lock_irqsave(&amp;q-&gt;lock, flags);</div><div class="line">	<span class="keyword">if</span> (list_empty(&amp;wait-&gt;task_list))</div><div class="line">		__add_wait_queue(q, wait);</div><div class="line">	set_current_state(state);</div><div class="line">	spin_unlock_irqrestore(&amp;q-&gt;lock, flags);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>prepare_to_wait(sk_sleep(sk), &amp;wait, TASK_INTERRUPTIBLE);</li>
<li>把wait放入q队列中，设置当前进程状态为TASK_INTERRUPTIBLE</li>
<li>TASK_INTERRUPTIBLE 是一种睡眠信号</li>
<li>标记TASK_INTERRUPTIBLE的信号会被唤醒并处理信号</li>
</ul>
<h3 id="阻塞socket唤醒机制"><a href="#阻塞socket唤醒机制" class="headerlink" title="阻塞socket唤醒机制"></a>阻塞socket唤醒机制</h3><p>[root@localhost stp]# stap bt.stp sock_def_wakeup</p>
<blockquote>
<p>WARNING: Missing unwind data for a module, rerun with ‘stap -d e1000’<br>—————-START————————-<br>In process [swapper/2]<br>RIP: ffffffff81558150<br>RSP: ffff88003fd03970  EFLAGS: 00000246<br>RAX: 0000000000004308 RBX: ffff88003a82a6c0 RCX: 0000000000000000<br>RDX: 0000000050000000 RSI: 0000000000ca00c8 RDI: ffff88003a82a6c0<br>RBP: ffff88003fd03988 R08: ffff88003db89708 R09: ffff88003e001800<br>R10: ffffffff815dabca R11: 0000000000000000 R12: ffff88001bfa3700<br>R13: ffff880002db6762 R14: 0000000000000218 R15: ffff880002db675a<br>FS:  0000000000000000(0000) GS:ffff88003fd00000(0000) knlGS:0000000000000000<br>CS:  0010 DS: 0000 ES: 0000 CR0: 000000008005003b<br>CR2: 00007ffaf3049072 CR3: 000000003b0b7000 CR4: 00000000000406e0<br> 0xffffffff81558150 : sock_def_wakeup+0x0/0x40 [kernel]<br> 0xffffffff815cbc09 : tcp_finish_connect+0xc9/0x120 [kernel]<br> 0xffffffff815cc297 : tcp_rcv_state_process+0x637/0xf20 [kernel]<br> 0xffffffff815d5ffb : tcp_v4_do_rcv+0x17b/0x340 [kernel]<br> 0xffffffff815d76d9 : tcp_v4_rcv+0x799/0x9a0 [kernel]<br> 0xffffffff815b1094 : ip_local_deliver_finish+0xb4/0x1f0 [kernel]<br> 0xffffffff815b1379 : ip_local_deliver+0x59/0xd0 [kernel]<br> 0xffffffff815b0d1a : ip_rcv_finish+0x8a/0x350 [kernel]<br> 0xffffffff815b16a6 : ip_rcv+0x2b6/0x410 [kernel]<br> 0xffffffff815700d2 : <strong>netif_receive_skb_core+0x582/0x800 [kernel]<br> 0xffffffff81570368 : </strong>netif_receive_skb+0x18/0x60 [kernel]<br> 0xffffffff815703f0 : netif_receive_skb_internal+0x40/0xc0 [kernel]<br> 0xffffffff81571578 : napi_gro_receive+0xd8/0x130 [kernel]<br> 0xffffffffa00472fc [e1000]<br>—————-END————————-</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">tcp_finish_connect</span><span class="params">(struct sock *sk, struct sk_buff *skb)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tcp_sock</span> *<span class="title">tp</span> = <span class="title">tcp_sk</span>(<span class="title">sk</span>);</span></div><div class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inet_connection_sock</span> *<span class="title">icsk</span> = <span class="title">inet_csk</span>(<span class="title">sk</span>);</span></div><div class="line"></div><div class="line">	tcp_set_state(sk, TCP_ESTABLISHED);</div><div class="line"></div><div class="line">	<span class="keyword">if</span> (skb != <span class="literal">NULL</span>) &#123;</div><div class="line">		icsk-&gt;icsk_af_ops-&gt;sk_rx_dst_set(sk, skb);</div><div class="line">		security_inet_conn_established(sk, skb);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">/* Make sure socket is routed, for correct metrics.  */</span></div><div class="line">	icsk-&gt;icsk_af_ops-&gt;rebuild_header(sk);</div><div class="line"></div><div class="line">	tcp_init_metrics(sk);</div><div class="line"></div><div class="line">	tcp_init_congestion_control(sk);</div><div class="line"></div><div class="line">	<span class="comment">/* Prevent spurious tcp_cwnd_restart() on first data</span></div><div class="line">	 * packet.</div><div class="line">	 */</div><div class="line">	tp-&gt;lsndtime = tcp_time_stamp;</div><div class="line"></div><div class="line">	tcp_init_buffer_space(sk);</div><div class="line"></div><div class="line">	<span class="keyword">if</span> (sock_flag(sk, SOCK_KEEPOPEN))</div><div class="line">		inet_csk_reset_keepalive_timer(sk, keepalive_time_when(tp));</div><div class="line"></div><div class="line">	<span class="keyword">if</span> (!tp-&gt;rx_opt.snd_wscale)</div><div class="line">		__tcp_fast_path_on(tp, tp-&gt;snd_wnd);</div><div class="line">	<span class="keyword">else</span></div><div class="line">		tp-&gt;pred_flags = <span class="number">0</span>;</div><div class="line"></div><div class="line">	<span class="keyword">if</span> (!sock_flag(sk, SOCK_DEAD)) &#123;</div><div class="line">		<span class="comment">/*握手完成唤醒所有进程*/</span></div><div class="line">		sk-&gt;sk_state_change(sk);</div><div class="line">		sk_wake_async(sk, SOCK_WAKE_IO, POLL_OUT);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>sock_def_wakeup -&gt;wake_up_interruptible_all </li>
<li>上述过程发声在三次握手完成后，TCP从syn send或者syn rcv切换到establish状态时候发生</li>
<li>tcp_finish_connect-&gt;sk-&gt;sk_state_change[sock_def_wakeup]</li>
<li>此次唤醒是全部唤醒sk上等待队列的进程</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;connect&quot;&gt;&lt;a href=&quot;#connect&quot; class=&quot;headerlink&quot; title=&quot;connect()&quot;&gt;&lt;/a&gt;connect()&lt;/h1&gt;&lt;p&gt;内核版本：3.10.0-514.16.1.el7.x86_64&lt;br&gt;下述源码分析均以tcp socket为背景&lt;/p&gt;
&lt;h2 id=&quot;用户态函数&quot;&gt;&lt;a href=&quot;#用户态函数&quot; class=&quot;headerlink&quot; title=&quot;用户态函数&quot;&gt;&lt;/a&gt;用户态函数&lt;/h2&gt;&lt;p&gt;int connect(int sockfd, const struct sockaddr *addr,socklen_t addrlen);&lt;br&gt;参数：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;socketfd socket文件描述索引下标&lt;br&gt;addr 要连接的服务端的地址&lt;br&gt;addrlen addr的长度&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;实例:&lt;br&gt;&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;sockaddr_in&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;remote_addr&lt;/span&gt;;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;memset&lt;/span&gt;(&amp;amp;remote_addr,&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,&lt;span class=&quot;keyword&quot;&gt;sizeof&lt;/span&gt;(remote_addr));&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;remote_addr.sin_family=AF_INET;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;remote_addr.sin_addr.s_addr=inet_addr(&lt;span class=&quot;string&quot;&gt;&quot;180.97.33.108&quot;&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;remote_addr.sin_port = htons(&lt;span class=&quot;number&quot;&gt;80&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;connect(fd,(struct sockaddr*)&amp;amp;remote_addr,&lt;span class=&quot;keyword&quot;&gt;sizeof&lt;/span&gt;(struct sockaddr)&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="socket" scheme="https://vcpu.github.io/categories/socket/"/>
    
    
      <category term="socket" scheme="https://vcpu.github.io/tags/socket/"/>
    
      <category term="tcp/ip" scheme="https://vcpu.github.io/tags/tcp-ip/"/>
    
      <category term="kernel3.10.0-514.16.1" scheme="https://vcpu.github.io/tags/kernel3-10-0-514-16-1/"/>
    
  </entry>
  
  <entry>
    <title>socket()实现源码分析</title>
    <link href="https://vcpu.github.io/2017/06/09/socket/"/>
    <id>https://vcpu.github.io/2017/06/09/socket/</id>
    <published>2017-06-09T10:03:12.000Z</published>
    <updated>2017-06-09T10:03:12.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="socket"><a href="#socket" class="headerlink" title="socket()"></a>socket()</h1><p>内核版本：3.10.0-514.16.1.el7.x86_64</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;          /* See NOTES */</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">socket</span><span class="params">(<span class="keyword">int</span> domain, <span class="keyword">int</span> type, <span class="keyword">int</span> protocol)</span></span>;</div><div class="line">fd=socket(PF_INET,SOCK_STREAM,<span class="number">0</span></div></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="1-接口说明："><a href="#1-接口说明：" class="headerlink" title="(1).接口说明："></a>(1).接口说明：</h2><h3 id="按照顺序可传入如下参数："><a href="#按照顺序可传入如下参数：" class="headerlink" title="按照顺序可传入如下参数："></a>按照顺序可传入如下参数：</h3><ul>
<li>PF_INEAT</li>
<li>SOCK_STREAM,SOCK_DGRAM,SOCK_RAW</li>
<li>IPPROTO_TCP,IPPROTO_UDP,IPPROTO_IP</li>
</ul>
<h3 id="返回值说明"><a href="#返回值说明" class="headerlink" title="返回值说明"></a>返回值说明</h3><ul>
<li>EAFNOSUPPORT 不支持地址类型</li>
<li>EMFILE     进程文件表溢出</li>
<li>ENFILE 核心内存不足无法建立新的socket</li>
<li>EINVAL 参数domain/type/protocol不合法</li>
<li>EACCES 权限不允许</li>
<li>ENOBUFS/ENOMEM 内存不足</li>
<li>EPROTONOSUPPORT domain指定的类型不支持参数type或者protocol</li>
</ul>
<h2 id="2-内核调用栈"><a href="#2-内核调用栈" class="headerlink" title="(2).内核调用栈"></a>(2).内核调用栈</h2><p><img src="/myimages/socket.png" alt="socket"></p>
<h2 id="3-结构体说明"><a href="#3-结构体说明" class="headerlink" title="(3).结构体说明"></a>(3).结构体说明</h2><blockquote>
<p>struct socket</p>
<blockquote>
<p>面向用户态的结构体<br>基于虚拟文件系统创建<br>创建socket时最先创建的结构体</p>
</blockquote>
<p>struct sock </p>
<blockquote>
<p>网络层socket</p>
</blockquote>
<p>struct inet_sock</p>
<blockquote>
<p>INET域socket表示<br>提供INET域的一些属性，TTL、 组播、 地址 、端口</p>
</blockquote>
<p>struct raw_socket、struct udp—sock、 struct inet_connection_sock </p>
<blockquote>
<p>是对struct inet_sock的扩展<br>struct raw_socket要处理ICMP<br>struct udp_sock udp协议socket<br>struct inet_connection_sock面向连接socket<br>struct tcp_sock TCP协议socket ，对inet_connection_sock扩展，增加了滑动窗口等拥塞控制属性<br>struct inet_timewait_sock网络层超时控制使用<br>struct tcp_timewait_sock TCP协议超时控制使用</p>
</blockquote>
</blockquote>
<h2 id="4-struct-socket创建源码分析"><a href="#4-struct-socket创建源码分析" class="headerlink" title="(4).struct socket创建源码分析"></a>(4).struct socket创建源码分析</h2><h3 id="4-1-sock-alloc函数"><a href="#4-1-sock-alloc函数" class="headerlink" title="(4.1).sock_alloc函数"></a>(4.1).sock_alloc函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> struct socket *<span class="title">sock_alloc</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span>;</span></div><div class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">socket</span> *<span class="title">sock</span>;</span></div><div class="line"></div><div class="line">	inode = new_inode_pseudo(sock_mnt-&gt;mnt_sb);</div><div class="line">	<span class="keyword">if</span> (!inode)</div><div class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line"></div><div class="line">	sock = SOCKET_I(inode);</div><div class="line"></div><div class="line">	kmemcheck_annotate_bitfield(sock, type);</div><div class="line">	inode-&gt;i_ino = get_next_ino();</div><div class="line">	inode-&gt;i_mode = S_IFSOCK | S_IRWXUGO;</div><div class="line">	inode-&gt;i_uid = current_fsuid();</div><div class="line">	inode-&gt;i_gid = current_fsgid();</div><div class="line">	inode-&gt;i_op = &amp;sockfs_inode_ops;</div><div class="line"></div><div class="line">	this_cpu_add(sockets_in_use, <span class="number">1</span>);</div><div class="line">	<span class="keyword">return</span> sock;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>一起申请两块内存struct socket和struct inode</li>
<li>两块内存用struct socket_alloc联系起来</li>
<li>inode是linux用来刻画一个存放在内存中的文件的</li>
<li>socket是一种网络文件类型，可以通过文件描述符使用read和write等文件操作函数操作socket</li>
<li>有了inode就支持了虚拟文件系统的操作</li>
</ul>
<h3 id="4-2-sock-alloc-gt-new-inode-pseudo-gt-alloc-inode"><a href="#4-2-sock-alloc-gt-new-inode-pseudo-gt-alloc-inode" class="headerlink" title="(4.2).sock_alloc-&gt;new_inode_pseudo-&gt;alloc_inode"></a>(4.2).sock_alloc-&gt;new_inode_pseudo-&gt;alloc_inode</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="function">struct inode *<span class="title">new_inode_pseudo</span><span class="params">(struct super_block *sb)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span> = <span class="title">alloc_inode</span>(<span class="title">sb</span>);</span></div><div class="line"></div><div class="line">	<span class="keyword">if</span> (inode) &#123;</div><div class="line">		spin_lock(&amp;inode-&gt;i_lock);</div><div class="line">		inode-&gt;i_state = <span class="number">0</span>;</div><div class="line">		spin_unlock(&amp;inode-&gt;i_lock);</div><div class="line">		INIT_LIST_HEAD(&amp;inode-&gt;i_sb_list);</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> inode;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">static</span> struct inode *<span class="title">alloc_inode</span><span class="params">(struct super_block *sb)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span>;</span></div><div class="line"></div><div class="line">	<span class="keyword">if</span> (sb-&gt;s_op-&gt;alloc_inode)</div><div class="line">		inode = sb-&gt;s_op-&gt;alloc_inode(sb);</div><div class="line">	<span class="keyword">else</span></div><div class="line">		inode = kmem_cache_alloc(inode_cachep, GFP_KERNEL);</div><div class="line"></div><div class="line">	<span class="keyword">if</span> (!inode)</div><div class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line"></div><div class="line">	<span class="keyword">if</span> (unlikely(inode_init_always(sb, inode))) &#123;</div><div class="line">		<span class="keyword">if</span> (inode-&gt;i_sb-&gt;s_op-&gt;destroy_inode)</div><div class="line">			inode-&gt;i_sb-&gt;s_op-&gt;destroy_inode(inode);</div><div class="line">		<span class="keyword">else</span></div><div class="line">			kmem_cache_free(inode_cachep, inode);</div><div class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">return</span> inode;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>alloc_inode获取内存有两种方式 1.通过自己alloc_inode分配 2.从高速缓存中分配</li>
</ul>
<h3 id="4-3-alloc-inode-gt-sock-alloc-inode"><a href="#4-3-alloc-inode-gt-sock-alloc-inode" class="headerlink" title="(4.3).alloc_inode -&gt; sock_alloc_inode"></a>(4.3).alloc_inode -&gt; sock_alloc_inode</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> struct inode *<span class="title">sock_alloc_inode</span><span class="params">(struct super_block *sb)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">socket_alloc</span> *<span class="title">ei</span>;</span></div><div class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">socket_wq</span> *<span class="title">wq</span>;</span></div><div class="line"></div><div class="line">	ei = kmem_cache_alloc(sock_inode_cachep, GFP_KERNEL);</div><div class="line">	<span class="keyword">if</span> (!ei)</div><div class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">	wq = kmalloc(<span class="keyword">sizeof</span>(*wq), GFP_KERNEL);</div><div class="line">	<span class="keyword">if</span> (!wq) &#123;</div><div class="line">		kmem_cache_free(sock_inode_cachep, ei);</div><div class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">	&#125;</div><div class="line">	init_waitqueue_head(&amp;wq-&gt;wait);</div><div class="line">	wq-&gt;fasync_list = <span class="literal">NULL</span>;</div><div class="line">	RCU_INIT_POINTER(ei-&gt;socket.wq, wq);</div><div class="line"></div><div class="line">	ei-&gt;socket.state = SS_UNCONNECTED;</div><div class="line">	ei-&gt;socket.flags = <span class="number">0</span>;</div><div class="line">	ei-&gt;socket.ops = <span class="literal">NULL</span>;</div><div class="line">	ei-&gt;socket.sk = <span class="literal">NULL</span>;</div><div class="line">	ei-&gt;socket.file = <span class="literal">NULL</span>;</div><div class="line"></div><div class="line">	<span class="keyword">return</span> &amp;ei-&gt;vfs_inode;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>socket结构体最终会调用上述函数申请内存</li>
<li>该函数会在sock_init中被注册和挂载到系统上</li>
</ul>
<h3 id="4-4-sock-init-中sock-allok-inode挂载过程"><a href="#4-4-sock-init-中sock-allok-inode挂载过程" class="headerlink" title="(4.4).sock_init 中sock_allok_inode挂载过程"></a>(4.4).sock_init 中sock_allok_inode挂载过程</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">err = register_filesystem(&amp;sock_fs_type);</div><div class="line">	<span class="keyword">if</span> (err)</div><div class="line">		<span class="keyword">goto</span> out_fs;</div><div class="line">	sock_mnt = kern_mount(&amp;sock_fs_type);</div><div class="line">	<span class="keyword">if</span> (IS_ERR(sock_mnt)) &#123;</div><div class="line">		err = PTR_ERR(sock_mnt);</div><div class="line">		<span class="keyword">goto</span> out_mount;</div><div class="line">	...</div><div class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_system_type</span> <span class="title">sock_fs_type</span> = &#123;</span></div><div class="line">	.name =		<span class="string">"sockfs"</span>,</div><div class="line">	.mount =	sockfs_mount,</div><div class="line">	.kill_sb =	kill_anon_super,</div><div class="line">&#125;;</div><div class="line"><span class="function"><span class="keyword">static</span> struct dentry *<span class="title">sockfs_mount</span><span class="params">(struct file_system_type *fs_type,</span></span></div><div class="line">			 <span class="keyword">int</span> flags, <span class="keyword">const</span> <span class="keyword">char</span> *dev_name, <span class="keyword">void</span> *data)</div><div class="line">&#123;</div><div class="line">	<span class="keyword">return</span> mount_pseudo(fs_type, <span class="string">"socket:"</span>, &amp;sockfs_ops,</div><div class="line">		&amp;sockfs_dentry_operations, SOCKFS_MAGIC);</div><div class="line">&#125;</div><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">super_operations</span> <span class="title">sockfs_ops</span> = &#123;</span></div><div class="line">	.alloc_inode	= sock_alloc_inode,</div><div class="line">	.destroy_inode	= sock_destroy_inode,</div><div class="line">	.statfs		= simple_statfs,</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<ul>
<li>sock_init -&gt; register mount -&gt; sock_fs_type-&gt;sockfs_mount-&gt;sockfs_ops-&gt;sock_alloc_node</li>
</ul>
<h3 id="4-5-pf-gt-create-即TCP／IP协议族的创建函数inet-create初始化步骤"><a href="#4-5-pf-gt-create-即TCP／IP协议族的创建函数inet-create初始化步骤" class="headerlink" title="(4.5).pf-&gt;create 即TCP／IP协议族的创建函数inet_create初始化步骤"></a>(4.5).pf-&gt;create 即TCP／IP协议族的创建函数inet_create初始化步骤</h3><h4 id="4-5-1-PF-INET协议族的create函数inet-create会被组册"><a href="#4-5-1-PF-INET协议族的create函数inet-create会被组册" class="headerlink" title="(4.5.1).PF_INET协议族的create函数inet_create会被组册"></a>(4.5.1).PF_INET协议族的create函数inet_create会被组册</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">(<span class="keyword">void</span>)sock_register(&amp;inet_family_ops);</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">net_proto_family</span> <span class="title">inet_family_ops</span> = &#123;</span></div><div class="line">	.family = PF_INET,</div><div class="line">	.create = inet_create,</div><div class="line">	.owner	= THIS_MODULE,</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h4 id="4-5-2-注册过程"><a href="#4-5-2-注册过程" class="headerlink" title="(4.5.2).注册过程"></a>(4.5.2).注册过程</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">sock_register</span><span class="params">(<span class="keyword">const</span> struct net_proto_family *ops)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span> err;</div><div class="line"></div><div class="line">	<span class="keyword">if</span> (ops-&gt;family &gt;= NPROTO) &#123;</div><div class="line">		printk(KERN_CRIT <span class="string">"protocol %d &gt;= NPROTO(%d)\n"</span>, ops-&gt;family,</div><div class="line">		       NPROTO);</div><div class="line">		<span class="keyword">return</span> -ENOBUFS;</div><div class="line">	&#125;</div><div class="line">	spin_lock(&amp;net_family_lock);</div><div class="line">	<span class="keyword">if</span> (rcu_dereference_protected(net_families[ops-&gt;family],</div><div class="line">				      lockdep_is_held(&amp;net_family_lock)))</div><div class="line">		err = -EEXIST;</div><div class="line">	<span class="keyword">else</span> &#123;</div><div class="line">		rcu_assign_pointer(net_families[ops-&gt;family], ops);</div><div class="line">		err = <span class="number">0</span>;</div><div class="line">	&#125;</div><div class="line">	spin_unlock(&amp;net_family_lock);</div><div class="line">	printk(KERN_INFO <span class="string">"NET: Registered protocol family %d\n"</span>, ops-&gt;family);</div><div class="line">	<span class="keyword">return</span> err;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>协议族选项ops会根基协议族类型PF_INET被放置到net_families系统全局变量中</li>
</ul>
<h4 id="4-5-3-sock-create使用过程"><a href="#4-5-3-sock-create使用过程" class="headerlink" title="(4.5.3).__sock_create使用过程"></a>(4.5.3).__sock_create使用过程</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">socket.c/__sock_create</div><div class="line">...</div><div class="line">rcu_read_lock();</div><div class="line">	pf = rcu_dereference(net_families[family]);</div><div class="line">	err = -EAFNOSUPPORT;</div><div class="line">	<span class="keyword">if</span> (!pf)</div><div class="line">		<span class="keyword">goto</span> out_release;</div><div class="line">	<span class="comment">/*</span></div><div class="line">	 * We will call the -&gt;create function, that possibly is in a loadable</div><div class="line">	 * module, so we have to bump that loadable module refcnt first.</div><div class="line">	 */</div><div class="line">	<span class="keyword">if</span> (!try_module_get(pf-&gt;owner))</div><div class="line">		<span class="keyword">goto</span> out_release;</div><div class="line"></div><div class="line">	<span class="comment">/* Now protected by module ref count */</span></div><div class="line">	rcu_read_unlock();</div><div class="line"></div><div class="line">	err = pf-&gt;create(net, sock, protocol, kern);</div><div class="line">	<span class="keyword">if</span> (err &lt; <span class="number">0</span>)</div><div class="line">		<span class="keyword">goto</span> out_module_put;</div></pre></td></tr></table></figure>
<ul>
<li>根据socket传输过来的协议族PF_INET查找全局变量net_families获取ops</li>
<li>通过ops-&gt;create调用inet_create根据具体协议创建网络层socket struct sock</li>
</ul>
<h3 id="4-6-inet-create都干了什么？"><a href="#4-6-inet-create都干了什么？" class="headerlink" title="(4.6).inet_create都干了什么？"></a>(4.6).inet_create都干了什么？</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">inet_create</span><span class="params">(struct net *net, struct socket *sock, <span class="keyword">int</span> protocol,</span></span></div><div class="line">		       <span class="keyword">int</span> kern)</div><div class="line">&#123;</div><div class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *<span class="title">sk</span>;</span></div><div class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inet_protosw</span> *<span class="title">answer</span>;</span></div><div class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inet_sock</span> *<span class="title">inet</span>;</span></div><div class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">proto</span> *<span class="title">answer_prot</span>;</span></div><div class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> answer_flags;</div><div class="line">	<span class="keyword">int</span> try_loading_module = <span class="number">0</span>;</div><div class="line">	<span class="keyword">int</span> err;</div><div class="line"></div><div class="line">	<span class="keyword">if</span> (protocol &lt; <span class="number">0</span> || protocol &gt;= IPPROTO_MAX)</div><div class="line">		<span class="keyword">return</span> -EINVAL;</div><div class="line"></div><div class="line">	sock-&gt;state = SS_UNCONNECTED;<span class="comment">//步骤1:设置socket状态SS_UNCONNECTED</span></div><div class="line"></div><div class="line">	<span class="comment">/* Look for the requested type/protocol pair. */</span></div><div class="line">lookup_protocol:</div><div class="line">	err = -ESOCKTNOSUPPORT;</div><div class="line">	rcu_read_lock();／／步骤<span class="number">2</span>:根据socket协议找到inet处理函数 connect、bind、accept、listen、等</div><div class="line">	list_for_each_entry_rcu(answer, &amp;inetsw[sock-&gt;type], <span class="built_in">list</span>) &#123;</div><div class="line"></div><div class="line">		err = <span class="number">0</span>;</div><div class="line">		<span class="comment">/* Check the non-wild match. */</span></div><div class="line">		<span class="keyword">if</span> (protocol == answer-&gt;protocol) &#123;</div><div class="line">			<span class="keyword">if</span> (protocol != IPPROTO_IP)</div><div class="line">				<span class="keyword">break</span>;</div><div class="line">		&#125; <span class="keyword">else</span> &#123;</div><div class="line">			<span class="comment">/* Check for the two wild cases. */</span></div><div class="line">			<span class="keyword">if</span> (IPPROTO_IP == protocol) &#123;</div><div class="line">				protocol = answer-&gt;protocol;</div><div class="line">				<span class="keyword">break</span>;</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">if</span> (IPPROTO_IP == answer-&gt;protocol)</div><div class="line">				<span class="keyword">break</span>;</div><div class="line">		&#125;</div><div class="line">		err = -EPROTONOSUPPORT;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">if</span> (unlikely(err)) &#123;</div><div class="line">		<span class="keyword">if</span> (try_loading_module &lt; <span class="number">2</span>) &#123;</div><div class="line">			rcu_read_unlock();</div><div class="line">			<span class="comment">/*</span></div><div class="line">			 * Be more specific, e.g. net-pf-2-proto-132-type-1</div><div class="line">			 * (net-pf-PF_INET-proto-IPPROTO_SCTP-type-SOCK_STREAM)</div><div class="line">			 */</div><div class="line">			<span class="keyword">if</span> (++try_loading_module == <span class="number">1</span>)</div><div class="line">				request_module(<span class="string">"net-pf-%d-proto-%d-type-%d"</span>,</div><div class="line">					       PF_INET, protocol, sock-&gt;type);</div><div class="line">			<span class="comment">/*</span></div><div class="line">			 * Fall back to generic, e.g. net-pf-2-proto-132</div><div class="line">			 * (net-pf-PF_INET-proto-IPPROTO_SCTP)</div><div class="line">			 */</div><div class="line">			<span class="keyword">else</span></div><div class="line">				request_module(<span class="string">"net-pf-%d-proto-%d"</span>,</div><div class="line">					       PF_INET, protocol);</div><div class="line">			<span class="keyword">goto</span> lookup_protocol;</div><div class="line">		&#125; <span class="keyword">else</span></div><div class="line">			<span class="keyword">goto</span> out_rcu_unlock;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	err = -EPERM;</div><div class="line">	<span class="keyword">if</span> (sock-&gt;type == SOCK_RAW &amp;&amp; !kern &amp;&amp;</div><div class="line">	    !ns_capable(net-&gt;user_ns, CAP_NET_RAW))</div><div class="line">		<span class="keyword">goto</span> out_rcu_unlock;</div><div class="line">／／步骤<span class="number">3</span>: 把协协议的inet操作集合赋值给socket结构的ops</div><div class="line">	sock-&gt;ops = answer-&gt;ops;</div><div class="line">	answer_prot = answer-&gt;prot;</div><div class="line">	answer_flags = answer-&gt;flags;</div><div class="line">	rcu_read_unlock();</div><div class="line"></div><div class="line">	WARN_ON(answer_prot-&gt;slab == <span class="literal">NULL</span>);</div><div class="line"></div><div class="line">	err = -ENOBUFS;</div><div class="line">	／／步骤<span class="number">4</span>:申请<span class="class"><span class="keyword">struct</span> <span class="title">sock</span>结构体，并切把协议操作集合赋值给<span class="title">sock</span>结构体</span></div><div class="line">	／／<span class="title">sk</span>-&gt;<span class="title">sk_prot</span> = <span class="title">sk</span>-&gt;<span class="title">sk_prot_creator</span> =协议操作集合;</div><div class="line">	sk = sk_alloc(net, PF_INET, GFP_KERNEL, answer_prot);</div><div class="line">	<span class="keyword">if</span> (sk == <span class="literal">NULL</span>)</div><div class="line">		<span class="keyword">goto</span> out;</div><div class="line"></div><div class="line">	err = <span class="number">0</span>;</div><div class="line">	<span class="keyword">if</span> (INET_PROTOSW_REUSE &amp; answer_flags)</div><div class="line">		sk-&gt;sk_reuse = SK_CAN_REUSE;</div><div class="line">／／步骤<span class="number">5</span>：inet_sock进行相关初始化</div><div class="line">	inet = inet_sk(sk);</div><div class="line">	inet-&gt;is_icsk = (INET_PROTOSW_ICSK &amp; answer_flags) != <span class="number">0</span>;</div><div class="line"></div><div class="line">	inet-&gt;nodefrag = <span class="number">0</span>;</div><div class="line"></div><div class="line">	<span class="keyword">if</span> (SOCK_RAW == sock-&gt;type) &#123;</div><div class="line">		inet-&gt;inet_num = protocol;</div><div class="line">		<span class="keyword">if</span> (IPPROTO_RAW == protocol)</div><div class="line">			inet-&gt;hdrincl = <span class="number">1</span>;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">if</span> (net-&gt;sysctl_ip_no_pmtu_disc)</div><div class="line">		inet-&gt;pmtudisc = IP_PMTUDISC_DONT;</div><div class="line">	<span class="keyword">else</span></div><div class="line">		inet-&gt;pmtudisc = IP_PMTUDISC_WANT;</div><div class="line"></div><div class="line">	inet-&gt;inet_id = <span class="number">0</span>;</div><div class="line"></div><div class="line">	sock_init_data(sock, sk);</div><div class="line"></div><div class="line">	sk-&gt;sk_destruct	   = inet_sock_destruct;</div><div class="line">	sk-&gt;sk_protocol	   = protocol;</div><div class="line">	sk-&gt;sk_backlog_rcv = sk-&gt;sk_prot-&gt;backlog_rcv;</div><div class="line"></div><div class="line">	inet-&gt;uc_ttl	= <span class="number">-1</span>;</div><div class="line">	inet-&gt;mc_loop	= <span class="number">1</span>;</div><div class="line">	inet-&gt;mc_ttl	= <span class="number">1</span>;</div><div class="line">	inet-&gt;mc_all	= <span class="number">1</span>;</div><div class="line">	inet-&gt;mc_index	= <span class="number">0</span>;</div><div class="line">	inet-&gt;mc_list	= <span class="literal">NULL</span>;</div><div class="line">	inet-&gt;rcv_tos	= <span class="number">0</span>;</div><div class="line"></div><div class="line">	sk_refcnt_debug_inc(sk);</div><div class="line"></div><div class="line">	<span class="keyword">if</span> (inet-&gt;inet_num) &#123;</div><div class="line">		<span class="comment">/* It assumes that any protocol which allows</span></div><div class="line">		 * the user to assign a number at socket</div><div class="line">		 * creation time automatically</div><div class="line">		 * shares.</div><div class="line">		 */</div><div class="line">		inet-&gt;inet_sport = htons(inet-&gt;inet_num);</div><div class="line">		<span class="comment">/* Add to protocol hash chains. */</span></div><div class="line">		sk-&gt;sk_prot-&gt;hash(sk);</div><div class="line">	&#125;</div><div class="line">／／步骤<span class="number">6</span>:调用协议层初始化函数tcp_v4_init_sock()进行始化</div><div class="line">	<span class="keyword">if</span> (sk-&gt;sk_prot-&gt;init) &#123;</div><div class="line">		err = sk-&gt;sk_prot-&gt;init(sk);</div><div class="line">		<span class="keyword">if</span> (err)</div><div class="line">			sk_common_release(sk);</div><div class="line">	&#125;</div><div class="line">out:</div><div class="line">	<span class="keyword">return</span> err;</div><div class="line">out_rcu_unlock:</div><div class="line">	rcu_read_unlock();</div><div class="line">	<span class="keyword">goto</span> out;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>设置socket状态SS_UNCONNECTED</li>
<li>根据协议类型找到具体的协议类型操作集合，例如协议处理函数tcp_proc和inet层处理函数集合inet_stream_ops</li>
<li>socket-&gt;ops 获得协议操作集合inet_stream_ops</li>
<li>申请sock，并把tcp_proc赋值给它 sk-&gt;sk_prot = sk-&gt;sk_prot_creator=tcp_proc</li>
<li>把申请的sock和inet_sock进行初始化</li>
<li>sk-&gt;sk_prot-&gt;init(sk) 调用tcp_proc深度初始化TCP相关信息</li>
</ul>
<p>尽管流程主要干了上述的事情，仍需要深入探究的问题是：<br>a. inet_protosw inet_protosw初始化过程如何？<br>b. inet_sock和sock是什么关系？<br>c. 从inet_protosw获取的prot和ops哪些结构体上会记录使用？</p>
<h4 id="4-6-1-inet-protosw初始化过程如何？"><a href="#4-6-1-inet-protosw初始化过程如何？" class="headerlink" title="(4.6.1).inet_protosw初始化过程如何？"></a>(4.6.1).inet_protosw初始化过程如何？</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">inet_protosw</span> <span class="title">inetsw_array</span>[] =</span></div><div class="line">&#123;</div><div class="line">	&#123;</div><div class="line">		.type =       SOCK_STREAM,</div><div class="line">		.protocol =   IPPROTO_TCP,</div><div class="line">		.prot =       &amp;tcp_prot,</div><div class="line">		.ops =        &amp;inet_stream_ops,</div><div class="line">		.flags =      INET_PROTOSW_PERMANENT |</div><div class="line">			      INET_PROTOSW_ICSK,</div><div class="line">	&#125;,</div><div class="line">	&#123;</div><div class="line">		.type =       SOCK_DGRAM,</div><div class="line">		.protocol =   IPPROTO_UDP,</div><div class="line">		.prot =       &amp;udp_prot,</div><div class="line">		.ops =        &amp;inet_dgram_ops,</div><div class="line">		.flags =      INET_PROTOSW_PERMANENT,</div><div class="line">       &#125;,</div><div class="line"></div><div class="line">       &#123;</div><div class="line">		.type =       SOCK_DGRAM,</div><div class="line">		.protocol =   IPPROTO_ICMP,</div><div class="line">		.prot =       &amp;ping_prot,</div><div class="line">		.ops =        &amp;inet_dgram_ops,</div><div class="line">		.flags =      INET_PROTOSW_REUSE,</div><div class="line">       &#125;,</div><div class="line">       &#123;</div><div class="line">	       .type =       SOCK_RAW,</div><div class="line">	       .protocol =   IPPROTO_IP,	<span class="comment">/* wild card */</span></div><div class="line">	       .prot =       &amp;raw_prot,</div><div class="line">	       .ops =        &amp;inet_sockraw_ops,</div><div class="line">	       .flags =      INET_PROTOSW_REUSE,</div><div class="line">       &#125;</div><div class="line">&#125;;</div><div class="line"><span class="comment">//inet_init</span></div><div class="line">	<span class="keyword">for</span> (q = inetsw_array; q &lt; &amp;inetsw_array[INETSW_ARRAY_LEN]; ++q)</div><div class="line">		inet_register_protosw(q);</div><div class="line">		</div><div class="line"><span class="comment">//inet_protosw放入全局inetsw管理</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">inet_register_protosw</span><span class="params">(struct inet_protosw *p)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">lh</span>;</span></div><div class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inet_protosw</span> *<span class="title">answer</span>;</span></div><div class="line">	<span class="keyword">int</span> protocol = p-&gt;protocol;</div><div class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">last_perm</span>;</span></div><div class="line"></div><div class="line">	spin_lock_bh(&amp;inetsw_lock);</div><div class="line"></div><div class="line">	<span class="keyword">if</span> (p-&gt;type &gt;= SOCK_MAX)</div><div class="line">		<span class="keyword">goto</span> out_illegal;</div><div class="line"></div><div class="line">	<span class="comment">/* If we are trying to override a permanent protocol, bail. */</span></div><div class="line">	answer = <span class="literal">NULL</span>;</div><div class="line">	last_perm = &amp;inetsw[p-&gt;type];</div><div class="line">	list_for_each(lh, &amp;inetsw[p-&gt;type]) &#123;</div><div class="line">		answer = list_entry(lh, struct inet_protosw, <span class="built_in">list</span>);</div><div class="line"></div><div class="line">		<span class="comment">/* Check only the non-wild match. */</span></div><div class="line">		<span class="keyword">if</span> (INET_PROTOSW_PERMANENT &amp; answer-&gt;flags) &#123;</div><div class="line">			<span class="keyword">if</span> (protocol == answer-&gt;protocol)</div><div class="line">				<span class="keyword">break</span>;</div><div class="line">			last_perm = lh;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		answer = <span class="literal">NULL</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span> (answer)</div><div class="line">		<span class="keyword">goto</span> out_permanent;</div><div class="line">	<span class="comment">/* Add the new entry after the last permanent entry if any, so that</span></div><div class="line">	 * the new entry does not override a permanent entry when matched with</div><div class="line">	 * a wild-card protocol. But it is allowed to override any existing</div><div class="line">	 * non-permanent entry.  This means that when we remove this entry, the</div><div class="line">	 * system automatically returns to the old behavior.</div><div class="line">	 */</div><div class="line">	list_add_rcu(&amp;p-&gt;<span class="built_in">list</span>, last_perm);</div><div class="line">out:</div><div class="line">	spin_unlock_bh(&amp;inetsw_lock);</div><div class="line">	<span class="keyword">return</span>;</div><div class="line">out_permanent:</div><div class="line">	pr_err(<span class="string">"Attempt to override permanent protocol %d\n"</span>, protocol);</div><div class="line">	<span class="keyword">goto</span> out;</div><div class="line">out_illegal:</div><div class="line">	pr_err(<span class="string">"Ignoring attempt to register invalid socket type %d\n"</span>,</div><div class="line">	       p-&gt;type);</div><div class="line">	<span class="keyword">goto</span> out;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>inet_init 会把inet_protosw方式inet_sw中</li>
<li>inet_protosw很重要，其含有协议的具体操作函数tcp_close,tcp_v4_connect,tcp_recvmsg等</li>
<li>inet_protosw，内还包含inet层操作函数 inet_bind,inet_accept,inet_bind,inet_listen等</li>
</ul>
<h4 id="4-6-2-inet-sock和sock是什么关系？"><a href="#4-6-2-inet-sock和sock是什么关系？" class="headerlink" title="(4.6.2). inet_sock和sock是什么关系？"></a>(4.6.2). inet_sock和sock是什么关系？</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div></pre></td><td class="code"><pre><div class="line"><span class="function">struct sock *<span class="title">sk_alloc</span><span class="params">(struct net *net, <span class="keyword">int</span> family, <span class="keyword">gfp_t</span> priority,</span></span></div><div class="line">		      struct proto *prot)</div><div class="line">&#123;</div><div class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *<span class="title">sk</span>;</span></div><div class="line"></div><div class="line">	sk = sk_prot_alloc(prot, priority | __GFP_ZERO, family);</div><div class="line">	<span class="keyword">if</span> (sk) &#123;</div><div class="line">		sk-&gt;sk_family = family;</div><div class="line">		<span class="comment">/*</span></div><div class="line">		 * See comment in struct sock definition to understand</div><div class="line">		 * why we need sk_prot_creator -acme</div><div class="line">		 */</div><div class="line">		sk-&gt;sk_prot = sk-&gt;sk_prot_creator = prot;</div><div class="line">		sock_lock_init(sk);</div><div class="line">		sock_net_set(sk, get_net(net));</div><div class="line">		atomic_set(&amp;sk-&gt;sk_wmem_alloc, <span class="number">1</span>);</div><div class="line"></div><div class="line">		sock_update_classid(sk);</div><div class="line">		sock_update_netprioidx(sk);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">return</span> sk;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">static</span> struct sock *<span class="title">sk_prot_alloc</span><span class="params">(struct proto *prot, <span class="keyword">gfp_t</span> priority,</span></span></div><div class="line">		<span class="keyword">int</span> family)</div><div class="line">&#123;</div><div class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *<span class="title">sk</span>;</span></div><div class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache</span> *<span class="title">slab</span>;</span></div><div class="line"></div><div class="line">	slab = prot-&gt;slab;</div><div class="line">	<span class="keyword">if</span> (slab != <span class="literal">NULL</span>) &#123;</div><div class="line">		sk = kmem_cache_alloc(slab, priority &amp; ~__GFP_ZERO);</div><div class="line">		<span class="keyword">if</span> (!sk)</div><div class="line">			<span class="keyword">return</span> sk;</div><div class="line">		<span class="keyword">if</span> (priority &amp; __GFP_ZERO) &#123;</div><div class="line">			<span class="keyword">if</span> (prot-&gt;clear_sk)</div><div class="line">				prot-&gt;clear_sk(sk, prot-&gt;obj_size);</div><div class="line">			<span class="keyword">else</span></div><div class="line">				sk_prot_clear_nulls(sk, prot-&gt;obj_size);</div><div class="line">		&#125;</div><div class="line">	&#125; <span class="keyword">else</span></div><div class="line">		sk = kmalloc(prot-&gt;obj_size, priority);<span class="comment">//申请内存大小为prot的objsize</span></div><div class="line"></div><div class="line">	<span class="keyword">if</span> (sk != <span class="literal">NULL</span>) &#123;</div><div class="line">		kmemcheck_annotate_bitfield(sk, flags);</div><div class="line"></div><div class="line">		<span class="keyword">if</span> (security_sk_alloc(sk, family, priority))</div><div class="line">			<span class="keyword">goto</span> out_free;</div><div class="line"></div><div class="line">		<span class="keyword">if</span> (!try_module_get(prot-&gt;owner))</div><div class="line">			<span class="keyword">goto</span> out_free_sec;</div><div class="line">		sk_tx_queue_clear(sk);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">return</span> sk;</div><div class="line"></div><div class="line">out_free_sec:</div><div class="line">	security_sk_free(sk);</div><div class="line">out_free:</div><div class="line">	<span class="keyword">if</span> (slab != <span class="literal">NULL</span>)</div><div class="line">		kmem_cache_free(slab, sk);</div><div class="line">	<span class="keyword">else</span></div><div class="line">		kfree(sk);</div><div class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><em>从上述sk_alloc  -&gt; sk_prot_alloc -&gt; obj_size</em></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proto</span> <span class="title">tcp_prot</span> = &#123;</span></div><div class="line">	.name			= <span class="string">"TCP"</span>,</div><div class="line">	.owner			= THIS_MODULE,</div><div class="line">	.close			= tcp_close,</div><div class="line">	.connect		= tcp_v4_connect,</div><div class="line">	.disconnect		= tcp_disconnect,</div><div class="line">	.accept			= inet_csk_accept,</div><div class="line">	.ioctl			= tcp_ioctl,</div><div class="line">	.init			= tcp_v4_init_sock,</div><div class="line">	.destroy		= tcp_v4_destroy_sock,</div><div class="line">	.shutdown		= tcp_shutdown,</div><div class="line">	.setsockopt		= tcp_setsockopt,</div><div class="line">	.getsockopt		= tcp_getsockopt,</div><div class="line">	.recvmsg		= tcp_recvmsg,</div><div class="line">	.sendmsg		= tcp_sendmsg,</div><div class="line">	.sendpage		= tcp_sendpage,</div><div class="line">	.backlog_rcv		= tcp_v4_do_rcv,</div><div class="line">	.release_cb		= tcp_release_cb,</div><div class="line">	.hash			= inet_hash,</div><div class="line">	.unhash			= inet_unhash,</div><div class="line">	.get_port		= inet_csk_get_port,</div><div class="line">	.enter_memory_pressure	= tcp_enter_memory_pressure,</div><div class="line">	.stream_memory_free	= tcp_stream_memory_free,</div><div class="line">	.sockets_allocated	= &amp;tcp_sockets_allocated,</div><div class="line">	.orphan_count		= &amp;tcp_orphan_count,</div><div class="line">	.memory_allocated	= &amp;tcp_memory_allocated,</div><div class="line">	.memory_pressure	= &amp;tcp_memory_pressure,</div><div class="line">	.sysctl_wmem		= sysctl_tcp_wmem,</div><div class="line">	.sysctl_rmem		= sysctl_tcp_rmem,</div><div class="line">	.max_header		= MAX_TCP_HEADER,</div><div class="line">	.obj_size		= <span class="keyword">sizeof</span>(struct tcp_sock),</div><div class="line">	.slab_flags		= SLAB_DESTROY_BY_RCU,</div><div class="line">	.twsk_prot		= &amp;tcp_timewait_sock_ops,</div><div class="line">	.rsk_prot		= &amp;tcp_request_sock_ops,</div><div class="line">	.h.hashinfo		= &amp;tcp_hashinfo,</div><div class="line">	.no_autobind		= <span class="literal">true</span>,</div><div class="line">#ifdef CONFIG_COMPAT</div><div class="line">	.compat_setsockopt	= compat_tcp_setsockopt,</div><div class="line">	.compat_getsockopt	= compat_tcp_getsockopt,</div><div class="line">#endif</div><div class="line">#ifdef CONFIG_MEMCG_KMEM</div><div class="line">	.init_cgroup		= tcp_init_cgroup,</div><div class="line">	.destroy_cgroup		= tcp_destroy_cgroup,</div><div class="line">	.proto_cgroup		= tcp_proto_cgroup,</div><div class="line">#endif</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<ul>
<li>struct tcp_sock 包含strcut inet_sock 包含 struct sock</li>
<li>上述结构体为互相包含的关系</li>
<li>实际上在申请sock时候，申请内存大小为tcp_sock大小，也就是说三个结构体共同诞生了</li>
</ul>
<h4 id="4-6-3-从inet-protosw获取的prot和ops哪些结构体上会记录使用？"><a href="#4-6-3-从inet-protosw获取的prot和ops哪些结构体上会记录使用？" class="headerlink" title="(4.6.3). 从inet_protosw获取的prot和ops哪些结构体上会记录使用？"></a>(4.6.3). 从inet_protosw获取的prot和ops哪些结构体上会记录使用？</h4><blockquote>
<p>struct socket会在inet_create函数中获取到ops<br>    sock-&gt;ops = answer-&gt;ops;<br>struct sock在sk_allloc函数中获取pro<br>  sk-&gt;sk_prot = sk-&gt;sk_prot_creator = prot;</p>
</blockquote>
<h2 id="5-socket与文件系统"><a href="#5-socket与文件系统" class="headerlink" title="(5).socket与文件系统"></a>(5).socket与文件系统</h2><p>socket与文件系统关联通过sock_map_fd完成</p>
<p>其步骤如下：</p>
<blockquote>
<p>1:获取fd get_unused_fd_flags</p>
<blockquote>
<p>该函数从当前进程管理的files获取可用的fd</p>
</blockquote>
<p>2:申请file sock_alloc_file</p>
<blockquote>
<p>将struct socket放到file的private_data管理 file-&gt;private_data = sock</p>
</blockquote>
<p>3:将file根据当前fd安装到current-&gt;files中</p>
<blockquote>
<p>files有一个指针fdt<br>fdt-&gt;fd是一个类型为file指针的数组，数组下标为fd<br>rcu_assign_pointer(fdt-&gt;fd[fd], file); 将file安装fd为数组下标放到current-&gt;files管理</p>
</blockquote>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;socket&quot;&gt;&lt;a href=&quot;#socket&quot; class=&quot;headerlink&quot; title=&quot;socket()&quot;&gt;&lt;/a&gt;socket()&lt;/h1&gt;&lt;p&gt;内核版本：3.10.0-514.16.1.el7.x86_64&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;sys/types.h&amp;gt;          /* See NOTES */&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;sys/socket.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;socket&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; domain, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; type, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; protocol)&lt;/span&gt;&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;fd=socket(PF_INET,SOCK_STREAM,&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="socket" scheme="https://vcpu.github.io/categories/socket/"/>
    
    
      <category term="socket" scheme="https://vcpu.github.io/tags/socket/"/>
    
      <category term="tcp/ip" scheme="https://vcpu.github.io/tags/tcp-ip/"/>
    
      <category term="kernel3.10.0-514.16.1" scheme="https://vcpu.github.io/tags/kernel3-10-0-514-16-1/"/>
    
  </entry>
  
  <entry>
    <title>systemtap使用调试记录（一）</title>
    <link href="https://vcpu.github.io/2017/06/05/systemtap%E4%BD%BF%E7%94%A8%E8%B0%83%E8%AF%95%E8%AE%B0%E5%BD%95%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>https://vcpu.github.io/2017/06/05/systemtap使用调试记录（一）/</id>
    <published>2017-06-05T10:15:52.000Z</published>
    <updated>2017-06-05T10:15:52.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="systemtap使用调试记录（一）"><a href="#systemtap使用调试记录（一）" class="headerlink" title="systemtap使用调试记录（一）"></a>systemtap使用调试记录（一）</h1><h2 id="一、调试环境介绍"><a href="#一、调试环境介绍" class="headerlink" title="一、调试环境介绍"></a>一、调试环境介绍</h2><pre><code>Linux 3.10.0-514.16.1.el7.x86_64 
kernel-devel-3.10.0-514.16.1.el7.x86_64.rpm 同版本的开发头文件
kernel-debuginfo-common-x86_64-3.10.0-514.16.1.el7.x86_64.rpm
kernel-debuginfo-3.10.0-514.16.1.el7.x86_64.rpm 同版本调试数据包
linux-3.10.0-514.16.1.el7.tar.xz 同版本的源码
</code></pre><p><a href="https://centos.pkgs.org/7/centos-updates-x86_64/kernel-devel-3.10.0-514.16.1.el7.x86_64.rpm.html" target="_blank" rel="external"><em>kernel开发头文件下载地址</em></a><br><a href="http://debuginfo.centos.org/7/x86_64/kernel-debuginfo-3.10.0-514.16.1.el7.x86_64.rpm" target="_blank" rel="external"><em>kernel调试包下载地址</em></a><br><a href="http://debuginfo.centos.org/7/x86_64/kernel-debuginfo-common-x86_64-3.10.0-514.16.1.el7.x86_64.rpm" target="_blank" rel="external"><em>kernel调试common包下载地址</em></a><br><a href="https://wiki.centos.org/zh/HowTos/I_need_the_Kernel_Source#head-963cd44439b8c10fa507fa0c90725029c060108a" target="_blank" rel="external">根据当前虚拟机获取内核代码的方法</a></p>
<a id="more"></a>
<h2 id="二、centos7安装方法"><a href="#二、centos7安装方法" class="headerlink" title="二、centos7安装方法"></a>二、centos7安装方法</h2><pre><code>yum install *.rpm  安装上述3个（debugifo,devel,debuginfo-common）rpm包
yum install systemtap
stap -ve &apos;probe begin { log(&quot;hello world&quot;) exit() }&apos;
</code></pre><p>测试正常结果如下：    </p>
<blockquote>
<p>[root@localhost qinlong]# stap -ve ‘probe begin { log(“hello world”) exit() }’<br>Pass 1: parsed user script and 120 library scripts using 227352virt/40488res/3260shr/37400data kb, in 260usr/30sys/338real ms.<br>Pass 2: analyzed script: 1 probe, 2 functions, 0 embeds, 0 globals using 228540virt/41804res/3420shr/38588data kb, in 10usr/0sys/6real ms.<br>Pass 3: translated to C into “/tmp/stap5CqHmN/stap_f7a5084b8a638f5ce64a31271684ef1f_1133_src.c” using 228672virt/42408res/3996shr/38720data kb, in 0usr/0sys/0real ms.<br>Pass 4: compiled C into “stap_f7a5084b8a638f5ce64a31271684ef1f_1133.ko” in 1000usr/330sys/1247real ms.<br>Pass 5: starting run.<br>hello world<br>Pass 5: run completed in 10usr/40sys/362real ms.</p>
</blockquote>
<h2 id="三、通用案例"><a href="#三、通用案例" class="headerlink" title="三、通用案例"></a>三、通用案例</h2><h3 id="1-函数调用栈打印"><a href="#1-函数调用栈打印" class="headerlink" title="1.函数调用栈打印"></a>1.函数调用栈打印</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">[root@localhost stp]# cat bt.stp</div><div class="line">	probe kernel.function(@1)&#123;</div><div class="line">	    print(&quot;----------------START-------------------------\n&quot;)</div><div class="line">	    printf(&quot;In process [%s]\n&quot;, execname())</div><div class="line">	    print_regs()</div><div class="line">	    print_backtrace()</div><div class="line">	    print(&quot;----------------END-------------------------\n&quot;)</div><div class="line">	    exit()</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p>打印内核函数的调用栈</p>
<blockquote>
<p>[root@localhost stp]# stap bt.stp tcp_sendmsg<br>—————-START————————-<br>In process [sshd]<br>RIP: ffffffff815c1ee0<br>RSP: ffff88003d217d28  EFLAGS: 00000202<br>RAX: ffffffff81aa20a0 RBX: ffff88003d217e38 RCX: 0000000000000024<br>RDX: ffff88003d217da8 RSI: ffff88003b3b87c0 RDI: ffff88003d217e38<br>RBP: ffff88003d217d50 R08: 0000000000000000 R09: 0000000000000000<br>R10: ffff88003d217da8 R11: 0000000000000000 R12: ffff88003d217e38<br>R13: 0000000000000001 R14: ffff88003d217e28 R15: ffff8800274d3480<br>FS:  00007f03e5514840(0000) GS:ffff88003fd00000(0000) knlGS:0000000000000000<br>CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033<br>CR2: 00007f19c6dc8000 CR3: 0000000035a5c000 CR4: 00000000000406e0<br> 0xffffffff815c1ee0 : tcp_sendmsg+0x0/0xc40 [kernel]<br> 0xffffffff815ed254 : inet_sendmsg+0x64/0xb0 [kernel]<br> 0xffffffff81554e07 : sock_aio_write+0x157/0x180 [kernel]<br> 0xffffffff811fdf3d : do_sync_write+0x8d/0xd0 [kernel]<br> 0xffffffff811fe8a5 : vfs_write+0x1b5/0x1e0 [kernel]<br> 0xffffffff811ff2cf : sys_write+0x7f/0xe0 [kernel]<br> 0xffffffff81697189 : system_call_fastpath+0x16/0x1b [kernel]<br>—————-END————————-</p>
</blockquote>
<h3 id="2-函数的调用过程"><a href="#2-函数的调用过程" class="headerlink" title="2.函数的调用过程"></a>2.函数的调用过程</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">[root@localhost stp]# cat socket-trace.stp</div><div class="line">probe kernel.function(&quot;*@net/socket.c&quot;).call&#123;</div><div class="line">	printf(&quot;%s -&gt; %s\n&quot;,thread_indent(1),ppfunc())</div><div class="line">&#125;</div><div class="line">probe kernel.function(&quot;*@net/socket.c&quot;).return&#123;</div><div class="line">	printf(&quot;%s&lt;-%s\n&quot;,thread_indent(-1),ppfunc())</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>thread_indent(1)     打印程序名称（线程id）<br>ppfunc() 打印出执行函数符号</p>
<p>kernel.function(“<em>@net/socket.c”).call<br>调用net/socket.c 文件中函数时候会触发函数体执行打印动作<br>kernel.function(“</em>@net/socket.c”).return<br>调用net/socket.c文件中函数执行完成返回后会触发函数体打印动作</p>
<blockquote>
<p>[root@localhost stp]# stap socket-trace.stp<br>  0 dndX11(3295): -&gt; SyS_recvmsg<br>  0 dndX11(3295): -&gt; <strong>sys_recvmsg<br>  0 dndX11(3295): -&gt; sockfd_lookup_light<br>  0 dndX11(3295):&lt;-sockfd_lookup<em>light<br>  1 dndX11(3295): -&gt; </em></strong>sys_recvmsg<br>  3 dndX11(3295): -&gt; sock_recvmsg<br>  7 dndX11(3295):&lt;-sock_recvmsg<br>  8 dndX11(3295):&lt;-<strong>_sys_recvmsg<br>  9 dndX11(3295):&lt;-</strong>sys_recvmsg<br> 10 dndX11(3295):&lt;-SyS_recvmsg<br>25274 dndX11(3295): -&gt; SyS_recvmsg<br>25279 dndX11(3295): -&gt; <strong>sys_recvmsg<br>25281 dndX11(3295): -&gt; sockfd_lookup_light<br>25284 dndX11(3295):&lt;-sockfd_lookup<em>light<br>25285 dndX11(3295): -&gt; </em></strong>sys_recvmsg<br>25288 dndX11(3295): -&gt; sock_recvmsg<br>25291 dndX11(3295):&lt;-sock_recvmsgx</p>
</blockquote>
<h3 id="3-打印协议栈函数中某一行数据"><a href="#3-打印协议栈函数中某一行数据" class="headerlink" title="3.打印协议栈函数中某一行数据"></a>3.打印协议栈函数中某一行数据</h3><p>/home/qinlong/rpmbuild/SOURCES/linux-3.10.0-514.16.1.el7/net/ipv4/tcp.c<br>局部源码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">1065 int tcp_sendmsg(struct kiocb *iocb, struct sock *sk, struct msghdr *msg,</div><div class="line">1066                 size_t size)</div><div class="line">1067 &#123;</div><div class="line">1068         struct iovec *iov;</div><div class="line">1069         struct tcp_sock *tp = tcp_sk(sk);</div><div class="line">1070         struct sk_buff *skb;</div><div class="line">1071         int iovlen, flags, err, copied = 0;</div><div class="line">1072         int mss_now = 0, size_goal, copied_syn = 0, offset = 0;</div><div class="line">1073         bool sg;</div><div class="line">1074         long timeo;</div><div class="line">1075</div><div class="line">1076         lock_sock(sk);</div><div class="line">1077</div><div class="line">1078         flags = msg-&gt;msg_flags;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[root@localhost ~]# stap -L &apos;kernel.statement(&quot;*@net/ipv4/tcp.c:1078&quot;)&apos;</div><div class="line">kernel.statement(&quot;tcp_sendmsg@net/ipv4/tcp.c:1078&quot;) $iocb:struct kiocb* $sk:struct sock* $msg:struct msghdr* $size:size_t $copied:int $mss_now:int $size_goal:int $copied_syn:int $offset:int $timeo:long int</div></pre></td></tr></table></figure>
<p>执行上述函数，可确代码具体的函数局部变量<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">$iocb:struct kiocb* </div><div class="line">$sk:struct sock* </div><div class="line">$msg:struct msghdr* </div><div class="line">$size:size_t </div><div class="line">$copied:int</div><div class="line">$mss_now:int </div><div class="line">$size_goal:int </div><div class="line">$copied_syn:int </div><div class="line">$offset:int </div><div class="line">$timeo:long int</div></pre></td></tr></table></figure></p>
<p>根据以上变量打印出size值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[root@localhost ~]# stap -e &apos;probe kernel.statement(&quot;*@net/ipv4/tcp.c:1078&quot;) &#123;printf(&quot;size %d \n&quot;,$size)&#125;&apos;</div><div class="line">size 36</div><div class="line">size 44</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;systemtap使用调试记录（一）&quot;&gt;&lt;a href=&quot;#systemtap使用调试记录（一）&quot; class=&quot;headerlink&quot; title=&quot;systemtap使用调试记录（一）&quot;&gt;&lt;/a&gt;systemtap使用调试记录（一）&lt;/h1&gt;&lt;h2 id=&quot;一、调试环境介绍&quot;&gt;&lt;a href=&quot;#一、调试环境介绍&quot; class=&quot;headerlink&quot; title=&quot;一、调试环境介绍&quot;&gt;&lt;/a&gt;一、调试环境介绍&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;Linux 3.10.0-514.16.1.el7.x86_64 
kernel-devel-3.10.0-514.16.1.el7.x86_64.rpm 同版本的开发头文件
kernel-debuginfo-common-x86_64-3.10.0-514.16.1.el7.x86_64.rpm
kernel-debuginfo-3.10.0-514.16.1.el7.x86_64.rpm 同版本调试数据包
linux-3.10.0-514.16.1.el7.tar.xz 同版本的源码
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;a href=&quot;https://centos.pkgs.org/7/centos-updates-x86_64/kernel-devel-3.10.0-514.16.1.el7.x86_64.rpm.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;em&gt;kernel开发头文件下载地址&lt;/em&gt;&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://debuginfo.centos.org/7/x86_64/kernel-debuginfo-3.10.0-514.16.1.el7.x86_64.rpm&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;em&gt;kernel调试包下载地址&lt;/em&gt;&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://debuginfo.centos.org/7/x86_64/kernel-debuginfo-common-x86_64-3.10.0-514.16.1.el7.x86_64.rpm&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;em&gt;kernel调试common包下载地址&lt;/em&gt;&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://wiki.centos.org/zh/HowTos/I_need_the_Kernel_Source#head-963cd44439b8c10fa507fa0c90725029c060108a&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;根据当前虚拟机获取内核代码的方法&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="linux kernel" scheme="https://vcpu.github.io/categories/linux-kernel/"/>
    
    
      <category term="systemtap" scheme="https://vcpu.github.io/tags/systemtap/"/>
    
  </entry>
  
</feed>
