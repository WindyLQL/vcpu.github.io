<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>i博客</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://vcpu.github.io/"/>
  <updated>2017-06-22T10:39:53.000Z</updated>
  <id>https://vcpu.github.io/</id>
  
  <author>
    <name>vcpu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>select</title>
    <link href="https://vcpu.github.io/select/"/>
    <id>https://vcpu.github.io/select/</id>
    <published>2017-06-22T10:39:53.000Z</published>
    <updated>2017-06-22T10:39:53.000Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> nfds, fd_set *readfds, fd_set *writefds,</span></span></div><div class="line">           fd_set *exceptfds, struct timeval *timeout);</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_CLR</span><span class="params">(<span class="keyword">int</span> fd, fd_set *<span class="built_in">set</span>)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span>  <span class="title">FD_ISSET</span><span class="params">(<span class="keyword">int</span> fd, fd_set *<span class="built_in">set</span>)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_SET</span><span class="params">(<span class="keyword">int</span> fd, fd_set *<span class="built_in">set</span>)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_ZERO</span><span class="params">(fd_set *<span class="built_in">set</span>)</span></span>;</div></pre></td></tr></table></figure>
<ul>
<li>nfds 是最大文件描述符号 +1   怎么可能这么简单，它限制的是最大值而不是个数</li>
<li>readfds 用来记录可读fd集合</li>
<li>writefds 用来记录可写fd集合</li>
<li>exceptfds 用来检查带外数据</li>
<li>timeout 决定select等待I/O时间</li>
</ul>
<blockquote>
<p>1.timeout该值为NULL，会阻塞一定等到监控的文件描述符集合中产生状态变化（可读，可写等）<br>2.timeout值为0分0毫秒，非阻塞，不关注文件描述符是否变化立刻返回<br>3.timeout正常值，timeout这段时间内阻塞，如果监控集合中有信号来临，select将返回，否则超时返回</p>
</blockquote>
<a id="more"></a>
<p>返回值：</p>
<ul>
<li>0 出发信号的fd数目</li>
<li>=0 超时</li>
<li>-1 出错 </li>
</ul>
<p>作用：<br>    用来管理fd集合，实现多fd集合监听操作</p>
<h2 id="select用户态用法"><a href="#select用户态用法" class="headerlink" title="select用户态用法"></a>select用户态用法</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MYPORT 1234    <span class="comment">// the port users will be connecting to</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> BACKLOG 5     <span class="comment">// how many pending connections queue will hold</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> BUF_SIZE 200</span></div><div class="line"></div><div class="line"><span class="keyword">int</span> fd_A[BACKLOG];    <span class="comment">// accepted connection fd</span></div><div class="line"><span class="keyword">int</span> conn_amount;    <span class="comment">// current connection amount</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">showclient</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> i;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"client amount: %d\n"</span>, conn_amount);</div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; BACKLOG; i++) &#123;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"[%d]:%d  "</span>, i, fd_A[i]);</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"\n\n"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> sock_fd, new_fd;  <span class="comment">// listen on sock_fd, new connection on new_fd</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server_addr</span>;</span>    <span class="comment">// server address information</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client_addr</span>;</span> <span class="comment">// connector's address information</span></div><div class="line">    <span class="keyword">socklen_t</span> sin_size;</div><div class="line">    <span class="keyword">int</span> yes = <span class="number">1</span>;</div><div class="line">    <span class="keyword">char</span> buf[BUF_SIZE];</div><div class="line">    <span class="keyword">int</span> ret;</div><div class="line">    <span class="keyword">int</span> i;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> ((sock_fd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>)) == <span class="number">-1</span>) &#123;</div><div class="line">        perror(<span class="string">"socket"</span>);</div><div class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (setsockopt(sock_fd, SOL_SOCKET, SO_REUSEADDR, &amp;yes, <span class="keyword">sizeof</span>(<span class="keyword">int</span>)) == <span class="number">-1</span>) &#123;</div><div class="line">        perror(<span class="string">"setsockopt"</span>);</div><div class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    server_addr.sin_family = AF_INET;</div><div class="line">    server_addr.sin_port = htons(MYPORT);</div><div class="line">    server_addr.sin_addr.s_addr = INADDR_ANY;</div><div class="line">    <span class="built_in">memset</span>(server_addr.sin_zero, <span class="string">'\0'</span>, <span class="keyword">sizeof</span>(server_addr.sin_zero));</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (bind(sock_fd, (struct sockaddr *)&amp;server_addr, <span class="keyword">sizeof</span>(server_addr)) == <span class="number">-1</span>) &#123;</div><div class="line">        perror(<span class="string">"bind"</span>);</div><div class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (listen(sock_fd, BACKLOG) == <span class="number">-1</span>) &#123;</div><div class="line">        perror(<span class="string">"listen"</span>);</div><div class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="built_in">printf</span>(<span class="string">"listen port %d\n"</span>, MYPORT);</div><div class="line"></div><div class="line">    fd_set fdsr;</div><div class="line">    <span class="keyword">int</span> maxsock;</div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>;</span></div><div class="line"></div><div class="line">    conn_amount = <span class="number">0</span>;</div><div class="line">    sin_size = <span class="keyword">sizeof</span>(client_addr);</div><div class="line">    maxsock = sock_fd;</div><div class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</div><div class="line">        <span class="comment">// initialize file descriptor set</span></div><div class="line">        FD_ZERO(&amp;fdsr);</div><div class="line">        FD_SET(sock_fd, &amp;fdsr);</div><div class="line"></div><div class="line">        <span class="comment">// timeout setting</span></div><div class="line">        tv.tv_sec = <span class="number">30</span>;</div><div class="line">        tv.tv_usec = <span class="number">0</span>;</div><div class="line"></div><div class="line">        <span class="comment">// add active connection to fd set</span></div><div class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; BACKLOG; i++) &#123;</div><div class="line">            <span class="keyword">if</span> (fd_A[i] != <span class="number">0</span>) &#123;</div><div class="line">                FD_SET(fd_A[i], &amp;fdsr);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        ret = select(maxsock + <span class="number">1</span>, &amp;fdsr, <span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;tv);</div><div class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</div><div class="line">            perror(<span class="string">"select"</span>);</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ret == <span class="number">0</span>) &#123;</div><div class="line">            <span class="built_in">printf</span>(<span class="string">"timeout\n"</span>);</div><div class="line">            <span class="keyword">continue</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// check every fd in the set</span></div><div class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; conn_amount; i++) &#123;</div><div class="line">            <span class="keyword">if</span> (FD_ISSET(fd_A[i], &amp;fdsr)) &#123;</div><div class="line">                ret = recv(fd_A[i], buf, <span class="keyword">sizeof</span>(buf), <span class="number">0</span>);</div><div class="line">                <span class="keyword">if</span> (ret &lt;= <span class="number">0</span>) &#123;        <span class="comment">// client close</span></div><div class="line">                    <span class="built_in">printf</span>(<span class="string">"client[%d] close\n"</span>, i);</div><div class="line">                    close(fd_A[i]);</div><div class="line">                    FD_CLR(fd_A[i], &amp;fdsr);</div><div class="line">                    fd_A[i] = <span class="number">0</span>;</div><div class="line">                &#125; <span class="keyword">else</span> &#123;        <span class="comment">// receive data</span></div><div class="line">                    <span class="keyword">if</span> (ret &lt; BUF_SIZE)</div><div class="line">                        <span class="built_in">memset</span>(&amp;buf[ret], <span class="string">'\0'</span>, <span class="number">1</span>);</div><div class="line">                    <span class="built_in">printf</span>(<span class="string">"client[%d] send:%s\n"</span>, i, buf);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// check whether a new connection comes</span></div><div class="line">        <span class="keyword">if</span> (FD_ISSET(sock_fd, &amp;fdsr)) &#123;</div><div class="line">            new_fd = accept(sock_fd, (struct sockaddr *)&amp;client_addr, &amp;sin_size);</div><div class="line">            <span class="keyword">if</span> (new_fd &lt;= <span class="number">0</span>) &#123;</div><div class="line">                perror(<span class="string">"accept"</span>);</div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">// add to fd queue</span></div><div class="line">            <span class="keyword">if</span> (conn_amount &lt; BACKLOG) &#123;</div><div class="line">                fd_A[conn_amount++] = new_fd;</div><div class="line">                <span class="built_in">printf</span>(<span class="string">"new connection client[%d] %s:%d\n"</span>, conn_amount,</div><div class="line">                        inet_ntoa(client_addr.sin_addr), ntohs(client_addr.sin_port));</div><div class="line">                <span class="keyword">if</span> (new_fd &gt; maxsock)</div><div class="line">                    maxsock = new_fd;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> &#123;</div><div class="line">                <span class="built_in">printf</span>(<span class="string">"max connections arrive, exit\n"</span>);</div><div class="line">                send(new_fd, <span class="string">"bye"</span>, <span class="number">4</span>, <span class="number">0</span>);</div><div class="line">                close(new_fd);</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        showclient();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// close other connections</span></div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; BACKLOG; i++) &#123;</div><div class="line">        <span class="keyword">if</span> (fd_A[i] != <span class="number">0</span>) &#123;</div><div class="line">            close(fd_A[i]);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>代码实现采用select用法描述：</p>
<blockquote>
<p>1.select作为服务端使用<br>2.select监听服务的fd，如果有客户端连接此服务端时候，服务端fd会被触发，然后调用accept完成连接<br>3.select监听服务端和客户端建立好连接的fd，如果客户端发送数据过来，select可监听到读信号，然后recv读出数据。</p>
</blockquote>
</blockquote>
<h2 id="select实现分析"><a href="#select实现分析" class="headerlink" title="select实现分析"></a>select实现分析</h2><h3 id="用户态select-系统调用-sys-select"><a href="#用户态select-系统调用-sys-select" class="headerlink" title="用户态select 系统调用 sys_select"></a>用户态select 系统调用 sys_select</h3><p> 调用栈如下：<br> 0xffffffff81213f80 : sys_select+0x0/0x110 [kernel]<br> 0xffffffff81697189 : system_call_fastpath+0x16/0x1b [kernel]</p>
<p> 实现代码位于：fs/select.c  SYSCALL_DEFINE5(select,…</p>
<h3 id="select功能概述"><a href="#select功能概述" class="headerlink" title="select功能概述"></a>select功能概述</h3><h3 id="sys-select实现分析"><a href="#sys-select实现分析" class="headerlink" title="sys_select实现分析"></a>sys_select实现分析</h3><p>分析结论：</p>
<p>sys_select<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">SYSCALL_DEFINE5(select, <span class="keyword">int</span>, n, fd_set __user *, inp, fd_set __user *, outp,</div><div class="line">		fd_set __user *, <span class="built_in">exp</span>, struct timeval __user *, tvp)</div><div class="line">&#123;</div><div class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">end_time</span>, *<span class="title">to</span> = <span class="title">NULL</span>;</span></div><div class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>;</span></div><div class="line">	<span class="keyword">int</span> ret;</div><div class="line"></div><div class="line">	<span class="comment">//用户态时间处理，将用户态时间拷入内核态并将参数规整为struct timespec以供调用</span></div><div class="line">	<span class="keyword">if</span> (tvp) &#123;</div><div class="line">		<span class="keyword">if</span> (copy_from_user(&amp;tv, tvp, <span class="keyword">sizeof</span>(tv)))</div><div class="line">			<span class="keyword">return</span> -EFAULT;</div><div class="line"></div><div class="line">		to = &amp;end_time;</div><div class="line">		<span class="keyword">if</span> (poll_select_set_timeout(to,</div><div class="line">				tv.tv_sec + (tv.tv_usec / USEC_PER_SEC),</div><div class="line">				(tv.tv_usec % USEC_PER_SEC) * NSEC_PER_USEC))</div><div class="line">			<span class="keyword">return</span> -EINVAL;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">//select的核心实现</span></div><div class="line">	ret = core_sys_select(n, inp, outp, <span class="built_in">exp</span>, to);</div><div class="line">	</div><div class="line">	<span class="comment">//该函数会将剩余的时间拷入到用户态的tvp 中</span></div><div class="line">	ret = poll_select_copy_remaining(&amp;end_time, tvp, <span class="number">1</span>, ret);</div><div class="line">	<span class="keyword">return</span> ret;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<blockquote>
<p>1.将用户态select时间参数拷入内核<br>2.调用core_sys_select<br>3.将select退出后剩余时间结果拷入用户态时间参数中</p>
</blockquote>
<p>core_sys_select<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">core_sys_select</span><span class="params">(<span class="keyword">int</span> n, fd_set __user *inp, fd_set __user *outp,</span></span></div><div class="line">			   fd_set __user *<span class="built_in">exp</span>, struct timespec *end_time)</div><div class="line">&#123;</div><div class="line">	fd_set_bits fds;</div><div class="line">	<span class="keyword">void</span> *bits;</div><div class="line">	<span class="keyword">int</span> ret, max_fds;</div><div class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> size;</div><div class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">fdtable</span> *<span class="title">fdt</span>;</span></div><div class="line">	<span class="comment">/* Allocate small arguments on the stack to save memory and be faster */</span></div><div class="line">	<span class="keyword">long</span> stack_fds[SELECT_STACK_ALLOC/<span class="keyword">sizeof</span>(<span class="keyword">long</span>)];</div><div class="line"></div><div class="line">	<span class="comment">//用户态给予参数nfds &lt; 0 ,直接返并报告参数非法 -EINVAL</span></div><div class="line">	ret = -EINVAL;</div><div class="line">	<span class="keyword">if</span> (n &lt; <span class="number">0</span>)</div><div class="line">		<span class="keyword">goto</span> out_nofds;</div><div class="line"></div><div class="line">	<span class="comment">/* max_fds can increase, so grab it once to avoid race */</span></div><div class="line">	rcu_read_lock();</div><div class="line">	fdt = files_fdtable(current-&gt;files);</div><div class="line">	max_fds = fdt-&gt;max_fds;</div><div class="line">	rcu_read_unlock();</div><div class="line">	<span class="keyword">if</span> (n &gt; max_fds)</div><div class="line">		n = max_fds;</div><div class="line"></div><div class="line">	<span class="comment">/*</span></div><div class="line">	 * We need 6 bitmaps (in/out/ex for both incoming and outgoing),</div><div class="line">	 * since we used fdset we need to allocate memory in units of</div><div class="line">	 * long-words. </div><div class="line">	 */</div><div class="line">	<span class="comment">//以一个文件描述符占1bit，传递进来的这么多fd共占多数字</span></div><div class="line">	size = FDS_BYTES(n);</div><div class="line">	bits = stack_fds;</div><div class="line">	<span class="comment">//检查默认静态数据资源是否够用</span></div><div class="line">	<span class="keyword">if</span> (size &gt; <span class="keyword">sizeof</span>(stack_fds) / <span class="number">6</span>) &#123;</div><div class="line">		<span class="comment">/* Not enough space in on-stack array; must use kmalloc */</span></div><div class="line">		ret = -ENOMEM;</div><div class="line">		bits = kmalloc(<span class="number">6</span> * size, GFP_KERNEL);</div><div class="line">		<span class="keyword">if</span> (!bits)</div><div class="line">			<span class="keyword">goto</span> out_nofds;</div><div class="line">	&#125;</div><div class="line">	<span class="comment">//fds用来指向具体的存储空间</span></div><div class="line">	fds.in      = bits;</div><div class="line">	fds.out     = bits +   size;</div><div class="line">	fds.ex      = bits + <span class="number">2</span>*size;</div><div class="line">	fds.res_in  = bits + <span class="number">3</span>*size;</div><div class="line">	fds.res_out = bits + <span class="number">4</span>*size;</div><div class="line">	fds.res_ex  = bits + <span class="number">5</span>*size;</div><div class="line"></div><div class="line"><span class="comment">//将用户空间的inp  outp exp 拷入内核空间</span></div><div class="line">	<span class="keyword">if</span> ((ret = get_fd_set(n, inp, fds.in)) ||</div><div class="line">	    (ret = get_fd_set(n, outp, fds.out)) ||</div><div class="line">	    (ret = get_fd_set(n, <span class="built_in">exp</span>, fds.ex)))</div><div class="line">		<span class="keyword">goto</span> out;</div><div class="line"></div><div class="line">	<span class="comment">//存放返回状态的字段清零，后续可用作返回结果使用</span></div><div class="line">	zero_fd_set(n, fds.res_in);</div><div class="line">	zero_fd_set(n, fds.res_out);</div><div class="line">	zero_fd_set(n, fds.res_ex);</div><div class="line"></div><div class="line">	<span class="comment">//select核心逻辑处理函数</span></div><div class="line">	ret = do_select(n, &amp;fds, end_time);</div><div class="line"></div><div class="line">	<span class="comment">//存在错误</span></div><div class="line">	<span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</div><div class="line">		<span class="keyword">goto</span> out;</div><div class="line">	<span class="comment">//超时情况</span></div><div class="line">	<span class="keyword">if</span> (!ret) &#123;</div><div class="line">		ret = -ERESTARTNOHAND;</div><div class="line">		<span class="keyword">if</span> (signal_pending(current))</div><div class="line">			<span class="keyword">goto</span> out;</div><div class="line">		ret = <span class="number">0</span>;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">//把结果集拷入用户空间</span></div><div class="line">	<span class="keyword">if</span> (set_fd_set(n, inp, fds.res_in) ||</div><div class="line">	    set_fd_set(n, outp, fds.res_out) ||</div><div class="line">	    set_fd_set(n, <span class="built_in">exp</span>, fds.res_ex))</div><div class="line">		ret = -EFAULT;</div><div class="line"></div><div class="line">out:</div><div class="line">	<span class="comment">//释放辅助内存</span></div><div class="line">	<span class="keyword">if</span> (bits != stack_fds)</div><div class="line">		kfree(bits);</div><div class="line">out_nofds:</div><div class="line">	<span class="keyword">return</span> ret;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<blockquote>
<p>1.检验nfds，如果其小于0，参数异常返回；并规整nfds（最大不能超过当前进程的max_fds）<br>2.将用户态fd集合拷入内核态<br>3.运行do_select<br>4.将do_select检测结果拷入用户空间<br>5.释放select运算中辅助内存</p>
</blockquote>
<p>do_select<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">do_select</span><span class="params">(<span class="keyword">int</span> n, fd_set_bits *fds, struct timespec *end_time)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">ktime_t</span> expire, *to = <span class="literal">NULL</span>;</div><div class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">poll_wqueues</span> <span class="title">table</span>;</span></div><div class="line">	poll_table *wait;</div><div class="line">	<span class="keyword">int</span> retval, i, timed_out = <span class="number">0</span>;</div><div class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> slack = <span class="number">0</span>;</div><div class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> busy_flag = net_busy_loop_on() ? POLL_BUSY_LOOP : <span class="number">0</span>;</div><div class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> busy_end = <span class="number">0</span>;</div><div class="line"></div><div class="line">	rcu_read_lock();</div><div class="line">	<span class="comment">//检查fd对应file状态，且找出最大fd</span></div><div class="line">	retval = max_select_fd(n, fds);</div><div class="line">	rcu_read_unlock();</div><div class="line"></div><div class="line">	<span class="keyword">if</span> (retval &lt; <span class="number">0</span>)</div><div class="line">		<span class="keyword">return</span> retval;</div><div class="line">	n = retval;</div><div class="line"></div><div class="line">	poll_initwait(&amp;table);</div><div class="line">	wait = &amp;table.pt;</div><div class="line">	<span class="comment">//传入的时间为0s 0ms time_out标记为1 这种情况不阻塞直接返回</span></div><div class="line">	<span class="keyword">if</span> (end_time &amp;&amp; !end_time-&gt;tv_sec &amp;&amp; !end_time-&gt;tv_nsec) &#123;</div><div class="line">		wait-&gt;_qproc = <span class="literal">NULL</span>;</div><div class="line">		timed_out = <span class="number">1</span>;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">//正常情况处理。 超时时间转换</span></div><div class="line">	<span class="keyword">if</span> (end_time &amp;&amp; !timed_out)</div><div class="line">		slack = select_estimate_accuracy(end_time);</div><div class="line"></div><div class="line">	retval = <span class="number">0</span>;</div><div class="line">	<span class="keyword">for</span> (;;) &#123;</div><div class="line">		<span class="keyword">unsigned</span> <span class="keyword">long</span> *rinp, *routp, *rexp, *inp, *outp, *<span class="built_in">exp</span>;</div><div class="line">		<span class="keyword">bool</span> can_busy_loop = <span class="literal">false</span>;</div><div class="line"></div><div class="line">		inp = fds-&gt;in; outp = fds-&gt;out; <span class="built_in">exp</span> = fds-&gt;ex;</div><div class="line">		rinp = fds-&gt;res_in; routp = fds-&gt;res_out; rexp = fds-&gt;res_ex;</div><div class="line"></div><div class="line">		<span class="comment">//所有监听的fd大循环</span></div><div class="line">		<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; ++rinp, ++routp, ++rexp) &#123;</div><div class="line">			<span class="keyword">unsigned</span> <span class="keyword">long</span> in, out, ex, all_bits, bit = <span class="number">1</span>, mask, j;</div><div class="line">			<span class="keyword">unsigned</span> <span class="keyword">long</span> res_in = <span class="number">0</span>, res_out = <span class="number">0</span>, res_ex = <span class="number">0</span>;</div><div class="line"></div><div class="line">			<span class="comment">//32个文件描述符号，没有任何状态被检测，进入下一轮32个</span></div><div class="line">			in = *inp++; out = *outp++; ex = *<span class="built_in">exp</span>++;</div><div class="line">			all_bits = in | out | ex;</div><div class="line">			<span class="keyword">if</span> (all_bits == <span class="number">0</span>) &#123;</div><div class="line">				i += BITS_PER_LONG;</div><div class="line">				<span class="keyword">continue</span>;</div><div class="line">			&#125;</div><div class="line">			<span class="comment">// 这一轮32个fd存在需要检测的状态</span></div><div class="line">			<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; BITS_PER_LONG; ++j, ++i, bit &lt;&lt;= <span class="number">1</span>) &#123;</div><div class="line">				<span class="class"><span class="keyword">struct</span> <span class="title">fd</span> <span class="title">f</span>;</span></div><div class="line">				<span class="comment">//超过最大待检测fd n直接退出循环</span></div><div class="line">				<span class="keyword">if</span> (i &gt;= n)</div><div class="line">					<span class="keyword">break</span>;</div><div class="line">					</div><div class="line">				<span class="comment">//跳过没有状态检测的fd</span></div><div class="line">				<span class="keyword">if</span> (!(bit &amp; all_bits))</div><div class="line">					<span class="keyword">continue</span>;</div><div class="line">					</div><div class="line">				f = fdget(i);</div><div class="line">				<span class="keyword">if</span> (f.file) &#123;</div><div class="line">					<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> *<span class="title">f_op</span>;</span></div><div class="line">					f_op = f.file-&gt;f_op;</div><div class="line">					</div><div class="line">					<span class="comment">//设置fd检测事件掩码，poll相关情况处理</span></div><div class="line">					mask = DEFAULT_POLLMASK;</div><div class="line">					<span class="keyword">if</span> (f_op &amp;&amp; f_op-&gt;poll) &#123;</div><div class="line">						<span class="comment">//设置用户需要探查的标记</span></div><div class="line">						wait_key_set(wait, in, out,</div><div class="line">							     bit, busy_flag);</div><div class="line">						<span class="comment">//获取fd当前对应的信号掩码</span></div><div class="line">						mask = (*f_op-&gt;poll)(f.file, wait);</div><div class="line">					&#125;</div><div class="line">					fdput(f);</div><div class="line">					</div><div class="line">					<span class="comment">//可读</span></div><div class="line">					<span class="keyword">if</span> ((mask &amp; POLLIN_SET) &amp;&amp; (in &amp; bit)) &#123;</div><div class="line">						res_in |= bit;</div><div class="line">						retval++;</div><div class="line">						wait-&gt;_qproc = <span class="literal">NULL</span>;</div><div class="line">					&#125;</div><div class="line">					<span class="comment">//可写</span></div><div class="line">					<span class="keyword">if</span> ((mask &amp; POLLOUT_SET) &amp;&amp; (out &amp; bit)) &#123;</div><div class="line">						res_out |= bit;</div><div class="line">						retval++;</div><div class="line">						wait-&gt;_qproc = <span class="literal">NULL</span>;</div><div class="line">					&#125;</div><div class="line">					<span class="keyword">if</span> ((mask &amp; POLLEX_SET) &amp;&amp; (ex &amp; bit)) &#123;</div><div class="line">						res_ex |= bit;</div><div class="line">						retval++;</div><div class="line">						wait-&gt;_qproc = <span class="literal">NULL</span>;</div><div class="line">					&#125;</div><div class="line">					<span class="comment">/* got something, stop busy polling */</span></div><div class="line">					<span class="keyword">if</span> (retval) &#123;</div><div class="line">						can_busy_loop = <span class="literal">false</span>;</div><div class="line">						busy_flag = <span class="number">0</span>;</div><div class="line"></div><div class="line">					<span class="comment">/*</span></div><div class="line">					 * only remember a returned</div><div class="line">					 * POLL_BUSY_LOOP if we asked for it</div><div class="line">					 */</div><div class="line">					&#125; <span class="keyword">else</span> <span class="keyword">if</span> (busy_flag &amp; mask)</div><div class="line">						can_busy_loop = <span class="literal">true</span>;</div><div class="line"></div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">			<span class="comment">//将检测结果存下来</span></div><div class="line">			<span class="keyword">if</span> (res_in)</div><div class="line">				*rinp = res_in;</div><div class="line">			<span class="keyword">if</span> (res_out)</div><div class="line">				*routp = res_out;</div><div class="line">			<span class="keyword">if</span> (res_ex)</div><div class="line">				*rexp = res_ex;</div><div class="line">				</div><div class="line">			<span class="comment">//增加抢占点 该抢占点可达到效果是：判断是否有进程需要抢占当前进程，如果是将立即发生调度</span></div><div class="line">			<span class="comment">//已经检查过的fd如果此时被唤醒，则会在此产生调度</span></div><div class="line">			cond_resched();</div><div class="line">		&#125;</div><div class="line">		wait-&gt;_qproc = <span class="literal">NULL</span>;</div><div class="line">		<span class="keyword">if</span> (retval || timed_out || signal_pending(current))</div><div class="line">			<span class="keyword">break</span>;</div><div class="line">			</div><div class="line">		<span class="comment">//设备就绪异常超时终止灯信号触发，直接break，可跳出大循环结束程序</span></div><div class="line">		<span class="keyword">if</span> (table.error) &#123;</div><div class="line">			retval = table.error;</div><div class="line">			<span class="keyword">break</span>;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="comment">/* only if found POLL_BUSY_LOOP sockets &amp;&amp; not out of time */</span></div><div class="line">		<span class="keyword">if</span> (can_busy_loop &amp;&amp; !need_resched()) &#123;</div><div class="line">			<span class="keyword">if</span> (!busy_end) &#123;</div><div class="line">				busy_end = busy_loop_end_time();</div><div class="line">				<span class="keyword">continue</span>;</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">if</span> (!busy_loop_timeout(busy_end))</div><div class="line">				<span class="keyword">continue</span>;</div><div class="line">		&#125;</div><div class="line">		busy_flag = <span class="number">0</span>;</div><div class="line"></div><div class="line">		<span class="comment">/*</span></div><div class="line">		 * If this is the first loop and we have a timeout</div><div class="line">		 * given, then we convert to ktime_t and set the to</div><div class="line">		 * pointer to the expiry value.</div><div class="line">		 */</div><div class="line">		<span class="keyword">if</span> (end_time &amp;&amp; !to) &#123;</div><div class="line">			expire = timespec_to_ktime(*end_time);</div><div class="line">			to = &amp;expire;</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		<span class="comment">//当前用户进程从这里进入睡眠，超时后timed_out 置1 直接退出</span></div><div class="line">		<span class="keyword">if</span> (!poll_schedule_timeout(&amp;table, TASK_INTERRUPTIBLE,</div><div class="line">					   to, slack))</div><div class="line">			timed_out = <span class="number">1</span>;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	poll_freewait(&amp;table);</div><div class="line">	<span class="keyword">return</span> retval;</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<p>do_select为select的核心实现，其处理过程如下：</p>
<blockquote>
<p>1.调用poll_initwait初始化poll_wqueues对象table，包括其成员poll_table；</p>
<p>2.如果用户传入的timeout不为NULL，但是设定的时间为0，那么设置poll_table指针wait(即 &amp;table.pt）为NULL；当&amp;table.pt为NULL，它并不会被加到等到队列中。</p>
<p>3.将in,out和exception进行或运算，得到all_bits，然后遍历all_bits中bit为1的fd，根据进程的fd_table查找到file指针filp，然后设置wait的key值（POLLEX_SET, POLLIN_SET,POLLIN_SET三者的或运算，取决于用户输入），并调用filp-&gt;poll(filp, wait)，获得返回值mask。 再根据mask值检查该文件是否立即满足条件，如果满足，设置res_in/res_out/res_exception的值，执行retval++, 并设置wait为NULL。</p>
<p>4.在每遍历32（取决于long型整数的位数）个文件后，调用1次cond_resched()，主动寻求调度，可以等待已经遍历过的文件是否有唤醒的；</p>
<p>5.在遍历完所有文件之后，设置wait为NULL，并检查是否有满足条件的文件（retval值是否为0），或者是否超时，或者是否有未决信号，如果有那么直接跳出循环，进入步骤7；</p>
<p>6.否则调用poll_schedule_timeout，使进程进入睡眠，直到超时（如果未设置超时，那么是直接调用的schedule()）。如果是超时后进程继续执行，那么设置pwq-&gt;triggered为0；如果是被文件对应的驱动程序唤醒的，那么pwq-&gt;triggered被设置为1.</p>
<p>   7.最终，函数调用poll_freewait，将本进程从所有文件的等待队列中删掉，并删除分配的poll_table_page对象，回收内存，并返回retval值。</p>
<p> 8.拷贝res_in, res_out和res_exception到传入的in, out, exception，并返回ret。</p>
</blockquote>
<h3 id="select睡眠过程"><a href="#select睡眠过程" class="headerlink" title="select睡眠过程"></a>select睡眠过程</h3><p>do_select</p>
<p>…<br>    步骤1<br>    poll_initwait(&amp;table);<br>    wait = &amp;table.pt;<br>…<br>    步骤2<br>    if (f_op &amp;&amp; f_op-&gt;poll) {<br>    wait_key_set(wait, in, out,<br>             bit, busy_flag);<br>    //如果是socket此处调用的是sock_poll<br>    mask = (*f_op-&gt;poll)(f.file, wait);<br>}<br>    步骤3<br>…<br>    if (!poll_schedule_timeout(&amp;table, TASK_INTERRUPTIBLE,<br>                       to, slack))</p>
<p>步骤1:初始化table<br>    struct poll_wqueues table;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">poll_initwait</span><span class="params">(struct poll_wqueues *pwq)</span></span></div><div class="line">&#123;</div><div class="line">	init_poll_funcptr(&amp;pwq-&gt;pt, __pollwait);</div><div class="line">	pwq-&gt;polling_task = current;</div><div class="line">	pwq-&gt;triggered = <span class="number">0</span>;</div><div class="line">	pwq-&gt;error = <span class="number">0</span>;</div><div class="line">	pwq-&gt;table = <span class="literal">NULL</span>;</div><div class="line">	pwq-&gt;inline_index = <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line">EXPORT_SYMBOL(poll_initwait);</div></pre></td></tr></table></figure>
<ul>
<li>将当前进程标志current给table让其记录下来</li>
<li>将__pollwait给table-&gt;pt-&gt;_qproc让其记录下来</li>
</ul>
<p>步骤2:调用sock_poll最终调用tcp_pool<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* No kernel lock held - perfect */</span></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">sock_poll</span><span class="params">(struct file *file, poll_table *wait)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> busy_flag = <span class="number">0</span>;</div><div class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">socket</span> *<span class="title">sock</span>;</span></div><div class="line"></div><div class="line">	<span class="comment">/*</span></div><div class="line">	 *      We can't return errors to poll, so it's either yes or no.</div><div class="line">	 */</div><div class="line">	sock = file-&gt;private_data;</div><div class="line"></div><div class="line">	<span class="keyword">if</span> (sk_can_busy_loop(sock-&gt;sk)) &#123;</div><div class="line">		<span class="comment">/* this socket can poll_ll so tell the system call */</span></div><div class="line">		busy_flag = POLL_BUSY_LOOP;</div><div class="line"></div><div class="line">		<span class="comment">/* once, only if requested by syscall */</span></div><div class="line">		<span class="keyword">if</span> (wait &amp;&amp; (wait-&gt;_key &amp; POLL_BUSY_LOOP))</div><div class="line">			sk_busy_loop(sock-&gt;sk, <span class="number">1</span>);</div><div class="line">	&#125;</div><div class="line">							<span class="comment">//针对于tcpsocket来讲此处调用tcp_pool</span></div><div class="line">	<span class="keyword">return</span> busy_flag | sock-&gt;ops-&gt;poll(file, sock, wait);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"> *	Wait for a TCP event.</div><div class="line"> *</div><div class="line"> *	Note that we don't need to lock the socket, as the upper poll layers</div><div class="line"> *	take care of normal races (between the test and the event) and we don't</div><div class="line"> *	go look at any of the socket buffers directly.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">tcp_poll</span><span class="params">(struct file *file, struct socket *sock, poll_table *wait)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> mask;</div><div class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *<span class="title">sk</span> = <span class="title">sock</span>-&gt;<span class="title">sk</span>;</span></div><div class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcp_sock</span> *<span class="title">tp</span> = <span class="title">tcp_sk</span>(<span class="title">sk</span>);</span></div><div class="line"></div><div class="line">	sock_rps_record_flow(sk);</div><div class="line"></div><div class="line">	sock_poll_wait(file, sk_sleep(sk), wait);</div><div class="line">	<span class="keyword">if</span> (sk-&gt;sk_state == TCP_LISTEN)</div><div class="line">		<span class="keyword">return</span> inet_csk_listen_poll(sk);</div><div class="line"></div><div class="line">	<span class="comment">/* Socket is not locked. We are protected from async events</span></div><div class="line">	 * by poll logic and correct handling of state changes</div><div class="line">	 * made by other threads is impossible in any case.</div><div class="line">	 */</div><div class="line"></div><div class="line">	mask = <span class="number">0</span>;</div><div class="line">	<span class="keyword">if</span> (sk-&gt;sk_shutdown == SHUTDOWN_MASK || sk-&gt;sk_state == TCP_CLOSE)</div><div class="line">		mask |= POLLHUP;</div><div class="line">	<span class="keyword">if</span> (sk-&gt;sk_shutdown &amp; RCV_SHUTDOWN)</div><div class="line">		mask |= POLLIN | POLLRDNORM | POLLRDHUP;</div><div class="line"></div><div class="line">	<span class="comment">/* Connected or passive Fast Open socket? */</span></div><div class="line">	<span class="keyword">if</span> (sk-&gt;sk_state != TCP_SYN_SENT &amp;&amp;</div><div class="line">	    (sk-&gt;sk_state != TCP_SYN_RECV || tp-&gt;fastopen_rsk != <span class="literal">NULL</span>)) &#123;</div><div class="line">		<span class="keyword">int</span> target = sock_rcvlowat(sk, <span class="number">0</span>, INT_MAX);</div><div class="line"></div><div class="line">		<span class="keyword">if</span> (tp-&gt;urg_seq == tp-&gt;copied_seq &amp;&amp;</div><div class="line">		    !sock_flag(sk, SOCK_URGINLINE) &amp;&amp;</div><div class="line">		    tp-&gt;urg_data)</div><div class="line">			target++;</div><div class="line"></div><div class="line">		<span class="comment">/* Potential race condition. If read of tp below will</span></div><div class="line">		 * escape above sk-&gt;sk_state, we can be illegally awaken</div><div class="line">		 * in SYN_* states. */</div><div class="line">		<span class="keyword">if</span> (tp-&gt;rcv_nxt - tp-&gt;copied_seq &gt;= target)</div><div class="line">			mask |= POLLIN | POLLRDNORM;</div><div class="line"></div><div class="line">		<span class="keyword">if</span> (!(sk-&gt;sk_shutdown &amp; SEND_SHUTDOWN)) &#123;</div><div class="line">			<span class="keyword">if</span> (sk_stream_is_writeable(sk)) &#123;</div><div class="line">				mask |= POLLOUT | POLLWRNORM;</div><div class="line">			&#125; <span class="keyword">else</span> &#123;  <span class="comment">/* send SIGIO later */</span></div><div class="line">				set_bit(SOCK_ASYNC_NOSPACE,</div><div class="line">					&amp;sk-&gt;sk_socket-&gt;flags);</div><div class="line">				set_bit(SOCK_NOSPACE, &amp;sk-&gt;sk_socket-&gt;flags);</div><div class="line"></div><div class="line">				<span class="comment">/* Race breaker. If space is freed after</span></div><div class="line">				 * wspace test but before the flags are set,</div><div class="line">				 * IO signal will be lost.</div><div class="line">				 */</div><div class="line">				<span class="keyword">if</span> (sk_stream_is_writeable(sk))</div><div class="line">					mask |= POLLOUT | POLLWRNORM;</div><div class="line">			&#125;</div><div class="line">		&#125; <span class="keyword">else</span></div><div class="line">			mask |= POLLOUT | POLLWRNORM;</div><div class="line"></div><div class="line">		<span class="keyword">if</span> (tp-&gt;urg_data &amp; TCP_URG_VALID)</div><div class="line">			mask |= POLLPRI;</div><div class="line">	&#125;</div><div class="line">	<span class="comment">/* This barrier is coupled with smp_wmb() in tcp_reset() */</span></div><div class="line">	smp_rmb();</div><div class="line">	<span class="keyword">if</span> (sk-&gt;sk_err)</div><div class="line">		mask |= POLLERR;</div><div class="line"></div><div class="line">	<span class="keyword">return</span> mask;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>收集信号状态以mask方式返回</li>
<li>调用sock_poll_wait然后poll_wait最终调用_qproc也就是__pollwait</li>
<li>__pollwait</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* Add a new entry */</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> __pollwait(struct file *filp, <span class="keyword">wait_queue_head_t</span> *wait_address,</div><div class="line">				poll_table *p)</div><div class="line">&#123;</div><div class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">poll_wqueues</span> *<span class="title">pwq</span> = <span class="title">container_of</span>(<span class="title">p</span>, <span class="title">struct</span> <span class="title">poll_wqueues</span>, <span class="title">pt</span>);</span></div><div class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">poll_table_entry</span> *<span class="title">entry</span> = <span class="title">poll_get_entry</span>(<span class="title">pwq</span>);</span></div><div class="line">	<span class="keyword">if</span> (!entry)</div><div class="line">		<span class="keyword">return</span>;</div><div class="line">	entry-&gt;filp = get_file(filp);</div><div class="line">	entry-&gt;wait_address = wait_address;</div><div class="line">	entry-&gt;key = p-&gt;_key;</div><div class="line">	init_waitqueue_func_entry(&amp;entry-&gt;wait, pollwake);</div><div class="line">	entry-&gt;wait.<span class="keyword">private</span> = pwq;</div><div class="line">	add_wait_queue(wait_address, &amp;entry-&gt;wait);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>为每个fd对应文件分配 poll_table_entry</li>
<li>将fd对应poll_table_entry加入到等待队列中</li>
</ul>
<p>步骤3:<br>    poll_schedule_timeout，作用是使进程进入睡眠，直到超时或者被唤醒<br>    如果超时后进程继续执行设置pwq-&gt;triggered为0<br>    如果是被文件对应的驱动程序唤醒pwq-&gt;triggered为1</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">poll_schedule_timeout</span><span class="params">(struct poll_wqueues *pwq, <span class="keyword">int</span> state,</span></span></div><div class="line">			  <span class="keyword">ktime_t</span> *expires, <span class="keyword">unsigned</span> <span class="keyword">long</span> slack)</div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span> rc = -EINTR;</div><div class="line"></div><div class="line">	set_current_state(state);</div><div class="line">	<span class="keyword">if</span> (!pwq-&gt;triggered)</div><div class="line">		rc = freezable_schedule_hrtimeout_range(expires, slack,</div><div class="line">							HRTIMER_MODE_ABS);</div><div class="line">	__set_current_state(TASK_RUNNING);</div><div class="line"></div><div class="line">	<span class="comment">/*</span></div><div class="line">	 * Prepare for the next iteration.</div><div class="line">	 *</div><div class="line">	 * The following set_mb() serves two purposes.  First, it's</div><div class="line">	 * the counterpart rmb of the wmb in pollwake() such that data</div><div class="line">	 * written before wake up is always visible after wake up.</div><div class="line">	 * Second, the full barrier guarantees that triggered clearing</div><div class="line">	 * doesn't pass event check of the next iteration.  Note that</div><div class="line">	 * this problem doesn't exist for the first iteration as</div><div class="line">	 * add_wait_queue() has full barrier semantics.</div><div class="line">	 */</div><div class="line">	set_mb(pwq-&gt;triggered, <span class="number">0</span>);</div><div class="line"></div><div class="line">	<span class="keyword">return</span> rc;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="select唤醒过程"><a href="#select唤醒过程" class="headerlink" title="select唤醒过程"></a>select唤醒过程</h3><p> 0xffffffff81213130 : pollwake+0x0/0x90 [kernel]<br> 0xffffffff810ba628 : <strong>wake_up_common+0x58/0x90 [kernel]<br> 0xffffffff810bc4a4 : </strong>wake_up_sync_key+0x44/0x60 [kernel]<br> 0xffffffff8155825a : sock_def_readable+0x3a/0x70 [kernel]<br> 0xffffffff815c8197 : tcp_data_queue+0x497/0xdd0 [kernel]<br> 0xffffffff815cb4a7 : tcp_rcv_established+0x217/0x760 [kernel]<br> 0xffffffff815d5f8a : tcp_v4_do_rcv+0x10a/0x340 [kernel]<br> 0xffffffff815d76d9 : tcp_v4_rcv+0x799/0x9a0 [kernel]<br> 0xffffffff815b1094 : ip_local_deliver_finish+0xb4/0x1f0 [kernel]<br> 0xffffffff815b1379 : ip_local_deliver+0x59/0xd0 [kernel]<br> 0xffffffff815b0d1a : ip_rcv_finish+0x8a/0x350 [kernel]<br> 0xffffffff815b16a6 : ip_rcv+0x2b6/0x410 [kernel]<br> 0xffffffff815700d2 : <strong>netif_receive_skb_core+0x582/0x800 [kernel]<br> 0xffffffff81570368 : </strong>netif_receive_skb+0x18/0x60 [kernel]<br> 0xffffffff815703f0 : netif_receive_skb_internal+0x40/0xc0 [kernel]<br> 0xffffffff81571578 : napi_gro_receive+0xd8/0x130 [kernel]<br> 0xffffffffa00472fc [e1000]</p>
<p> pollwake -&gt;__pollwake-&gt;default_wake_function-&gt;try_to_wake_up</p>
<p> try_to_wake_up会把进程的状态设置为TASK_RUNNING，并把进程插入CPU运行队列，来唤醒睡眠的进程</p>
<h2 id="linux-select-1024限制魔咒"><a href="#linux-select-1024限制魔咒" class="headerlink" title="linux select 1024限制魔咒"></a>linux select 1024限制魔咒</h2><p>__FD_SETSIZE 默认最大为1024，一个int占用4个byte，也就是32个bit，所以使用了一个int数组大小为32位来表示了我们要操作的fd的数值，每个bit代表了一个handle数值</p>
<p>需要注意的问题是，这里的最大为1024，如果handle数值为1025是不能处理的（而且很容易导致破坏堆栈），不是说可以容纳1024个网络客户端句柄，而是最大的handle数值为1024，再算上系统本身使用的stdout,stdin, stderr默认的3个，因此最多也就是1021个，再算上程序打开的文件句柄等等，实际上使用可能要比1024少上好多。</p>
<p>另外，ulimit对每个进程打开的句柄也有限制。</p>
<h3 id="why-1024"><a href="#why-1024" class="headerlink" title="why 1024 ?"></a>why 1024 ?</h3><p>内核参数适用结构体是fd_set</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">SYSCALL_DEFINE5(select, <span class="keyword">int</span>, n, fd_set __user *, inp, fd_set __user *, outp,</div><div class="line">		fd_set __user *, <span class="built_in">exp</span>, struct timeval __user *, tvp)</div><div class="line">&#123;</div></pre></td></tr></table></figure>
<p>fd_set是 __kernel_fd_set</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> __kernel_fd_set		fd_set;</div></pre></td></tr></table></figure>
<p>__kernel_fd_set 中fds_bits 最大只能1024 </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> __FD_SETSIZE	1024</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></div><div class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> fds_bits[__FD_SETSIZE / (<span class="number">8</span> * <span class="keyword">sizeof</span>(<span class="keyword">long</span>))];</div><div class="line">&#125; __kernel_fd_set;</div></pre></td></tr></table></figure>
<h3 id="我该怎么办才能突破1024限制？"><a href="#我该怎么办才能突破1024限制？" class="headerlink" title="我该怎么办才能突破1024限制？"></a>我该怎么办才能突破1024限制？</h3><p>修改掉此宏重新编译吧，当然还有其他办法，但是没必要这么复杂，直接用pool或者epool解决吧<br>当然你也可以多进程或者多线程，每个进程／线程 分别select</p>
<h2 id="select缺点总结"><a href="#select缺点总结" class="headerlink" title="select缺点总结"></a>select缺点总结</h2><blockquote>
<p>select效率低下，用户空间和内核空间来回拷贝，select内部吧存进程上下文切换，大型项目不适用<br>可同时监听的文件数量有限，linux平台1024个<br>每次调用select都要遍历完成所有的fd，每隔32fd需要调度一次<br>多个fd情况下，如果小的fs一直可读，会导致大的fd信号不会被收集到<br>需要在用户态和内核态来回拷贝fd_set，睡眠唤醒机制需要为fd分配poll_table_entry</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;sys/time.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;sys/types.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;unistd.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;select&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; nfds, fd_set *readfds, fd_set *writefds,&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;           fd_set *exceptfds, struct timeval *timeout);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;FD_CLR&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; fd, fd_set *&lt;span class=&quot;built_in&quot;&gt;set&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;  &lt;span class=&quot;title&quot;&gt;FD_ISSET&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; fd, fd_set *&lt;span class=&quot;built_in&quot;&gt;set&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;FD_SET&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; fd, fd_set *&lt;span class=&quot;built_in&quot;&gt;set&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;FD_ZERO&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(fd_set *&lt;span class=&quot;built_in&quot;&gt;set&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;nfds 是最大文件描述符号 +1   怎么可能这么简单，它限制的是最大值而不是个数&lt;/li&gt;
&lt;li&gt;readfds 用来记录可读fd集合&lt;/li&gt;
&lt;li&gt;writefds 用来记录可写fd集合&lt;/li&gt;
&lt;li&gt;exceptfds 用来检查带外数据&lt;/li&gt;
&lt;li&gt;timeout 决定select等待I/O时间&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;1.timeout该值为NULL，会阻塞一定等到监控的文件描述符集合中产生状态变化（可读，可写等）&lt;br&gt;2.timeout值为0分0毫秒，非阻塞，不关注文件描述符是否变化立刻返回&lt;br&gt;3.timeout正常值，timeout这段时间内阻塞，如果监控集合中有信号来临，select将返回，否则超时返回&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="socket" scheme="https://vcpu.github.io/categories/socket/"/>
    
    
      <category term="tcp/ip" scheme="https://vcpu.github.io/tags/tcp-ip/"/>
    
      <category term="select" scheme="https://vcpu.github.io/tags/select/"/>
    
      <category term="kernel3.10.0-415.16.1" scheme="https://vcpu.github.io/tags/kernel3-10-0-415-16-1/"/>
    
  </entry>
  
  <entry>
    <title>Linux系统调用</title>
    <link href="https://vcpu.github.io/Linux%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/"/>
    <id>https://vcpu.github.io/Linux系统调用/</id>
    <published>2017-06-22T10:10:14.000Z</published>
    <updated>2017-06-22T10:10:14.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么事系统调用"><a href="#什么事系统调用" class="headerlink" title="什么事系统调用"></a>什么事系统调用</h2><ul>
<li>linux虚拟地址空间分为用户空间和内核空间</li>
<li>用户空间不可直接访问内核空间，帝王班的内核空间可直接访问用户空间</li>
<li>用户空间只能通过系统调用访问内核空间</li>
<li>系统调用时内核提供的一组函数接口，使得用户空间上进程可以和内核空间交互</li>
</ul>
<h2 id="系统调用过程"><a href="#系统调用过程" class="headerlink" title="系统调用过程"></a>系统调用过程</h2><ul>
<li>执行用户程序</li>
<li>根据glibc中实现，取得系统调用号，将其存入EAX并执行int $0x80（128号中断）</li>
<li>用户态可以传递变量、参数值给内核，内核态运行时候会保存用户进程的一些寄存器值等（上下文环境）</li>
<li>触发中断后内核根据系统调用号执行对应的中断处理函数 </li>
<li>系统调用结束将访问址存入EAX，返回中断处理函数</li>
<li>中断处理函数根据存储用户态进程上下文环境恢复用户态，同时用户态就获取了内核态函数执行的返回值</li>
</ul>
<h2 id="系统调用汇编"><a href="#系统调用汇编" class="headerlink" title="系统调用汇编"></a>系统调用汇编</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">// pid = fork();</div><div class="line">asm volatile(</div><div class="line">    &quot;mov $0x2, %%eax\n\t&quot; // 将fork的系统调用号2存到eax寄存器  </div><div class="line">    &quot;int $0x80\n\t&quot;       // 产生int 0x80中断</div><div class="line">    &quot;mov %%eax,%0\n\t&quot;    // 将结果存入pid中</div><div class="line">    : &quot;=m&quot; (pid)</div></pre></td></tr></table></figure>
<h2 id="系统调用实现分析"><a href="#系统调用实现分析" class="headerlink" title="系统调用实现分析"></a>系统调用实现分析</h2><p>待续</p>
<h2 id="添加系统调用"><a href="#添加系统调用" class="headerlink" title="添加系统调用"></a>添加系统调用</h2><p>待续</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;什么事系统调用&quot;&gt;&lt;a href=&quot;#什么事系统调用&quot; class=&quot;headerlink&quot; title=&quot;什么事系统调用&quot;&gt;&lt;/a&gt;什么事系统调用&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;linux虚拟地址空间分为用户空间和内核空间&lt;/li&gt;
&lt;li&gt;用户空间不可直接访问内核
    
    </summary>
    
      <category term="linux" scheme="https://vcpu.github.io/categories/linux/"/>
    
    
      <category term="系统调用" scheme="https://vcpu.github.io/tags/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>tcp socket发送缓冲区</title>
    <link href="https://vcpu.github.io/tcp_sndbuf/"/>
    <id>https://vcpu.github.io/tcp_sndbuf/</id>
    <published>2017-06-20T10:31:48.000Z</published>
    <updated>2017-06-20T10:31:48.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="tcp-socket发送缓冲区探究结论"><a href="#tcp-socket发送缓冲区探究结论" class="headerlink" title="tcp socket发送缓冲区探究结论"></a>tcp socket发送缓冲区探究结论</h2><blockquote>
<p>1: 未设置SO_SNDBUF时，sk-&gt;sk_sndbuf值由tcp_finish_connect-&gt;tcp_init_buffer_space-&gt;tcp_sndbuf_expand决定，TCP协议栈会自己计算一个值出来46080，sk_sndbuf是46080和net.ipv4.tcp_wmem[2]（4194304）的较小值</p>
<p>2: 设置SO_SNDBUF后，tcp_sndbuf_expand将不会再被调用，其值情况完全由sock_setsockopt决定</p>
<blockquote>
<p>2-1: 设置值较小 value &lt;  2304 { SOCK_MIN_SNDBUF（4608）/2 }</p>
<blockquote>
<p>sk_sndbuf = 4608</p>
</blockquote>
<p>2-2: 设置值适中 { SOCK_MIN_SNDBUF（4608）/2 }  &lt;  value  &lt;  net.core.wmem_max</p>
<blockquote>
<p>sk_sndbuf = value*2</p>
</blockquote>
<p>2-3: 设置值较大 value &gt; net.core.wmem_max</p>
<blockquote>
<p>sk_sndbuf = net.core.wmem_max* 2</p>
</blockquote>
</blockquote>
</blockquote>
<a id="more"></a>
<h2 id="默认情况下（未设置SO-SNDBUF）"><a href="#默认情况下（未设置SO-SNDBUF）" class="headerlink" title="默认情况下（未设置SO_SNDBUF）"></a>默认情况下（未设置SO_SNDBUF）</h2><p>net.core.wmem_default = 212992<br>net.core.wmem_max = 212992<br>net.ipv4.tcp_wmem = 4096    16384 4194304</p>
<ul>
<li>TCPsocket未connect之前 sendbuf:16384 sk-&gt;sk_sndbuf是sysctl_tcp_wmem[1]的值</li>
<li>connect之后，sendbuf:46080</li>
</ul>
<p>通过调试机制可知，sendbuf默认大小为sysctl_tcp_wmem[1] 为16384<br>connect连接连接到服务端后，sendbuf变为46080，该值不是尚书配置中任何一个值</p>
<h3 id="原因探究"><a href="#原因探究" class="headerlink" title="原因探究"></a>原因探究</h3><p>阶段1:tcp_init_sock初始化，sk-&gt;sk_sndbuf = sysctl_tcp_wmem[1]</p>
<p>阶段2:主动连接进入ES状态时候，状态切换时候调用tcp_sndbuf_expand调整sk_sndbuf</p>
<p>stp脚本探测结果如下：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">tcp_v4_connect[2017/6/20,10:57:56]local=0.0.0.0:3000,remote=0.0.0.0:0 state:CLOSE,sndbubf 0:16384</div><div class="line">tcp_v4_connect return [2017/6/20,10:57:56]local=192.168.55.178:3000,remote=180.97.33.108:80 state:SYN_SENT,sndbubf 1280:16384</div><div class="line">tcp_input:302 return [2017/6/20,10:57:56]local=192.168.55.178:3000,remote=180.97.33.108:80 state:ESTABLISHED,sndbubf 0:16384 sndmem : 46080 permss 2304</div><div class="line"> 0xffffffff815c3527 : tcp_sndbuf_expand+0x67/0x90 [kernel]</div><div class="line"> 0xffffffff815c7ba8 : tcp_init_buffer_space+0x178/0x190 [kernel]</div><div class="line"> 0xffffffff815cbbae : tcp_finish_connect+0x6e/0x120 [kernel]</div><div class="line"> 0xffffffff815cc297 : tcp_rcv_state_process+0x637/0xf20 [kernel]</div><div class="line"> 0xffffffff815d5ffb : tcp_v4_do_rcv+0x17b/0x340 [kernel]</div><div class="line"> 0xffffffff815d76d9 : tcp_v4_rcv+0x799/0x9a0 [kernel]</div><div class="line"> 0xffffffff815b1094 : ip_local_deliver_finish+0xb4/0x1f0 [kernel]</div><div class="line"> 0xffffffff815b1379 : ip_local_deliver+0x59/0xd0 [kernel]</div><div class="line"> 0xffffffff815b0d1a : ip_rcv_finish+0x8a/0x350 [kernel]</div><div class="line"> 0xffffffff815b16a6 : ip_rcv+0x2b6/0x410 [kernel]</div><div class="line"> 0xffffffff815700d2 : __netif_receive_skb_core+0x582/0x800 [kernel]</div><div class="line"> 0xffffffff81570368 : __netif_receive_skb+0x18/0x60 [kernel]</div><div class="line"> 0xffffffff815703f0 : netif_receive_skb_internal+0x40/0xc0 [kernel]</div><div class="line"> 0xffffffff81571578 : napi_gro_receive+0xd8/0x130 [kernel]</div><div class="line"> 0xffffffffa00472fc [e1000]</div></pre></td></tr></table></figure></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">tcp_sndbuf_expand</span><span class="params">(struct sock *sk)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcp_sock</span> *<span class="title">tp</span> = <span class="title">tcp_sk</span>(<span class="title">sk</span>);</span></div><div class="line">	<span class="keyword">int</span> sndmem, per_mss;</div><div class="line">	u32 nr_segs;</div><div class="line"></div><div class="line">	<span class="comment">/* Worst case is non GSO/TSO : each frame consumes one skb</span></div><div class="line">	 * and skb-&gt;head is kmalloced using power of two area of memory</div><div class="line">	 */</div><div class="line">	per_mss = <span class="keyword">max_t</span>(u32, tp-&gt;rx_opt.mss_clamp, tp-&gt;mss_cache) +</div><div class="line">		  MAX_TCP_HEADER +</div><div class="line">		  SKB_DATA_ALIGN(<span class="keyword">sizeof</span>(struct skb_shared_info));</div><div class="line"></div><div class="line">	per_mss = roundup_pow_of_two(per_mss) +</div><div class="line">		  SKB_DATA_ALIGN(<span class="keyword">sizeof</span>(struct sk_buff));</div><div class="line"></div><div class="line">	nr_segs = <span class="keyword">max_t</span>(u32, TCP_INIT_CWND, tp-&gt;snd_cwnd);</div><div class="line">	nr_segs = <span class="keyword">max_t</span>(u32, nr_segs, tp-&gt;reordering + <span class="number">1</span>);</div><div class="line"></div><div class="line">	<span class="comment">/* Fast Recovery (RFC 5681 3.2) :</span></div><div class="line">	 * Cubic needs 1.7 factor, rounded to 2 to include</div><div class="line">	 * extra cushion (application might react slowly to POLLOUT)</div><div class="line">	 */</div><div class="line">	sndmem = <span class="number">2</span> * nr_segs * per_mss;</div><div class="line"></div><div class="line">	<span class="keyword">if</span> (sk-&gt;sk_sndbuf &lt; sndmem)</div><div class="line">		sk-&gt;sk_sndbuf = min(sndmem, sysctl_tcp_wmem[<span class="number">2</span>]);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="设置发送缓冲区大小为较小值"><a href="#设置发送缓冲区大小为较小值" class="headerlink" title="设置发送缓冲区大小为较小值"></a>设置发送缓冲区大小为较小值</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">socklen_t</span> sendbuflen = <span class="number">0</span>;</div><div class="line"><span class="keyword">socklen_t</span> len = <span class="keyword">sizeof</span>(sendbuflen);</div><div class="line">getsockopt(fd, SOL_SOCKET, SO_SNDBUF, (<span class="keyword">void</span>*)&amp;sendbuflen, &amp;len);</div><div class="line"><span class="built_in">printf</span>(<span class="string">"default,sendbuf:%d\n"</span>, sendbuflen);</div><div class="line"></div><div class="line"><span class="keyword">socklen_t</span> sendbuflen = <span class="number">100</span>;</div><div class="line">setsockopt(fd, SOL_SOCKET, SO_SNDBUF, (<span class="keyword">void</span>*)&amp;sendbuflen, len);</div><div class="line">getsockopt(fd, SOL_SOCKET, SO_SNDBUF, (<span class="keyword">void</span>*)&amp;sendbuflen, &amp;len);</div><div class="line"><span class="built_in">printf</span>(<span class="string">"now,sendbuf:%d\n"</span>, sendbuflen);</div></pre></td></tr></table></figure>
<p>输出信息如下：<br>default,sendbuf:16384<br>now,sendbuf:4608</p>
<p>输出信息总结：设置sendbubf为100时，没有生效，反而设置出来一个较大的值4608</p>
<h3 id="原因探究-1"><a href="#原因探究-1" class="headerlink" title="原因探究"></a>原因探究</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"> *	This is meant for all protocols to use and covers goings on</div><div class="line"> *	at the socket level. Everything here is generic.</div><div class="line"> */</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">sock_setsockopt</span><span class="params">(struct socket *sock, <span class="keyword">int</span> level, <span class="keyword">int</span> optname,</span></span></div><div class="line">		    <span class="keyword">char</span> __user *optval, <span class="keyword">unsigned</span> <span class="keyword">int</span> optlen)</div><div class="line">&#123;</div><div class="line">	···</div><div class="line">	<span class="keyword">case</span> SO_SNDBUF:</div><div class="line">		<span class="comment">/* Don't error on this BSD doesn't and if you think</span></div><div class="line">		 * about it this is right. Otherwise apps have to</div><div class="line">		 * play 'guess the biggest size' games. RCVBUF/SNDBUF</div><div class="line">		 * are treated in BSD as hints</div><div class="line">		 */</div><div class="line">		val = <span class="keyword">min_t</span>(u32, val, sysctl_wmem_max);</div><div class="line">set_sndbuf:</div><div class="line">		sk-&gt;sk_userlocks |= SOCK_SNDBUF_LOCK;</div><div class="line">		sk-&gt;sk_sndbuf = <span class="keyword">max_t</span>(<span class="keyword">int</span>, val * <span class="number">2</span>, SOCK_MIN_SNDBUF);</div><div class="line">		<span class="comment">/* Wake up sending tasks if we upped the value. */</span></div><div class="line">		sk-&gt;sk_write_space(sk);</div><div class="line">		<span class="keyword">break</span>;</div><div class="line">		···</div><div class="line">	<span class="keyword">default</span>:</div><div class="line">		ret = -ENOPROTOOPT;</div><div class="line">		<span class="keyword">break</span>;</div><div class="line">	&#125;</div><div class="line">	release_sock(sk);</div><div class="line">	<span class="keyword">return</span> ret;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> TCP_SKB_MIN_TRUESIZE	(2048 + SKB_DATA_ALIGN(sizeof(struct sk_buff)))</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> SOCK_MIN_SNDBUF		(TCP_SKB_MIN_TRUESIZE * 2)</span></div></pre></td></tr></table></figure>
<p>设置socket选项SO_SNDBUF会触发系统调用最终调用sock_setsockopt函数，其处理设置选项过程如上：<br>其会将用户设置的缓冲区大小乘以2，然后和SOCK_MIN_SNDBUF（4608）比较，取较大值<br>因此最终较小的缓冲区设置值200没有生效，生效的是4608</p>
<h2 id="设置发送缓冲区大小为中间值"><a href="#设置发送缓冲区大小为中间值" class="headerlink" title="设置发送缓冲区大小为中间值"></a>设置发送缓冲区大小为中间值</h2><p>缓冲区系统设置值大小：<br>net.core.wmem_max = 212992<br>net.ipv4.tcp_wmem = 4096    16384 4194304</p>
<p>实验动作将缓冲区大小设置为3000<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">socklen_t</span> sendbuflen = <span class="number">0</span>;</div><div class="line"><span class="keyword">socklen_t</span> len = <span class="keyword">sizeof</span>(sendbuflen);</div><div class="line">getsockopt(fd, SOL_SOCKET, SO_SNDBUF, (<span class="keyword">void</span>*)&amp;sendbuflen, &amp;len);</div><div class="line"><span class="built_in">printf</span>(<span class="string">"default,sendbuf:%d\n"</span>, sendbuflen);</div><div class="line"></div><div class="line"><span class="keyword">socklen_t</span> sendbuflen = <span class="number">3000</span>;</div><div class="line">setsockopt(fd, SOL_SOCKET, SO_SNDBUF, (<span class="keyword">void</span>*)&amp;sendbuflen, len);</div><div class="line">getsockopt(fd, SOL_SOCKET, SO_SNDBUF, (<span class="keyword">void</span>*)&amp;sendbuflen, &amp;len);</div><div class="line"><span class="built_in">printf</span>(<span class="string">"now,sendbuf:%d\n"</span>, sendbuflen);</div></pre></td></tr></table></figure></p>
<p>实验程序输出：<br>default,sendbuf:16384<br>now,sendbuf:6000<br>输出信息总结：设置大小3000生效，sndbuf大小会被设置成为3000*2</p>
<h2 id="设置发送缓冲区大小威较大值"><a href="#设置发送缓冲区大小威较大值" class="headerlink" title="设置发送缓冲区大小威较大值"></a>设置发送缓冲区大小威较大值</h2><p>缓冲区系统设置值大小：<br>net.core.wmem_max = 212992<br>net.ipv4.tcp_wmem = 4096    16384 4194304</p>
<p>实验动作将缓冲区大小设置为230000<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">socklen_t</span> sendbuflen = <span class="number">0</span>;</div><div class="line"><span class="keyword">socklen_t</span> len = <span class="keyword">sizeof</span>(sendbuflen);</div><div class="line">getsockopt(fd, SOL_SOCKET, SO_SNDBUF, (<span class="keyword">void</span>*)&amp;sendbuflen, &amp;len);</div><div class="line"><span class="built_in">printf</span>(<span class="string">"default,sendbuf:%d\n"</span>, sendbuflen);</div><div class="line"></div><div class="line"><span class="keyword">socklen_t</span> sendbuflen = <span class="number">230000</span>;</div><div class="line">setsockopt(fd, SOL_SOCKET, SO_SNDBUF, (<span class="keyword">void</span>*)&amp;sendbuflen, len);</div><div class="line">getsockopt(fd, SOL_SOCKET, SO_SNDBUF, (<span class="keyword">void</span>*)&amp;sendbuflen, &amp;len);</div><div class="line"><span class="built_in">printf</span>(<span class="string">"now,sendbuf:%d\n"</span>, sendbuflen);</div></pre></td></tr></table></figure></p>
<p>实现程序输出：<br>default,sendbuf:16384<br>now,sendbuf:425984<br>实验结果分析：设置大小23000（大于系统212992），sendbuf最终结果为212992*2 </p>
<h3 id="原因探究-2"><a href="#原因探究-2" class="headerlink" title="原因探究"></a>原因探究</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">case</span> SO_SNDBUF:</div><div class="line">		val = <span class="keyword">min_t</span>(u32, val, sysctl_wmem_max);</div><div class="line">set_sndbuf:</div><div class="line">		sk-&gt;sk_userlocks |= SOCK_SNDBUF_LOCK;</div><div class="line">		sk-&gt;sk_sndbuf = <span class="keyword">max_t</span>(<span class="keyword">int</span>, val * <span class="number">2</span>, SOCK_MIN_SNDBUF);</div><div class="line">		<span class="comment">/* Wake up sending tasks if we upped the value. */</span></div><div class="line">		sk-&gt;sk_write_space(sk);</div><div class="line">		<span class="keyword">break</span>;</div></pre></td></tr></table></figure>
<p>val为用户set的值，其在选择时候会同sysctl_wmem_max比较，选取一个较小的值，如果设置值大于sysctl_wmem_max值的话，val就取系统wmem的最大值。</p>
<p>如上可知：230000 &gt; net.core.wmem_max ,所以用户设置SO_SNDBUF选项最大只能取net.core.wmem_max，所以最终sk_sndbubf值为net.core.wmem_max*2 即425984</p>
<h2 id="其它说明"><a href="#其它说明" class="headerlink" title="其它说明"></a>其它说明</h2><p>tcp socket记录当前发送队列的占用缓冲区大小的变量为sk_wmem_queued<br>和发送缓冲区判断函数如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">sk_stream_memory_free</span><span class="params">(<span class="keyword">const</span> struct sock *sk)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">if</span> (sk-&gt;sk_wmem_queued &gt;= sk-&gt;sk_sndbuf)</div><div class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line"></div><div class="line">	<span class="keyword">return</span> sk-&gt;sk_prot-&gt;stream_memory_free ?</div><div class="line">		sk-&gt;sk_prot-&gt;stream_memory_free(sk) : <span class="literal">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>从上述判别中我们可以知道，发送缓冲区记录和比对单位均是字节</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;tcp-socket发送缓冲区探究结论&quot;&gt;&lt;a href=&quot;#tcp-socket发送缓冲区探究结论&quot; class=&quot;headerlink&quot; title=&quot;tcp socket发送缓冲区探究结论&quot;&gt;&lt;/a&gt;tcp socket发送缓冲区探究结论&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;1: 未设置SO_SNDBUF时，sk-&amp;gt;sk_sndbuf值由tcp_finish_connect-&amp;gt;tcp_init_buffer_space-&amp;gt;tcp_sndbuf_expand决定，TCP协议栈会自己计算一个值出来46080，sk_sndbuf是46080和net.ipv4.tcp_wmem[2]（4194304）的较小值&lt;/p&gt;
&lt;p&gt;2: 设置SO_SNDBUF后，tcp_sndbuf_expand将不会再被调用，其值情况完全由sock_setsockopt决定&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;2-1: 设置值较小 value &amp;lt;  2304 { SOCK_MIN_SNDBUF（4608）/2 }&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;sk_sndbuf = 4608&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;2-2: 设置值适中 { SOCK_MIN_SNDBUF（4608）/2 }  &amp;lt;  value  &amp;lt;  net.core.wmem_max&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;sk_sndbuf = value*2&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;2-3: 设置值较大 value &amp;gt; net.core.wmem_max&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;sk_sndbuf = net.core.wmem_max* 2&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="socket" scheme="https://vcpu.github.io/categories/socket/"/>
    
    
      <category term="tcp/ip" scheme="https://vcpu.github.io/tags/tcp-ip/"/>
    
      <category term="kernel3.10.0-514.16.1" scheme="https://vcpu.github.io/tags/kernel3-10-0-514-16-1/"/>
    
      <category term="socket" scheme="https://vcpu.github.io/tags/socket/"/>
    
  </entry>
  
  <entry>
    <title>PF_INET和AF_INET区别</title>
    <link href="https://vcpu.github.io/pf_inet/"/>
    <id>https://vcpu.github.io/pf_inet/</id>
    <published>2017-06-20T10:12:51.000Z</published>
    <updated>2017-06-20T10:12:51.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="PF-INET和AF-INET区别"><a href="#PF-INET和AF-INET区别" class="headerlink" title="PF_INET和AF_INET区别"></a>PF_INET和AF_INET区别</h1><ul>
<li>在初始化socket时候socket(PF_INET,SOCK_SRTEAM,0) 用PF_INET，表示ip协议</li>
<li>指定地址协议族时候用AF_INET，表示地址为IP协议</li>
<li>Linux AF_INET和PF_INET值相同均为2</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">socket.h</div><div class="line"></div><div class="line">#define AF_INET		2	/* Internet IP Protocol *</div><div class="line"></div><div class="line">...</div><div class="line">#define PF_INET		AF_INET</div></pre></td></tr></table></figure>
<h1 id="socket通信协议类型"><a href="#socket通信协议类型" class="headerlink" title="socket通信协议类型"></a>socket通信协议类型</h1><ul>
<li>SOCKET_STREAM: 面向连接TCP</li>
<li>SOCK_DGRAM: 无保障UDP</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;PF-INET和AF-INET区别&quot;&gt;&lt;a href=&quot;#PF-INET和AF-INET区别&quot; class=&quot;headerlink&quot; title=&quot;PF_INET和AF_INET区别&quot;&gt;&lt;/a&gt;PF_INET和AF_INET区别&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;在初始化
    
    </summary>
    
      <category term="socket" scheme="https://vcpu.github.io/categories/socket/"/>
    
    
      <category term="PF_INET" scheme="https://vcpu.github.io/tags/PF-INET/"/>
    
      <category term="AF_INET" scheme="https://vcpu.github.io/tags/AF-INET/"/>
    
  </entry>
  
  <entry>
    <title>sockaddr_in和sockaddr的区别</title>
    <link href="https://vcpu.github.io/sockaddr_in/"/>
    <id>https://vcpu.github.io/sockaddr_in/</id>
    <published>2017-06-20T07:18:11.000Z</published>
    <updated>2017-06-20T07:18:11.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="sockaddr-in在头文件-usr-include-netinet-in-h"><a href="#sockaddr-in在头文件-usr-include-netinet-in-h" class="headerlink" title="sockaddr_in在头文件/usr/include/netinet/in.h"></a>sockaddr_in在头文件/usr/include/netinet/in.h</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">/* Structure describing an Internet socket address.  */</div><div class="line">struct sockaddr_in</div><div class="line">  &#123;</div><div class="line">    __SOCKADDR_COMMON (sin_);</div><div class="line">    in_port_t sin_port;			/* Port number.  */</div><div class="line">    struct in_addr sin_addr;		/* Internet address.  */</div><div class="line"></div><div class="line">    /* Pad to size of `struct sockaddr&apos;.  */</div><div class="line">    unsigned char sin_zero[sizeof (struct sockaddr) -</div><div class="line">			   __SOCKADDR_COMMON_SIZE -</div><div class="line">			   sizeof (in_port_t) -</div><div class="line">			   sizeof (struct in_addr)];</div><div class="line">  &#125;;</div><div class="line">  or</div><div class="line">  struct  sockaddr_in &#123;</div><div class="line">	short  int  sin_family;                 /* Address family */</div><div class="line">	unsigned  short  int  sin_port;         /* Port number */</div><div class="line">	struct  in_addr  sin_addr;              /* Internet address */</div><div class="line">	unsigned  char  sin_zero[8];            /* Same size as struct sockaddr */</div><div class="line">&#125;;</div><div class="line">  </div><div class="line">   </div><div class="line"> struct   in_addr   &#123;</div><div class="line"> 		union &#123;</div><div class="line">          	struct &#123; u_char s_b1,s_b2,s_b3,s_b4; &#125; S_un_b;</div><div class="line">          	struct &#123; u_short s_w1,s_w2; &#125; S_un_w;</div><div class="line">          	u_long S_addr; </div><div class="line">          	&#125; S_un;</div><div class="line">          	 #define s_addr  S_un.S_addr</div><div class="line"> &#125;;</div></pre></td></tr></table></figure>
<ul>
<li>组成包含协议家族、端口、地址、填充</li>
<li>端口和地址，需要是网络字节序号</li>
<li>inet_addr(“127.0.0.1”)把字符串点分十进制地址按照网络字节序转换为4字节的地址</li>
</ul>
<a id="more"></a>
<h2 id="sockaddr为通用的socket地址"><a href="#sockaddr为通用的socket地址" class="headerlink" title="sockaddr为通用的socket地址"></a>sockaddr为通用的socket地址</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">struct sockaddr &#123;    </div><div class="line">      unsigned short sa_family;  // address family, AF_INET    </div><div class="line">      char sa_data[14];          // 14 bytes of protocol address    </div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<ul>
<li>bind、connect、recv、send等socket参数使用的就是这个结构体</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;sockaddr-in在头文件-usr-include-netinet-in-h&quot;&gt;&lt;a href=&quot;#sockaddr-in在头文件-usr-include-netinet-in-h&quot; class=&quot;headerlink&quot; title=&quot;sockaddr_in在头文件/usr/include/netinet/in.h&quot;&gt;&lt;/a&gt;sockaddr_in在头文件/usr/include/netinet/in.h&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;19&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;20&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;21&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;22&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;23&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;24&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;25&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;26&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;27&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;28&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;29&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;30&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;/* Structure describing an Internet socket address.  */&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;struct sockaddr_in&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    __SOCKADDR_COMMON (sin_);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    in_port_t sin_port;			/* Port number.  */&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    struct in_addr sin_addr;		/* Internet address.  */&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    /* Pad to size of `struct sockaddr&amp;apos;.  */&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    unsigned char sin_zero[sizeof (struct sockaddr) -&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;			   __SOCKADDR_COMMON_SIZE -&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;			   sizeof (in_port_t) -&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;			   sizeof (struct in_addr)];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &amp;#125;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  or&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  struct  sockaddr_in &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	short  int  sin_family;                 /* Address family */&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	unsigned  short  int  sin_port;         /* Port number */&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	struct  in_addr  sin_addr;              /* Internet address */&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	unsigned  char  sin_zero[8];            /* Same size as struct sockaddr */&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   &lt;/div&gt;&lt;div class=&quot;line&quot;&gt; struct   in_addr   &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; 		union &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;          	struct &amp;#123; u_char s_b1,s_b2,s_b3,s_b4; &amp;#125; S_un_b;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;          	struct &amp;#123; u_short s_w1,s_w2; &amp;#125; S_un_w;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;          	u_long S_addr; &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;          	&amp;#125; S_un;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;          	 #define s_addr  S_un.S_addr&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; &amp;#125;;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;组成包含协议家族、端口、地址、填充&lt;/li&gt;
&lt;li&gt;端口和地址，需要是网络字节序号&lt;/li&gt;
&lt;li&gt;inet_addr(“127.0.0.1”)把字符串点分十进制地址按照网络字节序转换为4字节的地址&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="socket" scheme="https://vcpu.github.io/categories/socket/"/>
    
    
      <category term="tcp/ip" scheme="https://vcpu.github.io/tags/tcp-ip/"/>
    
      <category term="sockaddr_in" scheme="https://vcpu.github.io/tags/sockaddr-in/"/>
    
      <category term="sockaddr" scheme="https://vcpu.github.io/tags/sockaddr/"/>
    
  </entry>
  
  <entry>
    <title>systemtap使用调试记录（二）</title>
    <link href="https://vcpu.github.io/socket_stp/"/>
    <id>https://vcpu.github.io/socket_stp/</id>
    <published>2017-06-20T06:52:23.000Z</published>
    <updated>2017-06-20T06:52:23.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="socket-sendbubf探究stp脚本"><a href="#socket-sendbubf探究stp脚本" class="headerlink" title="socket sendbubf探究stp脚本"></a>socket sendbubf探究stp脚本</h2><ul>
<li>centos7 3.10.0-514.16.1.el7.x86_64</li>
</ul>
<p>该systap脚本是在调用协议栈sk-&gt;sk_sndbuf可能改变的位置增加探测点，探究snd_buf变更规律使用</p>
<a id="more"></a>
<h2 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h2><p>socket.stp<br><figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div></pre></td><td class="code"><pre><div class="line">%&#123;</div><div class="line">  <span class="comment">#include &lt;linux/tcp.h&gt;</span></div><div class="line">  <span class="comment">#include&lt;linux/rtc.h&gt;</span></div><div class="line">  <span class="comment">#include &lt;net/tcp.h&gt;</span></div><div class="line"></div><div class="line">    static const char tcp_state_array[][<span class="number">16</span>] = &#123;</div><div class="line">        <span class="string">"NULL"</span>,</div><div class="line">        <span class="string">"ESTABLISHED"</span>,</div><div class="line">        <span class="string">"SYN_SENT"</span>,</div><div class="line">        <span class="string">"SYN_RECV"</span>,</div><div class="line">        <span class="string">"FIN_WAIT1"</span>,</div><div class="line">        <span class="string">"FIN_WAIT2"</span>,</div><div class="line">        <span class="string">"TIME_WAIT"</span>,</div><div class="line">        <span class="string">"CLOSE"</span>,</div><div class="line">        <span class="string">"CLOSE_WAIT"</span>,</div><div class="line">        <span class="string">"LAST_ACK"</span>,</div><div class="line">        <span class="string">"LISTEN"</span>,</div><div class="line">        <span class="string">"CLOSING"</span></div><div class="line">    &#125;;</div><div class="line">%&#125;</div><div class="line"></div><div class="line">function get_short_time:string()</div><div class="line">%&#123;</div><div class="line">    struct timeval tv;</div><div class="line">    struct rtc_time tm;</div><div class="line">    unsigned long <span class="keyword">time</span>;</div><div class="line"></div><div class="line">    do_gettimeofday(&amp;tv);</div><div class="line">    <span class="keyword">time</span> = tv.tv_sec + <span class="number">8</span> * <span class="number">3600</span>;</div><div class="line">    rtc_time_to_tm(<span class="keyword">time</span>, &amp;tm);</div><div class="line"></div><div class="line">    <span class="keyword">sprintf</span>(STAP_RETVALUE, <span class="string">"%02d:%02d:%02d"</span>,</div><div class="line">        tm.tm_hour, tm.tm_min, tm.tm_sec);</div><div class="line">%&#125;</div><div class="line"></div><div class="line">function get_full_time:string()</div><div class="line">%&#123;</div><div class="line">    struct timeval tv;</div><div class="line">    struct rtc_time tm;</div><div class="line">    unsigned long <span class="keyword">time</span>;</div><div class="line"></div><div class="line">    do_gettimeofday(&amp;tv);</div><div class="line">    <span class="keyword">time</span> = tv.tv_sec + <span class="number">8</span> * <span class="number">3600</span>;</div><div class="line">    rtc_time_to_tm(<span class="keyword">time</span>, &amp;tm);</div><div class="line"></div><div class="line">    <span class="keyword">sprintf</span>(STAP_RETVALUE, <span class="string">"%d/%d/%d,%02d:%02d:%02d"</span>,</div><div class="line">        tm.tm_year+<span class="number">1900</span>, tm.tm_mon+<span class="number">1</span>, tm.tm_mday,</div><div class="line">        tm.tm_hour, tm.tm_min, tm.tm_sec);</div><div class="line">%&#125;</div><div class="line"></div><div class="line">function get_conn_lifetime:long (sk:long)</div><div class="line">%&#123;</div><div class="line">    struct sock *sk = (struct sock *)STAP_ARG_sk;</div><div class="line">    struct stap_info *info = sk-&gt;sk_protinfo;</div><div class="line">    STAP_RETVALUE = jiffies_to_msecs(tcp_time_stamp - info-&gt;estab_t);</div><div class="line">%&#125;</div><div class="line"></div><div class="line">function get_conn_data:long (sk:long)</div><div class="line">%&#123;</div><div class="line">    struct sock *sk = (struct sock *)STAP_ARG_sk;</div><div class="line">    struct tcp_sock *tp = tcp_sk(sk);</div><div class="line">    struct stap_info *info = sk-&gt;sk_protinfo;</div><div class="line">    u32 len = tp-&gt;snd_nxt - info-&gt;isn;</div><div class="line"></div><div class="line">    STAP_RETVALUE = len ? len - <span class="number">1</span> : len;</div><div class="line">%&#125;</div><div class="line"></div><div class="line">function filter_http_transtime:long (sk:long)</div><div class="line">%&#123;</div><div class="line">    struct sock *sk = (struct sock *)STAP_ARG_sk;</div><div class="line">    struct stap_info *info = sk-&gt;sk_protinfo;</div><div class="line"></div><div class="line">    STAP_RETVALUE = info-&gt;http_filter;</div><div class="line">%&#125;</div><div class="line"></div><div class="line">function get_socket_addr:string (sk:long)</div><div class="line">&#123;</div><div class="line">    laddr = tcpmib_local_addr(sk)</div><div class="line">    lport = tcpmib_local_port(sk)</div><div class="line">    raddr = tcpmib_remote_addr(sk)</div><div class="line">    rport = tcpmib_remote_port(sk)</div><div class="line"></div><div class="line">    local_addr = <span class="keyword">sprintf</span>(<span class="string">"%s:%d"</span>, ip_ntop(htonl(laddr)), lport)</div><div class="line">    remote_addr = <span class="keyword">sprintf</span>(<span class="string">"%s:%d"</span>, ip_ntop(htonl(raddr)), rport)</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="keyword">sprintf</span>(<span class="string">"local=%s,remote=%s"</span>, local_addr, remote_addr)</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">function get_socket_state:string (sk:long)</div><div class="line">%&#123;</div><div class="line">    struct sock *sk = (struct sock *)STAP_ARG_sk;</div><div class="line">    <span class="keyword">sprintf</span>(STAP_RETVALUE, <span class="string">"%s"</span>, tcp_state_array[sk-&gt;sk_state]);</div><div class="line">%&#125;</div><div class="line"></div><div class="line">function get_socket_sk_sndbuf:string(sk:long)</div><div class="line">%&#123;</div><div class="line">    struct sock *sk=(struct sock*)STAP_ARG_sk;</div><div class="line">    <span class="keyword">sprintf</span>(STAP_RETVALUE,<span class="string">"%d:%d"</span>, sk-&gt;sk_wmem_queued, sk-&gt;sk_sndbuf);</div><div class="line">%&#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">function socket_state_num2str:string (<span class="keyword">state</span>:long)</div><div class="line">%&#123;</div><div class="line">    <span class="keyword">sprintf</span>(STAP_RETVALUE, <span class="string">"%s"</span>, tcp_state_array[STAP_ARG_state]);</div><div class="line">%&#125;</div><div class="line"></div><div class="line">function sshfilter:long(sk:long)</div><div class="line">&#123;</div><div class="line">    lport = tcpmib_local_port(sk)</div><div class="line">    <span class="keyword">if</span>(lport == <span class="number">22</span>)</div><div class="line">        <span class="keyword">return</span> <span class="number">1</span></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">probe kernel.function(<span class="string">"tcp_send_ack"</span>).call&#123;</div><div class="line">    <span class="keyword">if</span>(sshfilter($sk))</div><div class="line">        <span class="keyword">next</span></div><div class="line">    <span class="keyword">printf</span>(<span class="string">"tcp_send_ack[%s]%s state:%s\n"</span>,get_full_time(),get_socket_addr($sk),get_socket_state($sk));</div><div class="line">&#125;</div><div class="line"></div><div class="line">probe kernel.function(<span class="string">"tcp_sendmsg"</span>).call&#123;</div><div class="line">    <span class="keyword">if</span>(sshfilter($sk))</div><div class="line">        <span class="keyword">next</span></div><div class="line">    <span class="keyword">printf</span>(<span class="string">"tcp_sendmsg[%s]%s state:%s,sndbubf %s\n"</span>,get_full_time(),get_socket_addr($sk),get_socket_state($sk),get_socket_sk_sndbuf($sk));</div><div class="line">&#125;</div><div class="line"></div><div class="line">probe kernel.function(<span class="string">"tcp_sendmsg"</span>).<span class="keyword">return</span>&#123;</div><div class="line">    <span class="keyword">if</span>(sshfilter($sk))</div><div class="line">        <span class="keyword">next</span></div><div class="line">    <span class="keyword">printf</span>(<span class="string">"tcp_sendmsg return [%s]%s state:%s,sndbubf %s\n"</span>,get_full_time(),get_socket_addr($sk),get_socket_state($sk),get_socket_sk_sndbuf($sk));</div><div class="line">&#125;</div><div class="line"></div><div class="line">probe kernel.statement(<span class="string">"*@net/core/sock.c:711"</span>)&#123;</div><div class="line"></div><div class="line">    <span class="keyword">if</span>(sshfilter($sk))</div><div class="line">        <span class="keyword">next</span></div><div class="line">    <span class="keyword">printf</span>(<span class="string">"sock:711 return [%s]%s state:%s,sndbubf %s\n"</span>,get_full_time(),get_socket_addr($sk),get_socket_state($sk),get_socket_sk_sndbuf($sk));</div><div class="line">&#125;</div><div class="line"></div><div class="line">probe kernel.statement(<span class="string">"*@net/core/sock.c:715"</span>)&#123;</div><div class="line">    <span class="keyword">if</span>(sshfilter($sk))</div><div class="line">        <span class="keyword">next</span></div><div class="line">    <span class="keyword">printf</span>(<span class="string">"sock:715 return [%s]%s state:%s,sndbubf %s\n"</span>,get_full_time(),get_socket_addr($sk),get_socket_state($sk),get_socket_sk_sndbuf($sk));</div><div class="line">&#125;</div><div class="line"></div><div class="line">probe kernel.statement(<span class="string">"*@net/ipv4/ip_output.c:1581"</span>)&#123;</div><div class="line">    <span class="keyword">if</span>(sshfilter($sk))</div><div class="line">        <span class="keyword">next</span></div><div class="line">    <span class="keyword">printf</span>(<span class="string">"ip_output:1581 return [%s]%s state:%s,sndbubf %s\n"</span>,get_full_time(),get_socket_addr($sk),get_socket_state($sk),get_socket_sk_sndbuf($sk));</div><div class="line">&#125;</div><div class="line"></div><div class="line">probe kernel.statement(<span class="string">"*@net/ipv4/ip_output.c:1583"</span>)&#123;</div><div class="line">    <span class="keyword">if</span>(sshfilter($sk))</div><div class="line">        <span class="keyword">next</span></div><div class="line">    <span class="keyword">printf</span>(<span class="string">"ip_output:1583 return [%s]%s state:%s,sndbubf %s\n"</span>,get_full_time(),get_socket_addr($sk),get_socket_state($sk),get_socket_sk_sndbuf($sk));</div><div class="line">&#125;</div><div class="line"></div><div class="line">probe kernel.statement(<span class="string">"*@net/ipv4/tcp_input.c:304"</span>)&#123;</div><div class="line">    <span class="keyword">if</span>(sshfilter($sk))</div><div class="line">        <span class="keyword">next</span></div><div class="line">    <span class="keyword">printf</span>(<span class="string">"tcp_input:304 return [%s]%s state:%s,sndbubf %s sndmem : %d permss %d\n"</span>,get_full_time(),get_socket_addr($sk),get_socket_state($sk),get_socket_sk_sndbuf($sk),$sndmem,$per_mss);</div><div class="line">    print_backtrace()</div><div class="line">&#125;</div><div class="line"></div><div class="line">probe kernel.function(<span class="string">"__sk_mem_schedule"</span>).call&#123;</div><div class="line">    <span class="keyword">if</span>(sshfilter($sk))</div><div class="line">        <span class="keyword">next</span></div><div class="line">    <span class="keyword">printf</span>(<span class="string">"__sk_mem_schedule[%s]%s state:%s,sndbubf %s\n"</span>,get_full_time(),get_socket_addr($sk),get_socket_state($sk),get_socket_sk_sndbuf($sk));</div><div class="line">&#125;</div><div class="line"></div><div class="line">probe kernel.function(<span class="string">"__sk_mem_schedule"</span>).<span class="keyword">return</span>&#123;</div><div class="line">    <span class="keyword">if</span>(sshfilter($sk))</div><div class="line">        <span class="keyword">next</span></div><div class="line">    <span class="keyword">printf</span>(<span class="string">"__sk_mem_schedule return [%s]%s state:%s,sndbubf %s\n"</span>,get_full_time(),get_socket_addr($sk),get_socket_state($sk),get_socket_sk_sndbuf($sk));</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">probe kernel.function(<span class="string">"sk_page_frag_refill"</span>).call&#123;</div><div class="line">    <span class="keyword">if</span>(sshfilter($sk))</div><div class="line">        <span class="keyword">next</span></div><div class="line">    <span class="keyword">printf</span>(<span class="string">"sk_page_frag_refill[%s]%s state:%s,sndbubf %s\n"</span>,get_full_time(),get_socket_addr($sk),get_socket_state($sk),get_socket_sk_sndbuf($sk));</div><div class="line">&#125;</div><div class="line"></div><div class="line">probe kernel.function(<span class="string">"sk_page_frag_refill"</span>).<span class="keyword">return</span>&#123;</div><div class="line">    <span class="keyword">if</span>(sshfilter($sk))</div><div class="line">        <span class="keyword">next</span></div><div class="line">    <span class="keyword">printf</span>(<span class="string">"sk_page_frag_refill return [%s]%s state:%s,sndbubf %s\n"</span>,get_full_time(),get_socket_addr($sk),get_socket_state($sk),get_socket_sk_sndbuf($sk));</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">probe kernel.function(<span class="string">"sk_stream_alloc_skb"</span>).call&#123;</div><div class="line">    <span class="keyword">if</span>(sshfilter($sk))</div><div class="line">        <span class="keyword">next</span></div><div class="line">    <span class="keyword">printf</span>(<span class="string">"sk_stream_alloc_skb[%s]%s state:%s,sndbubf %s\n"</span>,get_full_time(),get_socket_addr($sk),get_socket_state($sk),get_socket_sk_sndbuf($sk));</div><div class="line">&#125;</div><div class="line"></div><div class="line">probe kernel.function(<span class="string">"sk_stream_alloc_skb"</span>).<span class="keyword">return</span>&#123;</div><div class="line">    <span class="keyword">if</span>(sshfilter($sk))</div><div class="line">        <span class="keyword">next</span></div><div class="line">    <span class="keyword">printf</span>(<span class="string">"sk_stream_alloc_skb return [%s]%s state:%s,sndbubf %s\n"</span>,get_full_time(),get_socket_addr($sk),get_socket_state($sk),get_socket_sk_sndbuf($sk));</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">probe kernel.function(<span class="string">"tcp_v4_connect"</span>).call&#123;</div><div class="line">    <span class="keyword">if</span>(sshfilter($sk))</div><div class="line">        <span class="keyword">next</span></div><div class="line">    <span class="keyword">printf</span>(<span class="string">"tcp_v4_connect[%s]%s state:%s,sndbubf %s\n"</span>,get_full_time(),get_socket_addr($sk),get_socket_state($sk),get_socket_sk_sndbuf($sk));</div><div class="line">&#125;</div><div class="line"></div><div class="line">probe kernel.function(<span class="string">"tcp_v4_connect"</span>).<span class="keyword">return</span>&#123;</div><div class="line">    <span class="keyword">if</span>(sshfilter($sk))</div><div class="line">        <span class="keyword">next</span></div><div class="line">    <span class="keyword">printf</span>(<span class="string">"tcp_v4_connect return [%s]%s state:%s,sndbubf %s\n"</span>,get_full_time(),get_socket_addr($sk),get_socket_state($sk),get_socket_sk_sndbuf($sk));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="执行步骤"><a href="#执行步骤" class="headerlink" title="执行步骤"></a>执行步骤</h2><p>stap -g socket.stp</p>
<h2 id="执行结果"><a href="#执行结果" class="headerlink" title="执行结果"></a>执行结果</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">[root@localhost stp]# stap -g socket.stp</div><div class="line">WARNING: Eliding unused function 'filter_http_transtime': identifier 'filter_http_transtime' at socket.stp:68:10</div><div class="line"> source: function filter_http_transtime:long (sk:long)</div><div class="line">                  ^</div><div class="line">WARNING: Eliding unused function 'get_conn_data': identifier 'get_conn_data' at :58:10</div><div class="line"> source: function get_conn_data:long (sk:long)</div><div class="line">                  ^</div><div class="line">WARNING: Eliding unused function 'get_conn_lifetime': identifier 'get_conn_lifetime' at :51:10</div><div class="line"> source: function get_conn_lifetime:long (sk:long)</div><div class="line">                  ^</div><div class="line">WARNING: Eliding unused function 'get_short_time': identifier 'get_short_time' at :22:10</div><div class="line"> source: function get_short_time:string()</div><div class="line">                  ^</div><div class="line">WARNING: Eliding unused function 'socket_state_num2str': identifier 'socket_state_num2str' at :104:10</div><div class="line"> source: function socket_state_num2str:string (state:long)</div><div class="line">                  ^</div><div class="line">sock:711 return [2017/6/20,14:42:35]local=0.0.0.0:0,remote=0.0.0.0:0 state:CLOSE,sndbubf 0:16384</div><div class="line">sock:715 return [2017/6/20,14:42:35]local=0.0.0.0:0,remote=0.0.0.0:0 state:CLOSE,sndbubf 0:32768</div><div class="line">tcp_v4_connect[2017/6/20,14:42:35]local=0.0.0.0:3000,remote=0.0.0.0:0 state:CLOSE,sndbubf 0:32768</div><div class="line">tcp_v4_connect return [2017/6/20,14:42:35]local=192.168.55.178:3000,remote=180.97.33.108:80 state:SYN_SENT,sndbubf 1280:32768</div><div class="line">tcp_send_ack[2017/6/20,14:42:35]local=192.168.55.178:3000,remote=180.97.33.108:80 state:ESTABLISHED</div><div class="line">tcp_sendmsg[2017/6/20,14:42:35]local=192.168.55.178:3000,remote=180.97.33.108:80 state:ESTABLISHED,sndbubf 0:32768</div><div class="line">sk_stream_alloc_skb[2017/6/20,14:42:35]local=192.168.55.178:3000,remote=180.97.33.108:80 state:ESTABLISHED,sndbubf 0:32768</div><div class="line">sk_stream_alloc_skb return [2017/6/20,14:42:35]local=192.168.55.178:3000,remote=180.97.33.108:80 state:ESTABLISHED,sndbubf 0:32768</div><div class="line">tcp_sendmsg return [2017/6/20,14:42:35]local=192.168.55.178:3000,remote=180.97.33.108:80 state:ESTABLISHED,sndbubf 2304:32768</div><div class="line">tcp_send_ack[2017/6/20,14:42:35]local=192.168.55.178:3000,remote=180.97.33.108:80 state:ESTABLISHED</div><div class="line">tcp_send_ack[2017/6/20,14:42:35]local=192.168.55.178:3000,remote=180.97.33.108:80 state:ESTABLISHED</div><div class="line">ip_output:1583 return [2017/6/20,14:42:35]local=0.0.0.0:6,remote=0.0.0.0:0 state:CLOSE,sndbubf 0:212992</div><div class="line">ip_output:1581 return [2017/6/20,14:42:35]local=0.0.0.0:6,remote=0.0.0.0:0 state:CLOSE,sndbubf 0:212992</div><div class="line">ip_output:1583 return [2017/6/20,14:42:35]local=0.0.0.0:6,remote=0.0.0.0:0 state:CLOSE,sndbubf 0:212992</div><div class="line">ip_output:1581 return [2017/6/20,14:42:35]local=0.0.0.0:6,remote=0.0.0.0:0 state:CLOSE,sndbubf 0:212992</div><div class="line">ip_output:1583 return [2017/6/20,14:42:35]local=0.0.0.0:6,remote=0.0.0.0:0 state:CLOSE,sndbubf 0:212992</div><div class="line">ip_output:1581 return [2017/6/20,14:42:35]local=0.0.0.0:6,remote=0.0.0.0:0 state:CLOSE,sndbubf 0:212992</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;socket-sendbubf探究stp脚本&quot;&gt;&lt;a href=&quot;#socket-sendbubf探究stp脚本&quot; class=&quot;headerlink&quot; title=&quot;socket sendbubf探究stp脚本&quot;&gt;&lt;/a&gt;socket sendbubf探究stp脚本&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;centos7 3.10.0-514.16.1.el7.x86_64&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;该systap脚本是在调用协议栈sk-&amp;gt;sk_sndbuf可能改变的位置增加探测点，探究snd_buf变更规律使用&lt;/p&gt;
    
    </summary>
    
      <category term="linux kernel" scheme="https://vcpu.github.io/categories/linux-kernel/"/>
    
    
      <category term="kernel3.10.0-514.16.1" scheme="https://vcpu.github.io/tags/kernel3-10-0-514-16-1/"/>
    
      <category term="socket" scheme="https://vcpu.github.io/tags/socket/"/>
    
      <category term="systemtap" scheme="https://vcpu.github.io/tags/systemtap/"/>
    
  </entry>
  
  <entry>
    <title>socket send</title>
    <link href="https://vcpu.github.io/socketsend1/"/>
    <id>https://vcpu.github.io/socketsend1/</id>
    <published>2017-06-19T04:43:31.000Z</published>
    <updated>2017-06-19T04:43:31.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="用户态发送函数列表"><a href="#用户态发送函数列表" class="headerlink" title="用户态发送函数列表"></a>用户态发送函数列表</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">ssize_t</span> send(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> len, <span class="keyword">int</span> flags);</div><div class="line"></div><div class="line"><span class="keyword">ssize_t</span> sendto(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> len, <span class="keyword">int</span> flags,</div><div class="line">                            <span class="keyword">const</span> struct sockaddr *dest_addr, <span class="keyword">socklen_t</span> addrlen);</div><div class="line"></div><div class="line"><span class="keyword">ssize_t</span> sendmsg(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> struct msghdr *msg, <span class="keyword">int</span> flags);</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">sendmmsg</span><span class="params">(<span class="keyword">int</span> sockfd, struct mmsghdr *msgvec, <span class="keyword">unsigned</span> <span class="keyword">int</span> vlen,</span></span></div><div class="line">                                                            <span class="keyword">unsigned</span> <span class="keyword">int</span> flags);</div><div class="line">                                                            </div><div class="line"><span class="keyword">ssize_t</span> write(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> count);</div></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="发送函数之间差别"><a href="#发送函数之间差别" class="headerlink" title="发送函数之间差别"></a>发送函数之间差别</h2><blockquote>
<p>send 有连接协议发送数据使用，send第四个参数flags为0时候，等价于write</p>
<blockquote>
<p>send(sockfd, buf, len, 0) 等价 write（sockfd, buf, len）</p>
</blockquote>
<p>send是sendto一部分,send可被sendto替换</p>
<blockquote>
<p>send(sockfd, buf, len, flags) 等价于  sendto(sockfd, buf, len, flags, NULL, 0)</p>
</blockquote>
<p>sendto 无连接和有连接发包都可以使用</p>
<p>sendmsg 可替换上树所有的发包函数</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msghdr</span> &#123;</span></div><div class="line">     <span class="keyword">void</span>         *msg_name;       <span class="comment">/* optional address */</span></div><div class="line">     <span class="keyword">socklen_t</span>     msg_namelen;    <span class="comment">/* size of address */</span></div><div class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> *<span class="title">msg_iov</span>;</span>        <span class="comment">/* scatter/gather array */</span></div><div class="line">     <span class="keyword">size_t</span>        msg_iovlen;     <span class="comment">/* # elements in msg_iov */</span></div><div class="line">     <span class="keyword">void</span>         *msg_control;    <span class="comment">/* ancillary data, see below */</span></div><div class="line">     <span class="keyword">size_t</span>        msg_controllen; <span class="comment">/* ancillary data buffer len */</span></div><div class="line">     <span class="keyword">int</span>           msg_flags;      <span class="comment">/* flags (unused) */</span></div><div class="line"> &#125;;</div></pre></td></tr></table></figure>
</blockquote>
<p> /proc/sys/net/core/optmem_max可控制每个socket的msg_control大小<br> sendmsg不使用msg_flags参数</p>
</blockquote>
<h2 id="send发包过程概述"><a href="#send发包过程概述" class="headerlink" title="send发包过程概述"></a>send发包过程概述</h2><ul>
<li><p>阻塞模式下<br> 调用send函数时候，比较要发送数据和套接字发送缓冲区长度（net.ipv4.tcp_wmem）；如果发送缓冲区较小，函数直接返回SOCKET_ERR;</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> send_len &lt;= tcp_wmem&#123;</div><div class="line">	<span class="keyword">if</span> is sending&#123;</div><div class="line">		wait</div><div class="line">		<span class="keyword">if</span> network err</div><div class="line">			<span class="keyword">return</span> SCOKET_ERR</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">else</span>&#123;</div><div class="line">		<span class="keyword">if</span> len &gt; tcp_wmem left&#123;</div><div class="line">			wait</div><div class="line">			<span class="keyword">if</span> network err</div><div class="line">				<span class="keyword">return</span> SCOKET_ERR</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">else</span>&#123;</div><div class="line">			copy data to tcp buf</div><div class="line">			<span class="keyword">if</span> copy err</div><div class="line">				<span class="keyword">return</span> SCOKET_ERR</div><div class="line">			<span class="keyword">return</span> copy data size</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p> 剩余缓冲区能容纳发送数据，则直接将数据拷贝到缓冲区中，send直接返回。如果剩余缓冲区不足，发送端阻塞等待，对端在协议栈层接收到数据后会发送ack确认，发送方接收到ack后释放缓冲区空间；如果此时剩余缓冲区大小可放置要发送数据，则直接将数据拷入缓冲区，返回。<br> Tips：阻塞模式下，数据发送正常，其返回的数据长度一定是发送数据的长度。</p>
</li>
</ul>
<ul>
<li>非阻塞模式下<br>  send函数将数据拷入协议栈缓冲区，如果缓冲区不足，则send尽力拷贝，并返回拷贝大小；如果缓冲区满则返回-1，同时errno为EAGAIN，让发送端再次尝试发送数据。</li>
</ul>
<h2 id="发送缓冲区设置"><a href="#发送缓冲区设置" class="headerlink" title="发送缓冲区设置"></a>发送缓冲区设置</h2><pre><code>socklen_t sendbuflen = 0;  
socklen_t len = sizeof(sendbuflen);  
getsockopt(clientSocket, SOL_SOCKET, SO_SNDBUF, (void*)&amp;sendbuflen, &amp;len);  
printf(&quot;default,sendbuf:%d\n&quot;, sendbuflen);      
sendbuflen = 10240;  
setsockopt(clientSocket, SOL_SOCKET, SO_SNDBUF, (void*)&amp;sendbuflen, len);  
getsockopt(clientSocket, SOL_SOCKET, SO_SNDBUF, (void*)&amp;sendbuflen, &amp;len);  
printf(&quot;now,sendbuf:%d\n&quot;, sendbuflen); 
</code></pre><h2 id="send发包实例解析"><a href="#send发包实例解析" class="headerlink" title="send发包实例解析"></a>send发包实例解析</h2><p>实际socket使用过程中，常用的是非阻塞模式，我们就以非阻塞模式为例进行分析，预设多种场景如下：</p>
<ul>
<li><p>场景1：发送端10k数据已经安全放入缓冲区，已实际发出2k（收到对端ack），接收端正在处理数据，此时发送端因为10k数据发送完毕，关闭了socket。</p>
<blockquote>
<p>场景分析：</p>
<blockquote>
<p>发送端关闭socket，主动fin告诉对端发送端数据发送完毕想关闭TCP连接，发送完fin后发送端处于fin wait1状态等待接收端ack确认；发送端协议栈剩余8k数据依然在独立发送，待数据发送完成后，协议栈才会把fin发给接收端；接收端在接收ack完10k数据后，且收到fin信号后，接收端回复ack确认fin信号，两者协商关闭socket。</p>
</blockquote>
</blockquote>
</li>
<li><p>场景2：发送端预期发送10k数据，已将2k数据拷入缓冲区并实际发出拷入的2k数据（收到对端ack），接收端正在处理数据，此时发送端又发送了8k新数据；（缓冲区充足(8k新数据会被拷入缓冲区)情况我们不讨论）缓冲区不足时候会发生什么？</p>
<blockquote>
<p>场景分析</p>
<blockquote>
<p>新发送的10k数据会尽力拷入缓冲区，send返回拷入缓冲区数据长度2k，如果此时缓冲区剩余空间为0时候，客户端强制send数据，会收到EAGAIN信号；其实这种情况客户端正确处理方式是读出缓冲区可写信号再发送数据，而不是自己进行发送尝试。</p>
</blockquote>
</blockquote>
</li>
<li><p>场景3:发送端10k数据已经安全放入缓冲区，已实际发出2k（收到对端ack），接收端正在处理接收到1k数据，处理完成后数据接收端关闭了socket，会发发生什么？</p>
<blockquote>
<p>场景分析</p>
<blockquote>
<ul>
<li>数据发送端有监听机制，数据发送端用户态会得到接收端端关闭信号（socket可读信号），这时候用户正确打开方式是调用close关闭socket</li>
<li>如果数据发送端未处理该关闭信号，且数据接收端没有rst强制关闭连接，数据发送端仍然可正常发送数据</li>
<li>如果数据发送端未处理该关闭信号，但是数据接收端已经rst强制关闭连接，数据发送端仍然在send发送数据，send将返回-1</li>
<li>如果是阻塞情况，但是因缓冲区满正在阻塞，如果接收端发送rst，阻塞发送端会退出阻塞返回，发送成功字节数，如果在此调用send，将返回-1</li>
</ul>
</blockquote>
</blockquote>
</li>
<li><p>场景4：发送端10k数据已经安全放入缓冲区，已实际发出2k（收到对端ack），接收端正在处理接收到1k数据，此时网络出现异常</p>
<blockquote>
<p>场景分析</p>
<blockquote>
<p>接收应用程序在处理完已收到的1k数据后,会继续从缓存区读取余下的1k数据,然后就表现为无数据可读的现象,这种情况需要应用程序来处理超时.一般做法是设定一个select等待的最大时间,如果超出这个时间依然没有数据可读,则认为socket已不可用.<br>发送应用程序会不断的将余下的数据发送到网络上,但始终得不到确认,所以缓存区的可用空间持续为0,这种情况也需要应用程序来处理.如果不由应用程序来处理这种情况超时的情况,也可以通过tcp协议本身来处理,具体可以查看sysctl项中的:<br>net.ipv4.tcp_keepalive_intvl<br>net.ipv4.tcp_keepalive_probes<br>net.ipv4.tcp_keepalive_time</p>
</blockquote>
</blockquote>
</li>
</ul>
<h2 id="send特点"><a href="#send特点" class="headerlink" title="send特点"></a>send特点</h2><ul>
<li>send只是将数据放入缓冲区中，并不是真正已经发给对方</li>
<li>非阻塞发送字节可以是1-n，其发送多少完全依赖于剩余的发送缓冲区</li>
</ul>
<h2 id="socket发送函数解析"><a href="#socket发送函数解析" class="headerlink" title="socket发送函数解析"></a>socket发送函数解析</h2><h3 id="发送流程图"><a href="#发送流程图" class="headerlink" title="发送流程图"></a>发送流程图</h3><blockquote>
<p>send<br>sendto<br>sendmmsg<br>sendmsg </p>
</blockquote>
<p>上述流程调用过程如下：<br>-&gt;socketcall -&gt;sock_sendmsg -&gt; __sock_sendmsg -&gt; sock-&gt;ops-&gt;sendmsg(inet_sendmsg)<br>-&gt;[tcp_prot]tcp_sendmsg</p>
<h3 id="内核系统调用"><a href="#内核系统调用" class="headerlink" title="内核系统调用"></a>内核系统调用</h3><p>send    、sendto、sendmsg、sendmmsg发送函数由glibc提供，声明于/usr/include/sys/socket.h<br>用户态在调用后会进入到sys_socketcall系统调用中，下面代码部分就是其入口<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">SYSCALL_DEFINE2(socketcall, <span class="keyword">int</span>, call, <span class="keyword">unsigned</span> <span class="keyword">long</span> __user *, args)</div><div class="line">&#123;</div><div class="line">...</div><div class="line">	<span class="keyword">switch</span> (call) &#123;</div><div class="line">	...</div><div class="line">	<span class="keyword">case</span> SYS_SEND:</div><div class="line">		err = sys_send(a0, (<span class="keyword">void</span> __user *)a1, a[<span class="number">2</span>], a[<span class="number">3</span>]);</div><div class="line">		<span class="keyword">break</span>;</div><div class="line">	<span class="keyword">case</span> SYS_SENDTO:</div><div class="line">		err = sys_sendto(a0, (<span class="keyword">void</span> __user *)a1, a[<span class="number">2</span>], a[<span class="number">3</span>],</div><div class="line">				 (struct sockaddr __user *)a[<span class="number">4</span>], a[<span class="number">5</span>]);</div><div class="line">		<span class="keyword">break</span>;</div><div class="line">	...</div><div class="line">	<span class="keyword">case</span> SYS_SENDMSG:</div><div class="line">		err = sys_sendmsg(a0, (struct msghdr __user *)a1, a[<span class="number">2</span>]);</div><div class="line">		<span class="keyword">break</span>;</div><div class="line">	<span class="keyword">case</span> SYS_SENDMMSG:</div><div class="line">		err = sys_sendmmsg(a0, (struct mmsghdr __user *)a1, a[<span class="number">2</span>], a[<span class="number">3</span>]);</div><div class="line">		<span class="keyword">break</span>;</div><div class="line">	...</div><div class="line">		<span class="keyword">default</span>:</div><div class="line">		err = -EINVAL;</div><div class="line">		<span class="keyword">break</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> err;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>send 是sendto的一种特殊情况,(sendto发送地址为NULL发送地址长度为0)</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">SYSCALL_DEFINE4(send, <span class="keyword">int</span>, fd, <span class="keyword">void</span> __user *, buff, <span class="keyword">size_t</span>, len,</div><div class="line">		<span class="keyword">unsigned</span> <span class="keyword">int</span>, flags)</div><div class="line">&#123;</div><div class="line">	<span class="keyword">return</span> sys_sendto(fd, buff, len, flags, <span class="literal">NULL</span>, <span class="number">0</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>sendto -&gt; sock_sendmsg -&gt; __sock_sendmsg -&gt; sock-&gt;ops-&gt;sendmsg(inet_sendmsg)</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">SYSCALL_DEFINE6(sendto, <span class="keyword">int</span>, fd, <span class="keyword">void</span> __user *, buff, <span class="keyword">size_t</span>, len,</div><div class="line">		<span class="keyword">unsigned</span> <span class="keyword">int</span>, flags, struct sockaddr __user *, addr,</div><div class="line">		<span class="keyword">int</span>, addr_len)</div><div class="line">&#123;</div><div class="line"> ...</div><div class="line">	err = sock_sendmsg(sock, &amp;msg, len);</div><div class="line"></div><div class="line">out_put:</div><div class="line">	fput_light(sock-&gt;file, fput_needed);</div><div class="line">out:</div><div class="line">	<span class="keyword">return</span> err;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>sendmsg 和sendmmsg 完成用户态数据拷贝到内核态后，最终也是调用inet_sendmsg处理，在此就拿sendto情况详细分析</li>
</ul>
<h3 id="sendto源码实现分析"><a href="#sendto源码实现分析" class="headerlink" title="sendto源码实现分析"></a>sendto源码实现分析</h3><p>sendto -&gt; sock_sendmsg -&gt; “<strong>sock_sendmsg” -&gt;”</strong>sock_sendmsg_nosec” -&gt; sock-&gt;ops-&gt;sendmsg(inet_sendmsg)</p>
<ul>
<li>首先分析sock_sendmsg实现</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">sock_sendmsg</span><span class="params">(struct socket *sock, struct msghdr *msg, <span class="keyword">size_t</span> size)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kiocb</span> <span class="title">iocb</span>;</span></div><div class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sock_iocb</span> <span class="title">siocb</span>;</span></div><div class="line">	<span class="keyword">int</span> ret;</div><div class="line">	<span class="comment">/*异步IO控制块初始化*/</span></div><div class="line">	init_sync_kiocb(&amp;iocb, <span class="literal">NULL</span>);</div><div class="line">	iocb.<span class="keyword">private</span> = &amp;siocb;</div><div class="line">	<span class="comment">/*异步控制块调用完毕后，可调用__sock_sendmsg发送数据*/</span></div><div class="line">	ret = __sock_sendmsg(&amp;iocb, sock, msg, size);</div><div class="line">	<span class="keyword">if</span> (-EIOCBQUEUED == ret)</div><div class="line">		ret = wait_on_sync_kiocb(&amp;iocb);</div><div class="line">	<span class="keyword">return</span> ret;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> __sock_sendmsg(struct kiocb *iocb, struct socket *sock,</div><div class="line">				 struct msghdr *msg, <span class="keyword">size_t</span> size)</div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span> err = security_socket_sendmsg(sock, msg, size);</div><div class="line">	<span class="comment">/*调用__sock_sendmsg_nosec*/</span></div><div class="line">	<span class="keyword">return</span> err ?: __sock_sendmsg_nosec(iocb, sock, msg, size);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> __sock_sendmsg_nosec(struct kiocb *iocb, struct socket *sock,</div><div class="line">				       struct msghdr *msg, <span class="keyword">size_t</span> size)</div><div class="line">&#123;</div><div class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sock_iocb</span> *<span class="title">si</span> = <span class="title">kiocb_to_siocb</span>(<span class="title">iocb</span>);</span></div><div class="line"></div><div class="line">	si-&gt;sock = sock;</div><div class="line">	si-&gt;scm = <span class="literal">NULL</span>;</div><div class="line">	si-&gt;msg = msg;</div><div class="line">	si-&gt;size = size;</div><div class="line">	</div><div class="line">	<span class="comment">/*调用inet_sendnsg*/</span></div><div class="line">	<span class="keyword">return</span> sock-&gt;ops-&gt;sendmsg(iocb, sock, msg, size);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">inet_sendmsg</span><span class="params">(struct kiocb *iocb, struct socket *sock, struct msghdr *msg,</span></span></div><div class="line">		 <span class="keyword">size_t</span> size)</div><div class="line">&#123;</div><div class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *<span class="title">sk</span> = <span class="title">sock</span>-&gt;<span class="title">sk</span>;</span></div><div class="line"></div><div class="line">	sock_rps_record_flow(sk);</div><div class="line">	<span class="comment">/*如果连接没有分配本地端口且允许分配本地端口，我们就给连接绑定一个本地端口</span></div><div class="line">	*/</div><div class="line">	<span class="comment">/* We may need to bind the socket. */</span></div><div class="line">	<span class="keyword">if</span> (!inet_sk(sk)-&gt;inet_num &amp;&amp; !sk-&gt;sk_prot-&gt;no_autobind &amp;&amp;</div><div class="line">	    inet_autobind(sk))</div><div class="line">	   </div><div class="line">		<span class="keyword">return</span> -EAGAIN;</div><div class="line">	<span class="comment">/*传输层是TCP情况下，调用tcp_sendmsg()*/</span></div><div class="line">	<span class="keyword">return</span> sk-&gt;sk_prot-&gt;sendmsg(iocb, sk, msg, size);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>其次分析inet_autobind ，获取可用端口并给，获取后的端口会赋值给inet-&gt;inet_sport/inet_num</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">inet_autobind</span><span class="params">(struct sock *sk)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inet_sock</span> *<span class="title">inet</span>;</span></div><div class="line">	<span class="comment">/* We may need to bind the socket. */</span></div><div class="line">	lock_sock(sk);</div><div class="line">	inet = inet_sk(sk);</div><div class="line">	<span class="keyword">if</span> (!inet-&gt;inet_num) &#123;</div><div class="line">		<span class="comment">/*针对于TCP情况sk-&gt;sk_prot-&gt;get_port调用的是inet_csk_get_port</span></div><div class="line">		* inet_csk_get_port工作获取端口，并将其赋值给inet-&gt;inet_num</div><div class="line">		*/</div><div class="line">		<span class="keyword">if</span> (sk-&gt;sk_prot-&gt;get_port(sk, <span class="number">0</span>)) &#123;</div><div class="line">			release_sock(sk);</div><div class="line">			<span class="keyword">return</span> -EAGAIN;</div><div class="line">		&#125;</div><div class="line">		<span class="comment">/*获取inet-&gt;inet_num赋值给inet-&gt;inet_sport*/</span></div><div class="line">		inet-&gt;inet_sport = htons(inet-&gt;inet_num);</div><div class="line">	&#125;</div><div class="line">	release_sock(sk);</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>最后分析tcp_sendmsg</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div><div class="line">230</div><div class="line">231</div><div class="line">232</div><div class="line">233</div><div class="line">234</div><div class="line">235</div><div class="line">236</div><div class="line">237</div><div class="line">238</div><div class="line">239</div><div class="line">240</div><div class="line">241</div><div class="line">242</div><div class="line">243</div><div class="line">244</div><div class="line">245</div><div class="line">246</div><div class="line">247</div><div class="line">248</div><div class="line">249</div><div class="line">250</div><div class="line">251</div><div class="line">252</div><div class="line">253</div><div class="line">254</div><div class="line">255</div><div class="line">256</div><div class="line">257</div><div class="line">258</div><div class="line">259</div><div class="line">260</div><div class="line">261</div><div class="line">262</div><div class="line">263</div><div class="line">264</div><div class="line">265</div><div class="line">266</div><div class="line">267</div><div class="line">268</div><div class="line">269</div><div class="line">270</div><div class="line">271</div><div class="line">272</div><div class="line">273</div><div class="line">274</div><div class="line">275</div><div class="line">276</div><div class="line">277</div><div class="line">278</div><div class="line">279</div><div class="line">280</div><div class="line">281</div><div class="line">282</div><div class="line">283</div><div class="line">284</div><div class="line">285</div><div class="line">286</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">tcp_sendmsg</span><span class="params">(struct kiocb *iocb, struct sock *sk, struct msghdr *msg,</span></span></div><div class="line">		<span class="keyword">size_t</span> size)</div><div class="line">&#123;</div><div class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> *<span class="title">iov</span>;</span></div><div class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tcp_sock</span> *<span class="title">tp</span> = <span class="title">tcp_sk</span>(<span class="title">sk</span>);</span></div><div class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">skb</span>;</span></div><div class="line">	<span class="keyword">int</span> iovlen, flags, err, copied = <span class="number">0</span>;</div><div class="line">	<span class="keyword">int</span> mss_now = <span class="number">0</span>, size_goal, copied_syn = <span class="number">0</span>, offset = <span class="number">0</span>;</div><div class="line">	<span class="keyword">bool</span> sg;</div><div class="line">	<span class="keyword">long</span> timeo;</div><div class="line"></div><div class="line">	lock_sock(sk);</div><div class="line">	</div><div class="line">	flags = msg-&gt;msg_flags;</div><div class="line">	<span class="keyword">if</span> (flags &amp; MSG_FASTOPEN) &#123;</div><div class="line">		err = tcp_sendmsg_fastopen(sk, msg, &amp;copied_syn, size);</div><div class="line">		<span class="keyword">if</span> (err == -EINPROGRESS &amp;&amp; copied_syn &gt; <span class="number">0</span>)</div><div class="line">			<span class="keyword">goto</span> out;</div><div class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (err)</div><div class="line">			<span class="keyword">goto</span> out_err;</div><div class="line">		offset = copied_syn;</div><div class="line">	&#125;</div><div class="line">  </div><div class="line">    <span class="comment">/*</span></div><div class="line">	* 获取数据发送超时时间</div><div class="line">	*/</div><div class="line">	timeo = sock_sndtimeo(sk, flags &amp; MSG_DONTWAIT);</div><div class="line"></div><div class="line">	<span class="comment">/* Wait for a connection to finish. One exception is TCP Fast Open</span></div><div class="line">	 * (passive side) where data is allowed to be sent before a connection</div><div class="line">	 * is fully established.</div><div class="line">	 */</div><div class="line">	<span class="comment">/*</span></div><div class="line">	 * TCP状态检查，ES和CLOSE_WAIT状态才能发送数据，其它状态都要等待连接建立起来</div><div class="line">	 * 否则直接返回错误</div><div class="line">	 * </div><div class="line">	 * 随着协议栈进步，增加一种情况tcp_passive_fastopen即tcp被动快速打开时候，不区分当前TCP处于状态</div><div class="line">	 */</div><div class="line">	<span class="keyword">if</span> (((<span class="number">1</span> &lt;&lt; sk-&gt;sk_state) &amp; ~(TCPF_ESTABLISHED | TCPF_CLOSE_WAIT)) &amp;&amp;</div><div class="line">	    !tcp_passive_fastopen(sk)) &#123;</div><div class="line">	    <span class="comment">/*等待连接建立，连接建立成功则返回0*/</span></div><div class="line">		<span class="keyword">if</span> ((err = sk_stream_wait_connect(sk, &amp;timeo)) != <span class="number">0</span>)</div><div class="line">			<span class="keyword">goto</span> do_error;</div><div class="line">	&#125;</div><div class="line">	<span class="comment">/*开启repair功能处理*/</span></div><div class="line">	<span class="keyword">if</span> (unlikely(tp-&gt;repair)) &#123;</div><div class="line">		<span class="keyword">if</span> (tp-&gt;repair_queue == TCP_RECV_QUEUE) &#123;</div><div class="line">			copied = tcp_send_rcvq(sk, msg, size);</div><div class="line">			<span class="keyword">goto</span> out_nopush;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		err = -EINVAL;</div><div class="line">		<span class="keyword">if</span> (tp-&gt;repair_queue == TCP_NO_QUEUE)</div><div class="line">			<span class="keyword">goto</span> out_err;</div><div class="line"></div><div class="line">		<span class="comment">/* 'common' sending to sendq */</span></div><div class="line">	&#125;</div><div class="line">	<span class="comment">/**/</span></div><div class="line">	<span class="comment">/* This should be in poll */</span></div><div class="line">	clear_bit(SOCK_ASYNC_NOSPACE, &amp;sk-&gt;sk_socket-&gt;flags);</div><div class="line"></div><div class="line">	<span class="comment">/*获取发送mss*/</span></div><div class="line">	mss_now = tcp_send_mss(sk, &amp;size_goal, flags);</div><div class="line"></div><div class="line">	<span class="comment">/* Ok commence sending. */</span></div><div class="line">	iovlen = msg-&gt;msg_iovlen;<span class="comment">//应用层要发送数据块个数</span></div><div class="line">	iov = msg-&gt;msg_iov;<span class="comment">//要发送数据地址</span></div><div class="line">	copied = <span class="number">0</span>;<span class="comment">//已经放到缓冲区的数据长度</span></div><div class="line"></div><div class="line">	err = -EPIPE;</div><div class="line">	<span class="comment">/*在发送数据前，如果sk已经关闭或者出现err，直接返回 -EPIPE*/</span></div><div class="line">	<span class="keyword">if</span> (sk-&gt;sk_err || (sk-&gt;sk_shutdown &amp; SEND_SHUTDOWN))</div><div class="line">		<span class="keyword">goto</span> out_err;</div><div class="line"></div><div class="line">	<span class="comment">/*网卡分散聚合*/</span></div><div class="line">	sg = !!(sk-&gt;sk_route_caps &amp; NETIF_F_SG);</div><div class="line"></div><div class="line">	<span class="keyword">while</span> (--iovlen &gt;= <span class="number">0</span>) &#123;</div><div class="line">	</div><div class="line">		<span class="comment">/*获取用户态数据长度和数据指针并指向下一个用户态要发送数据块*/</span></div><div class="line">		<span class="keyword">size_t</span> seglen = iov-&gt;iov_len;</div><div class="line">		<span class="keyword">unsigned</span> <span class="keyword">char</span> __user *from = iov-&gt;iov_base;</div><div class="line">		iov++;</div><div class="line">		</div><div class="line">		<span class="comment">/*TCP fast open涉及*/</span></div><div class="line">		<span class="keyword">if</span> (unlikely(offset &gt; <span class="number">0</span>)) &#123;  <span class="comment">/* Skip bytes copied in SYN */</span></div><div class="line">			<span class="keyword">if</span> (offset &gt;= seglen) &#123;</div><div class="line">				offset -= seglen;</div><div class="line">				<span class="keyword">continue</span>;</div><div class="line">			&#125;</div><div class="line">			seglen -= offset;</div><div class="line">			from += offset;</div><div class="line">			offset = <span class="number">0</span>;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="keyword">while</span> (seglen &gt; <span class="number">0</span>) &#123;</div><div class="line">			<span class="keyword">int</span> copy = <span class="number">0</span>;</div><div class="line">			<span class="keyword">int</span> max = size_goal;</div><div class="line">			<span class="comment">/*从发送队列尾部取skb，尝试将用户态数据放入skb-&gt;data剩余空间*/</span></div><div class="line">			skb = tcp_write_queue_tail(sk);</div><div class="line">			<span class="keyword">if</span> (tcp_send_head(sk)) &#123;</div><div class="line">			</div><div class="line">				<span class="comment">/*另一种mss情况，GSO*/</span></div><div class="line">				<span class="keyword">if</span> (skb-&gt;ip_summed == CHECKSUM_NONE)</div><div class="line">					max = mss_now;</div><div class="line">				copy = max - skb-&gt;len;</div><div class="line">			&#125;</div><div class="line"></div><div class="line">			<span class="keyword">if</span> (copy &lt;= <span class="number">0</span>) &#123;<span class="comment">/*skb已经装满数据，后续会申请新的skb来发送数据*/</span></div><div class="line">new_segment:</div><div class="line">				<span class="comment">/* Allocate new segment. If the interface is SG,</span></div><div class="line">				 * allocate skb fitting to single page.</div><div class="line">				 */</div><div class="line">				<span class="keyword">if</span> (!sk_stream_memory_free(sk))</div><div class="line">					<span class="keyword">goto</span> wait_for_sndbuf;</div><div class="line">				</div><div class="line">				<span class="comment">/*申请内存大小为select_size（线性数据区+协议头），申请失败或者不合法，睡眠等待*/</span></div><div class="line">				skb = sk_stream_alloc_skb(sk,</div><div class="line">							  select_size(sk, sg),</div><div class="line">							  sk-&gt;sk_allocation);</div><div class="line">				<span class="keyword">if</span> (!skb)</div><div class="line">					<span class="keyword">goto</span> wait_for_memory;</div><div class="line"></div><div class="line">				<span class="comment">/*</span></div><div class="line">				 * Check whether we can use HW checksum.</div><div class="line">				 * 检查释放网卡硬件释放可以计算校验和</div><div class="line">				 */</div><div class="line">				<span class="keyword">if</span> (sk-&gt;sk_route_caps &amp; NETIF_F_CSUM_MASK)</div><div class="line">					skb-&gt;ip_summed = CHECKSUM_PARTIAL;</div><div class="line"></div><div class="line">				<span class="comment">/*将新分配的skb入sk_write_queue数据发送队列*/</span></div><div class="line">				skb_entail(sk, skb);</div><div class="line">				copy = size_goal;</div><div class="line">				max = size_goal;</div><div class="line"></div><div class="line">				<span class="comment">/* All packets are restored as if they have</span></div><div class="line">				 * already been sent. skb_mstamp isn't set to</div><div class="line">				 * avoid wrong rtt estimation.</div><div class="line">				 * TCP repair</div><div class="line">				 */</div><div class="line">				<span class="keyword">if</span> (tp-&gt;repair)</div><div class="line">					TCP_SKB_CB(skb)-&gt;sacked |= TCPCB_REPAIRED;</div><div class="line">			&#125;</div><div class="line"></div><div class="line">			<span class="comment">/* Try to append data to the end of skb. */</span></div><div class="line">			<span class="keyword">if</span> (copy &gt; seglen)</div><div class="line">				copy = seglen;</div><div class="line"></div><div class="line">			<span class="comment">/* Where to copy to? */</span></div><div class="line">			<span class="comment">/*如果数据还有线性区间，直接将数据拷入冰计算校验和*/</span></div><div class="line">			<span class="keyword">if</span> (skb_availroom(skb) &gt; <span class="number">0</span>) &#123;</div><div class="line">				<span class="comment">/* We have some space in skb head. Superb! */</span></div><div class="line">				copy = <span class="keyword">min_t</span>(<span class="keyword">int</span>, copy, skb_availroom(skb));</div><div class="line">				err = skb_add_data_nocache(sk, skb, from, copy);</div><div class="line">				<span class="keyword">if</span> (err)</div><div class="line">					<span class="keyword">goto</span> do_fault;</div><div class="line">			&#125; <span class="keyword">else</span> &#123;<span class="comment">/*如果没有了线性空间*/</span></div><div class="line">				<span class="comment">/*</span></div><div class="line">				*  数据会被复制到分页中</div><div class="line">				*  </div><div class="line">				*/</div><div class="line">				<span class="keyword">bool</span> merge = <span class="literal">true</span>;</div><div class="line">				<span class="comment">/*取得当前SKB的分片段数*/</span></div><div class="line">				<span class="keyword">int</span> i = skb_shinfo(skb)-&gt;nr_frags;</div><div class="line">				<span class="class"><span class="keyword">struct</span> <span class="title">page_frag</span> *<span class="title">pfrag</span> = <span class="title">sk_page_frag</span>(<span class="title">sk</span>);</span></div><div class="line">				<span class="comment">/*检查分也可用空间，如果没有就申请新的页，如果系统内存不足就睡眠等待*/</span></div><div class="line">				<span class="keyword">if</span> (!sk_page_frag_refill(sk, pfrag))</div><div class="line">					<span class="keyword">goto</span> wait_for_memory;</div><div class="line">				</div><div class="line">				<span class="comment">/*如果不能将数据最佳到最后一个分片*/</span></div><div class="line">				<span class="keyword">if</span> (!skb_can_coalesce(skb, i, pfrag-&gt;page,</div><div class="line">						      pfrag-&gt;offset)) &#123;</div><div class="line">					<span class="comment">/*分页已经达到最大规格，将当前数据发出去，跳到new_segment重新申请skb*/</span></div><div class="line">					<span class="keyword">if</span> (i == MAX_SKB_FRAGS || !sg) &#123;</div><div class="line">						tcp_mark_push(tp, skb);</div><div class="line">						<span class="keyword">goto</span> new_segment;</div><div class="line">					&#125;</div><div class="line">					merge = <span class="literal">false</span>;</div><div class="line">				&#125;</div><div class="line"></div><div class="line">				copy = <span class="keyword">min_t</span>(<span class="keyword">int</span>, copy, pfrag-&gt;size - pfrag-&gt;offset);</div><div class="line">				</div><div class="line">				<span class="comment">/*系统对发送缓冲区申请合法性判断*/</span></div><div class="line">				<span class="keyword">if</span> (!sk_wmem_schedule(sk, copy))</div><div class="line">					<span class="keyword">goto</span> wait_for_memory;</div><div class="line">				<span class="comment">/*拷贝用户空间数据，同时计算校验和，更新数据skb长度和缓存*/</span></div><div class="line">				err = skb_copy_to_page_nocache(sk, from, skb,</div><div class="line">							       pfrag-&gt;page,</div><div class="line">							       pfrag-&gt;offset,</div><div class="line">							       copy);</div><div class="line">				<span class="keyword">if</span> (err)</div><div class="line">					<span class="keyword">goto</span> do_error;</div><div class="line"></div><div class="line">				<span class="comment">/* Update the skb. */</span></div><div class="line">				<span class="comment">/*最后一个分页可以放数据数据页被放入了，就更新分也大小记录*/</span></div><div class="line">				<span class="keyword">if</span> (merge) &#123;</div><div class="line">					skb_frag_size_add(&amp;skb_shinfo(skb)-&gt;frags[i - <span class="number">1</span>], copy);</div><div class="line">				&#125; <span class="keyword">else</span> &#123;</div><div class="line">					<span class="comment">/*如果不能分页就新增页，并初始化*/</span></div><div class="line">					skb_fill_page_desc(skb, i, pfrag-&gt;page,</div><div class="line">							   pfrag-&gt;offset, copy);</div><div class="line">					get_page(pfrag-&gt;page);</div><div class="line">				&#125;</div><div class="line">				pfrag-&gt;offset += copy;</div><div class="line">			&#125;</div><div class="line">			</div><div class="line">			<span class="comment">/*如果复制数据长度为0，不用加PSH标记*/</span></div><div class="line">			<span class="keyword">if</span> (!copied)</div><div class="line">				TCP_SKB_CB(skb)-&gt;tcp_flags &amp;= ~TCPHDR_PSH;</div><div class="line">			<span class="comment">/*更新发送队列中最后一个序号，数据包的最后一个序号*/</span></div><div class="line">			tp-&gt;write_seq += copy;</div><div class="line">			TCP_SKB_CB(skb)-&gt;end_seq += copy;</div><div class="line">			skb_shinfo(skb)-&gt;gso_segs = <span class="number">0</span>;</div><div class="line">			</div><div class="line">			<span class="comment">/*已经拷入了copy大小数据，用户态指针后移且更新已经拷贝数据增加*/</span></div><div class="line">			from += copy;</div><div class="line">			copied += copy;</div><div class="line">			</div><div class="line">			<span class="comment">/*所有数据处理完毕，直接退出*/</span></div><div class="line">			<span class="keyword">if</span> ((seglen -= copy) == <span class="number">0</span> &amp;&amp; iovlen == <span class="number">0</span>)</div><div class="line">				<span class="keyword">goto</span> out;</div><div class="line"></div><div class="line">			<span class="comment">/*如果skbb还可以继续填充数据或者是带外数据或者是有REPAIR选项，继续使用skb*/</span></div><div class="line">			<span class="keyword">if</span> (skb-&gt;len &lt; max || (flags &amp; MSG_OOB) || unlikely(tp-&gt;repair))</div><div class="line">				<span class="keyword">continue</span>;</div><div class="line"></div><div class="line">			<span class="comment">/*检查释放必须立即发送，即检查自上次发送后产生的数据是否已经超过对方通告过的最大接收窗口的一半。如果必须发送则设置紧急数据标示，然后将数据发出去*/</span></div><div class="line">			<span class="keyword">if</span> (forced_push(tp)) &#123;</div><div class="line">				tcp_mark_push(tp, skb);</div><div class="line">				__tcp_push_pending_frames(sk, mss_now, TCP_NAGLE_PUSH);</div><div class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> (skb == tcp_send_head(sk))</div><div class="line">				<span class="comment">/*数据不必立即发送，且数据上只存在这段数据，则将这段数据发出*/</span></div><div class="line">				tcp_push_one(sk, mss_now);</div><div class="line">				</div><div class="line">			<span class="keyword">continue</span>;</div><div class="line"></div><div class="line">wait_for_sndbuf:</div><div class="line"><span class="comment">/*套接口缓冲区大小超过限制，此时无法再申请skb放数据，我们设置socket满标志*/</span></div><div class="line">			set_bit(SOCK_NOSPACE, &amp;sk-&gt;sk_socket-&gt;flags);</div><div class="line">			</div><div class="line"><span class="comment">/*系统内存不足处理*/</span></div><div class="line">wait_for_memory:</div><div class="line">	<span class="comment">/*skb分配失败了，已经拷入发送队列数据，直接调用tcp_push发出去</span></div><div class="line">	～MSG_MORE表示无更多数据</div><div class="line">	TCP_NAGLE_PUSH 选项调用NAGLE，尽量减少小字节发送数据</div><div class="line">	*/</div><div class="line">			<span class="keyword">if</span> (copied)</div><div class="line">				tcp_push(sk, flags &amp; ~MSG_MORE, mss_now,</div><div class="line">					 TCP_NAGLE_PUSH, size_goal);</div><div class="line">		<span class="comment">/*等待内存空闲，超过timeo时间后返回错误*/</span></div><div class="line">			<span class="keyword">if</span> ((err = sk_stream_wait_memory(sk, &amp;timeo)) != <span class="number">0</span>)</div><div class="line">				<span class="keyword">goto</span> do_error;</div><div class="line">			<span class="comment">/*啊，内存来了，重新获取MSS和TSO，继续将用户态数据拷入缓冲区*/</span></div><div class="line">			mss_now = tcp_send_mss(sk, &amp;size_goal, flags);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">out:</div><div class="line">	<span class="comment">/*如果数据已经拷入发送队列，则立即发送*/</span></div><div class="line">	<span class="keyword">if</span> (copied)</div><div class="line">		tcp_push(sk, flags, mss_now, tp-&gt;nonagle, size_goal);</div><div class="line">out_nopush:</div><div class="line">	release_sock(sk);</div><div class="line">	<span class="keyword">return</span> copied + copied_syn;</div><div class="line"></div><div class="line">do_fault:</div><div class="line">	<span class="comment">/*复制数据异常时才进入这里</span></div><div class="line">	* skb无负载数据，从发送队列上去除，并更新发送队列等参数*/</div><div class="line">	<span class="keyword">if</span> (!skb-&gt;len) &#123;</div><div class="line">		tcp_unlink_write_queue(skb, sk);</div><div class="line">		<span class="comment">/* It is the one place in all of TCP, except connection</span></div><div class="line">		 * reset, where we can be unlinking the send_head.</div><div class="line">		 */</div><div class="line">		tcp_check_send_head(sk, skb);</div><div class="line">		sk_wmem_free_skb(sk, skb);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">do_error:</div><div class="line">	<span class="comment">/*如果已经复制了部分数据，即使发生了错误也可以发送，跳到out就是去发送数据去了*/</span></div><div class="line">	<span class="keyword">if</span> (copied + copied_syn)</div><div class="line">		<span class="keyword">goto</span> out;</div><div class="line">out_err:</div><div class="line">	err = sk_stream_error(sk, flags, err);</div><div class="line">	release_sock(sk);</div><div class="line">	<span class="keyword">return</span> err;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>tcp_sendmsg()做了以下事情：</p>
<ol>
<li>如果使用了TCP Fast Open，则会在发送SYN包的同时携带上数据。</li>
<li>如果连接尚未建立好，不处于ESTABLISHED或者CLOSE_WAIT状态，<br> 那么进程进行睡眠，等待三次握手的完成。</li>
<li>获取当前的MSS、网络设备支持的最大数据长度size_goal。<br> 如果支持GSO，size_goal会是MSS的整数倍。</li>
<li>遍历用户层的数据块数组：<br> 4.1 获取发送队列的最后一个skb，如果是尚未发送的，且长度尚未达到size_goal，<pre><code>那么可以往此skb继续追加数据。
</code></pre> 4.2 否则需要申请一个新的skb来装载数据。<br> 4.2.1 如果发送队列的总大小sk_wmem_queued大于等于发送缓存的上限sk_sndbuf，<pre><code>或者发送缓存中尚未发送的数据量超过了用户的设置值：
设置同步发送时发送缓存不够的标志。
如果此时已有数据复制到发送队列了，就尝试立即发送。
等待发送缓存，直到sock有发送缓存可写事件唤醒进程，或者等待超时。
</code></pre> 4.2.2 申请一个skb，其线性数据区的大小为：<pre><code>通过select_size()得到的线性数据区中TCP负荷的大小 + 最大的协议头长度。
如果申请skb失败了，或者虽然申请skb成功，但是从系统层面判断此次申请不合法，
等待可用内存，等待时间为2~202ms之间的一个随机数。
</code></pre> 4.2.3 如果以上两步成功了，就更新skb的TCP控制块字段，把skb加入到sock发送队列的尾部，<pre><code>增加发送队列的大小，减小预分配缓存的大小。
</code></pre> 4.3 接下来就是拷贝消息头中的数据到skb中了。<pre><code>如果skb的线性数据区还有剩余空间，就复制数据到线性数据区中，同时计算校验和。
</code></pre> 4.4 如果skb的线性数据区已经用完了，那么就使用分页区：<br> 4.4.1 检查分页是否有可用空间，如果没有就申请新的page。如果申请失败，说明系统内存不足。<pre><code>之后会设置TCP内存压力标志，减小发送缓冲区的上限，睡眠等待内存。
</code></pre> 4.4.2 判断能否往最后一个分页追加数据。不能追加时，检查分页数是否达到了上限、<pre><code>或网卡不支持分散聚合。如果是的话，就为此skb设置PSH标志。
然后跳转到4.2处申请新的skb，来继续填装数据。
</code></pre> 4.4.3 从系统层面判断此次分页发送缓存的申请是否合法。<br> 4.4.4 拷贝用户空间的数据到skb的分页中，同时计算校验和。<pre><code>更新skb的长度字段，更新sock的发送队列大小和预分配缓存。
</code></pre> 4.4.5 如果把数据追加到最后一个分页了，更新最后一个分页的数据大小。否则初始化新的分页。<br> 4.5 拷贝成功后更新：发送队列的最后一个序号、skb的结束序号、已经拷贝到发送队列的数据量。<br> 4.6 尽可能的将发送队列中的skb发送出去。</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>  <a href="http://blog.csdn.net/zhangskd/article/details/48207553" target="_blank" rel="external">http://blog.csdn.net/zhangskd/article/details/48207553</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;用户态发送函数列表&quot;&gt;&lt;a href=&quot;#用户态发送函数列表&quot; class=&quot;headerlink&quot; title=&quot;用户态发送函数列表&quot;&gt;&lt;/a&gt;用户态发送函数列表&lt;/h2&gt;&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;ssize_t&lt;/span&gt; send(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; sockfd, &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *buf, &lt;span class=&quot;keyword&quot;&gt;size_t&lt;/span&gt; len, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; flags);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;ssize_t&lt;/span&gt; sendto(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; sockfd, &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *buf, &lt;span class=&quot;keyword&quot;&gt;size_t&lt;/span&gt; len, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; flags,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                            &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; struct sockaddr *dest_addr, &lt;span class=&quot;keyword&quot;&gt;socklen_t&lt;/span&gt; addrlen);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;ssize_t&lt;/span&gt; sendmsg(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; sockfd, &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; struct msghdr *msg, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; flags);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;sendmmsg&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; sockfd, struct mmsghdr *msgvec, &lt;span class=&quot;keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; vlen,&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                                                            &lt;span class=&quot;keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; flags);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                                                            &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;ssize_t&lt;/span&gt; write(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; fd, &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *buf, &lt;span class=&quot;keyword&quot;&gt;size_t&lt;/span&gt; count);&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="socket" scheme="https://vcpu.github.io/categories/socket/"/>
    
    
      <category term="tcp/ip" scheme="https://vcpu.github.io/tags/tcp-ip/"/>
    
      <category term="kernel3.10.0-514.16.1" scheme="https://vcpu.github.io/tags/kernel3-10-0-514-16-1/"/>
    
      <category term="send" scheme="https://vcpu.github.io/tags/send/"/>
    
      <category term="sendto" scheme="https://vcpu.github.io/tags/sendto/"/>
    
      <category term="sendmsg" scheme="https://vcpu.github.io/tags/sendmsg/"/>
    
      <category term="sendmmsg" scheme="https://vcpu.github.io/tags/sendmmsg/"/>
    
  </entry>
  
  <entry>
    <title>f-stack安装运行</title>
    <link href="https://vcpu.github.io/f-stack%E5%AE%89%E8%A3%85/"/>
    <id>https://vcpu.github.io/f-stack安装/</id>
    <published>2017-06-15T08:06:20.000Z</published>
    <updated>2017-06-15T08:06:20.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="mac-os-virtual-box跑f-stack环境搭建"><a href="#mac-os-virtual-box跑f-stack环境搭建" class="headerlink" title="mac os virtual box跑f-stack环境搭建"></a>mac os virtual box跑f-stack环境搭建</h1><h2 id="基本环境"><a href="#基本环境" class="headerlink" title="基本环境"></a>基本环境</h2><p>kernel版本3.10.0-514.el7.x86_64<br>CentOS-7-x86_64-Minimal-1611.iso<br>Mac osx<br>Oreacle Virtual Box5.1.22<br>kernel-devel</p>
<h2 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h2><h3 id="在Oreacle-Virtual-Box上安装centos-7虚拟机"><a href="#在Oreacle-Virtual-Box上安装centos-7虚拟机" class="headerlink" title="在Oreacle Virtual Box上安装centos 7虚拟机"></a>在Oreacle Virtual Box上安装centos 7虚拟机</h3><h4 id="配置开启NAT网卡和桥接网卡"><a href="#配置开启NAT网卡和桥接网卡" class="headerlink" title="配置开启NAT网卡和桥接网卡"></a>配置开启NAT网卡和桥接网卡</h4><ul>
<li>网卡配置芯片类型选择<br>Add two more virtual network adapters with “Intel PRO/1000 MT Server (82545EM)” type in order to provide virtual network hardware to the virtual machine that is supported by Intel DPDK.<br>  上述说明来自于一篇国外文档说明，使用的Inetl 82545EM，但是经过尝试Intel PRO/1000MT桌面(82540EN)也是可以的。所以不要太迷信啦。</li>
</ul>
<a id="more"></a>
<ul>
<li>桥接网卡用来ssh登陆管理串口，NAT网卡用来运行DPDK驱动，跑nginx<br>  在Virtual Box上制作地址映射<br>  <img src="/myimages/wk1.png" alt="wk1"><br>  <img src="/myimages/wk2.png" alt="wk2"></li>
<li>centos7虚拟机上网口配置信息<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div></pre></td><td class="code"><pre><div class="line">[root@localhost ~]# cat /etc/sysconfig/network-scripts/ifcfg-enp0s17</div><div class="line">TYPE="Ethernet"</div><div class="line">BOOTPROTO="dhcp"</div><div class="line">DEFROUTE="yes"</div><div class="line">PEERDNS="yes"</div><div class="line">PEERROUTES="yes"</div><div class="line">IPV4_FAILURE_FATAL="no"</div><div class="line">IPV6INIT="yes"</div><div class="line">IPV6_AUTOCONF="yes"</div><div class="line">IPV6_DEFROUTE="yes"</div><div class="line">IPV6_PEERDNS="yes"</div><div class="line">IPV6_PEERROUTES="yes"</div><div class="line">IPV6_FAILURE_FATAL="no"</div><div class="line">IPV6_ADDR_GEN_MODE="stable-privacy"</div><div class="line">NAME="enp0s17"</div><div class="line">UUID="2ea1ed66-7bcd-4153-a495-39c25d5f0ff9"</div><div class="line">DEVICE="enp0s17"</div><div class="line">ONBOOT="yes"</div><div class="line">[root@localhost ~]# cat /etc/sysconfig/network-scripts/ifcfg-enp0s8</div><div class="line">TYPE=Ethernet</div><div class="line">BOOTPROTO=dhcp</div><div class="line">DEFROUTE=yes</div><div class="line">PEERDNS=yes</div><div class="line">PEERROUTES=yes</div><div class="line">IPV4_FAILURE_FATAL=no</div><div class="line">IPV6INIT=yes</div><div class="line">IPV6_AUTOCONF=yes</div><div class="line">IPV6_DEFROUTE=yes</div><div class="line">IPV6_PEERDNS=yes</div><div class="line">IPV6_PEERROUTES=yes</div><div class="line">IPV6_FAILURE_FATAL=no</div><div class="line">IPV6_ADDR_GEN_MODE=stable-privacy</div><div class="line">NAME=enp0s8</div><div class="line">UUID=6c930d05-bc17-4316-998e-f01a7233cbd3</div><div class="line">DEVICE=enp0s8</div><div class="line">ONBOOT=yes</div><div class="line">[root@localhost ~]# ifconfig</div><div class="line">enp0s8: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</div><div class="line">        inet 192.168.55.183  netmask 255.255.255.0  broadcast 192.168.55.255</div><div class="line">        inet6 fe80::f97d:539:4010:eaff  prefixlen 64  scopeid 0x20&lt;link&gt;</div><div class="line">        ether 08:00:27:d5:ee:00  txqueuelen 1000  (Ethernet)</div><div class="line">        RX packets 521  bytes 58437 (57.0 KiB)</div><div class="line">        RX errors 0  dropped 0  overruns 0  frame 0</div><div class="line">        TX packets 155  bytes 23680 (23.1 KiB)</div><div class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</div><div class="line">enp0s17: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</div><div class="line">        inet 10.0.2.15  netmask 255.255.255.0  broadcast 10.0.2.255</div><div class="line">        inet6 fe80::a15d:3b87:fec0:f3c1  prefixlen 64  scopeid 0x20&lt;link&gt;</div><div class="line">        ether 08:00:27:28:39:6c  txqueuelen 1000  (Ethernet)</div><div class="line">        RX packets 2  bytes 1180 (1.1 KiB)</div><div class="line">        RX errors 0  dropped 0  overruns 0  frame 0</div><div class="line">        TX packets 10  bytes 1308 (1.2 KiB)</div><div class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</div><div class="line">lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt;  mtu 65536</div><div class="line">        inet 127.0.0.1  netmask 255.0.0.0</div><div class="line">        inet6 ::1  prefixlen 128  scopeid 0x10&lt;host&gt;</div><div class="line">        loop  txqueuelen 1  (Local Loopback)</div><div class="line">        RX packets 0  bytes 0 (0.0 B)</div><div class="line">        RX errors 0  dropped 0  overruns 0  frame 0</div><div class="line">        TX packets 0  bytes 0 (0.0 B)</div><div class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</div><div class="line">```     </div><div class="line">        </div><div class="line"><span class="meta">#</span>### 开启CPU flags(SSE 4.1/SSE 4.2)</div><div class="line"></div><div class="line">```shell</div><div class="line">VBoxManage setextradata "VM name" VBoxInternal/CPUM/SSE4.1 1</div><div class="line">VBoxManage setextradata "VM name" VBoxInternal/CPUM/SSE4.2 1</div></pre></td></tr></table></figure>
</li>
</ul>
<p>Note:</p>
<ul>
<li>上述CPU flags默认是不开启的，启动f-stack上ngx会err日志如下</li>
<li>如果不开启sse cpu选项，在启动ngx会报如下问题<br>/usr/local/nginx_fstack/sbin/nginx /data/f-stack/config.ini -c 1 –proc-type=primary –num-procs=1 –proc-id=0<br>ERROR: This system does not support “SSE4_1”.<br>Please check that RTE_MACHINE is set correctly.</li>
<li>做NAT网卡10.0.2.15需要在vbox上做主机地址和端口映射才能访问<br> <img src="/myimages/vboxaddr.png" alt="wk2"></li>
</ul>
<h3 id="安装详细步骤"><a href="#安装详细步骤" class="headerlink" title="安装详细步骤"></a>安装详细步骤</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line">yum install -y git gcc openssl-devel bc</div><div class="line">cd /data</div><div class="line">yum install kernel-devel-`uname -r` -y</div><div class="line">mkdir /data/f-stack</div><div class="line">git clone https://github.com/F-Stack/f-stack.git /data/f-stack</div><div class="line"><span class="meta"></span></div><div class="line"># Compile DPDK</div><div class="line">cd /data/f-stack/dpdk</div><div class="line">make config T=x86_64-native-linuxapp-gc</div><div class="line">make</div><div class="line"><span class="meta"></span></div><div class="line"># set hugepage    </div><div class="line">echo 1024 &gt; /sys/kernel/mm/hugepages/hugepages-2048kB/nr_hugepages</div><div class="line">mkdir /mnt/huge</div><div class="line">mount -t hugetlbfs nodev /mnt/huge</div><div class="line"><span class="meta"></span></div><div class="line"># insmod ko</div><div class="line">modprobe uio</div><div class="line">insmod build/kmod/igb_uio.ko</div><div class="line">insmod build/kmod/rte_kni.ko</div><div class="line"><span class="meta"></span></div><div class="line"># set ip address</div><div class="line">export myaddr=`ifconfig enp0s17 | grep "inet" | grep -v ":" | awk -F ' '  '&#123;print $2&#125;'`</div><div class="line">export mymask=`ifconfig enp0s17 | grep "netmask" | awk -F ' ' '&#123;print $4&#125;'`</div><div class="line">export mybc=`ifconfig enp0s17 | grep "broadcast" | awk -F ' ' '&#123;print $6&#125;'`</div><div class="line">export myhw=`ifconfig enp0s17 | grep "ether" | awk -F ' ' '&#123;print $2&#125;'`</div><div class="line">export mygw=`route -n | grep 0.0.0.0 | grep enp0s17 | grep UG | awk -F ' ' '&#123;print $2&#125;'`</div><div class="line"></div><div class="line">sed "s/addr=192.168.1.2/addr=$&#123;myaddr&#125;/" -i /data/f-stack/config.ini</div><div class="line">sed "s/netmask=255.255.255.0/netmask=$&#123;mymask&#125;/" -i /data/f-stack/config.ini</div><div class="line">sed "s/broadcast=192.168.1.255/broadcast=$&#123;mybc&#125;/" -i /data/f-stack/config.ini</div><div class="line">sed "s/gateway=192.168.1.1/gateway=$&#123;mygw&#125;/" -i /data/f-stack/config.ini</div><div class="line"><span class="meta"></span></div><div class="line"></div><div class="line"># Compile F-Stack lib</div><div class="line">export FF_PATH=/data/f-stack</div><div class="line">export FF_DPDK=/data/f-stack/dpdk/build</div><div class="line">cd /data/f-stack/lib</div><div class="line">make</div><div class="line"><span class="meta"></span></div><div class="line"># Compile Nginx</div><div class="line">cd ../app/nginx-1.11.10</div><div class="line">./configure --prefix=/usr/local/nginx_fstack --with-ff_module</div><div class="line">make</div><div class="line">make install</div><div class="line"><span class="meta"></span></div><div class="line"># offload NIC（if there is only one NIC，the follow commands must run in a script）</div><div class="line">ifconfig enp0s17 down</div><div class="line">python /data/f-stack/dpdk/tools/dpdk-devbind.py --bind=igb_uio enp0s17</div><div class="line"><span class="meta"></span></div><div class="line"># start Nginx</div><div class="line">cd ../..</div><div class="line">./start.sh -b /usr/local/nginx_fstack/sbin/nginx -c config.ini</div></pre></td></tr></table></figure>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>在vbox主机上访问映射地址和端口192.168.55.165:8080 -&gt; 10.0.2.15:80<br>curl <a href="http://192.168.55.165:8080" target="_blank" rel="external">http://192.168.55.165:8080</a><br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>Welcome to nginx!<span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></div><div class="line">    body &#123;</div><div class="line">        width: 35em;</div><div class="line">        margin: 0 auto;</div><div class="line">        font-family: Tahoma, Verdana, Arial, sans-serif;</div><div class="line">    &#125;</div><div class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Welcome to nginx!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>If you see this page, the nginx web server is successfully installed and</div><div class="line">working. Further configuration is required.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>For online documentation and support please refer to</div><div class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://nginx.org/"</span>&gt;</span>nginx.org<span class="tag">&lt;/<span class="name">a</span>&gt;</span>.<span class="tag">&lt;<span class="name">br</span>/&gt;</span></div><div class="line">Commercial support is available at</div><div class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://nginx.com/"</span>&gt;</span>nginx.com<span class="tag">&lt;/<span class="name">a</span>&gt;</span>.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">em</span>&gt;</span>Thank you for using nginx.<span class="tag">&lt;/<span class="name">em</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure></p>
<h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><h3 id="f-stack-ngx配置文件"><a href="#f-stack-ngx配置文件" class="headerlink" title="f-stack ngx配置文件"></a>f-stack ngx配置文件</h3><p>/data/f-stack/config.ini<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div></pre></td><td class="code"><pre><div class="line">[dpdk]</div><div class="line"><span class="meta">#</span># Hexadecimal bitmask of cores to run on.</div><div class="line">lcore_mask=3</div><div class="line"><span class="meta">#</span># Port mask, enable and disable ports.</div><div class="line"><span class="meta">#</span># Default: all ports are enabled.</div><div class="line"><span class="meta">#</span>port_mask=1</div><div class="line">channel=4</div><div class="line"><span class="meta">#</span># Number of ports.</div><div class="line">nb_ports=1</div><div class="line">promiscuous=1</div><div class="line">numa_on=1</div><div class="line"><span class="meta">#</span># TCP segment offload, default: disabled.</div><div class="line">tso=0</div><div class="line"><span class="meta"></span></div><div class="line">## Port config section</div><div class="line"><span class="meta">#</span># According to dpdk.nb_ports: port0, port1...</div><div class="line">[port0]</div><div class="line">addr=10.0.2.15</div><div class="line">netmask=255.255.255.0</div><div class="line">broadcast=10.0.2.255</div><div class="line">gateway=10.0.2.2</div><div class="line"><span class="meta">#</span># Packet capture path, this will hurt performance</div><div class="line"><span class="meta">#</span>pcap=./a.pcap</div><div class="line"><span class="meta"></span></div><div class="line">## Kni config: if enabled and method=reject,</div><div class="line"><span class="meta">#</span># all packets that do not belong to the following tcp_port and udp_port</div><div class="line"><span class="meta">#</span># will transmit to kernel; if method=accept, all packets that belong to</div><div class="line"><span class="meta">#</span># the following tcp_port and udp_port will transmit to kernel.</div><div class="line"><span class="meta">#</span>[kni]</div><div class="line"><span class="meta">#</span>enable=1</div><div class="line"><span class="meta">#</span>method=reject</div><div class="line"><span class="meta">#</span>tcp_port=80,443</div><div class="line"><span class="meta">#</span>udp_port=53</div><div class="line"><span class="meta"></span></div><div class="line">## FreeBSD network performance tuning configurations.</div><div class="line"><span class="meta">#</span># Most native FreeBSD configurations are supported.</div><div class="line">[freebsd.boot]</div><div class="line">hz=100</div><div class="line"></div><div class="line">kern.ipc.maxsockets=262144</div><div class="line"></div><div class="line">net.inet.tcp.syncache.hashsize=4096</div><div class="line">net.inet.tcp.syncache.bucketlimit=100</div><div class="line"></div><div class="line">net.inet.tcp.tcbhashsize=65536</div><div class="line"></div><div class="line">[freebsd.sysctl]</div><div class="line">kern.ipc.somaxconn=32768</div><div class="line">kern.ipc.maxsockbuf=16777216</div><div class="line"></div><div class="line">net.inet.tcp.fast_finwait2_recycle=1</div><div class="line">net.inet.tcp.sendspace=16384</div><div class="line">net.inet.tcp.recvspace=8192</div><div class="line">net.inet.tcp.nolocaltimewait=1</div><div class="line">net.inet.tcp.cc.algorithm=htcp</div><div class="line">net.inet.tcp.sendbuf_max=16777216</div><div class="line">net.inet.tcp.recvbuf_max=16777216</div><div class="line">net.inet.tcp.sendbuf_auto=1</div><div class="line">net.inet.tcp.recvbuf_auto=1</div><div class="line">net.inet.tcp.sendbuf_inc=16384</div><div class="line">net.inet.tcp.recvbuf_inc=524288</div><div class="line">net.inet.tcp.inflight.enable=0</div><div class="line">net.inet.tcp.sack=1</div><div class="line">net.inet.tcp.blackhole=1</div><div class="line">net.inet.tcp.msl=2000</div><div class="line">net.inet.tcp.delayed_ack=0</div><div class="line"></div><div class="line">net.inet.udp.blackhole=1</div><div class="line">net.inet.ip.redirect=0</div></pre></td></tr></table></figure></p>
<h3 id="f-stack-ngx正常启动信息"><a href="#f-stack-ngx正常启动信息" class="headerlink" title="f-stack ngx正常启动信息"></a>f-stack ngx正常启动信息</h3><p>[root@localhost f-stack]# ./start.sh -b /usr/local/nginx_fstack/sbin/nginx -c config.ini<br>/usr/local/nginx_fstack/sbin/nginx config.ini -c 1 –proc-type=primary –num-procs=1 –proc-id=0</p>
<p>EAL: Detected 1 lcore(s)<br>EAL: Probing VFIO support…<br>EAL: PCI device 0000:00:08.0 on NUMA socket -1<br>EAL:   probe driver: 8086:100f rte_em_pmd<br>EAL: PCI device 0000:00:11.0 on NUMA socket -1<br>EAL:   probe driver: 8086:100f rte_em_pmd<br>create mbuf pool on socket 0<br>create ring:arp_ring_0_0 success, 2047 ring entries are now free!<br>Port 0 MAC: 08 00 27 28 39 6c<br>TSO is disabled<br>set port 0 to promiscuous mode ok</p>
<p>Checking link status………………..done<br>Port 0 Link Up - speed 1000 Mbps - full-duplex<br>link_elf_lookup_symbol: missing symbol hash table<br>link_elf_lookup_symbol: missing symbol hash table<br>netisr_init: forcing maxthreads from 1 to 0<br>Timecounters tick every 10.000 msec<br>Timecounter “ff_clock” frequency 100 Hz quality 1<br>f-stack-0: Ethernet address: 08:00:27:28:39:6c</p>
<h3 id="f-stack-环境安装完成后重启后应该重新设置的参数"><a href="#f-stack-环境安装完成后重启后应该重新设置的参数" class="headerlink" title="f-stack 环境安装完成后重启后应该重新设置的参数"></a>f-stack 环境安装完成后重启后应该重新设置的参数</h3><p>下述命令可放入/etc/rd.c/rd.local启动文件中，在机器重启后执行一次下面环境设置<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">echo 1024 &gt; /sys/kernel/mm/hugepages/hugepages-2048kB/nr_hugepages</div><div class="line">mount -t hugetlbfs nodev /mnt/huge</div><div class="line">modprobe uio</div><div class="line">insmod /data/f-stack/dpdk/build/kmod/igb_uio.ko</div><div class="line">insmod /data/f-stack/dpdk/build/kmod/rte_kni.ko</div><div class="line">ifconfig enp0s17 down</div><div class="line">python /data/f-stack/dpdk/tools/dpdk-devbind.py --bind=igb_uio enp0s17</div><div class="line">/data/f-stack/start.sh -b /usr/local/nginx_fstack/sbin/nginx -c /data/f-stack/config.ini</div></pre></td></tr></table></figure></p>
<h3 id="如果kernel-devel-yum无法找到内核对应版本可去centos官网查找下载"><a href="#如果kernel-devel-yum无法找到内核对应版本可去centos官网查找下载" class="headerlink" title="如果kernel-devel yum无法找到内核对应版本可去centos官网查找下载"></a>如果kernel-devel yum无法找到内核对应版本可去centos官网查找下载</h3><p>wget <a href="https://buildlogs.centos.org/c7.1511.00/kernel/20151119220809/3.10.0-327.el7.x86_64/kernel-devel-3.10.0-327.el7.x86_64.rpm" target="_blank" rel="external">https://buildlogs.centos.org/c7.1511.00/kernel/20151119220809/3.10.0-327.el7.x86_64/kernel-devel-3.10.0-327.el7.x86_64.rpm</a><br>rpm -ivh kernel-devel-3.10.0-327.el7.x86_64.rpm</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;mac-os-virtual-box跑f-stack环境搭建&quot;&gt;&lt;a href=&quot;#mac-os-virtual-box跑f-stack环境搭建&quot; class=&quot;headerlink&quot; title=&quot;mac os virtual box跑f-stack环境搭建&quot;&gt;&lt;/a&gt;mac os virtual box跑f-stack环境搭建&lt;/h1&gt;&lt;h2 id=&quot;基本环境&quot;&gt;&lt;a href=&quot;#基本环境&quot; class=&quot;headerlink&quot; title=&quot;基本环境&quot;&gt;&lt;/a&gt;基本环境&lt;/h2&gt;&lt;p&gt;kernel版本3.10.0-514.el7.x86_64&lt;br&gt;CentOS-7-x86_64-Minimal-1611.iso&lt;br&gt;Mac osx&lt;br&gt;Oreacle Virtual Box5.1.22&lt;br&gt;kernel-devel&lt;/p&gt;
&lt;h2 id=&quot;操作步骤&quot;&gt;&lt;a href=&quot;#操作步骤&quot; class=&quot;headerlink&quot; title=&quot;操作步骤&quot;&gt;&lt;/a&gt;操作步骤&lt;/h2&gt;&lt;h3 id=&quot;在Oreacle-Virtual-Box上安装centos-7虚拟机&quot;&gt;&lt;a href=&quot;#在Oreacle-Virtual-Box上安装centos-7虚拟机&quot; class=&quot;headerlink&quot; title=&quot;在Oreacle Virtual Box上安装centos 7虚拟机&quot;&gt;&lt;/a&gt;在Oreacle Virtual Box上安装centos 7虚拟机&lt;/h3&gt;&lt;h4 id=&quot;配置开启NAT网卡和桥接网卡&quot;&gt;&lt;a href=&quot;#配置开启NAT网卡和桥接网卡&quot; class=&quot;headerlink&quot; title=&quot;配置开启NAT网卡和桥接网卡&quot;&gt;&lt;/a&gt;配置开启NAT网卡和桥接网卡&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;网卡配置芯片类型选择&lt;br&gt;Add two more virtual network adapters with “Intel PRO/1000 MT Server (82545EM)” type in order to provide virtual network hardware to the virtual machine that is supported by Intel DPDK.&lt;br&gt;  上述说明来自于一篇国外文档说明，使用的Inetl 82545EM，但是经过尝试Intel PRO/1000MT桌面(82540EN)也是可以的。所以不要太迷信啦。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="DPDK" scheme="https://vcpu.github.io/categories/DPDK/"/>
    
    
      <category term="DPDK" scheme="https://vcpu.github.io/tags/DPDK/"/>
    
      <category term="f-stack" scheme="https://vcpu.github.io/tags/f-stack/"/>
    
      <category term="nginx" scheme="https://vcpu.github.io/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>centos环境下脚本执行顺序探究</title>
    <link href="https://vcpu.github.io/centos%E8%84%9A%E6%9C%AC%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/"/>
    <id>https://vcpu.github.io/centos脚本执行顺序/</id>
    <published>2017-06-15T07:42:10.000Z</published>
    <updated>2017-06-15T07:42:10.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="centos脚本执行顺序"><a href="#centos脚本执行顺序" class="headerlink" title="centos脚本执行顺序"></a>centos脚本执行顺序</h1><p>通用角度分析，centos 7 系统中存在如下以下5种常用的脚本路径<br>/etc/rc.d/rc.local<br>/etc/profile<br>/etc/bashrc<br>~/.bash_profile<br>~/.bashrc</p>
<p>通过在除rc外的脚本中加入echo信息，reboot虚拟机并ssh登陆用户，打印出顺序如下<br>I am etc profile<br>i am etc bashrc<br>i am ~ bash rc<br>i am ~ bash profile</p>
<a id="more"></a>
<h2 id="脚本执行顺序和执行时机"><a href="#脚本执行顺序和执行时机" class="headerlink" title="脚本执行顺序和执行时机"></a>脚本执行顺序和执行时机</h2><table>
<thead>
<tr>
<th>脚本路径</th>
<th style="text-align:center">执行顺序</th>
<th style="text-align:right">执行时机</th>
</tr>
</thead>
<tbody>
<tr>
<td>/etc/rc.d/rc.local</td>
<td style="text-align:center">1</td>
<td style="text-align:right">系统起机执行一次，后续均不执行</td>
</tr>
<tr>
<td>/etc/profile</td>
<td style="text-align:center">2</td>
<td style="text-align:right">ssh/su/界面登陆时执行</td>
</tr>
<tr>
<td>/etc/bashrc</td>
<td style="text-align:center">3</td>
<td style="text-align:right">ssh/su/界面登陆时执行</td>
</tr>
<tr>
<td>~/.bash_profile</td>
<td style="text-align:center">4</td>
<td style="text-align:right">ssh/su/界面登陆以当前用户身份登陆</td>
</tr>
<tr>
<td>~/.bashrc</td>
<td style="text-align:center">5</td>
<td style="text-align:right">ssh/su/界面登陆以当前用户身份登陆</td>
</tr>
</tbody>
</table>
<h2 id="脚本含义"><a href="#脚本含义" class="headerlink" title="脚本含义"></a>脚本含义</h2><p>rc.local脚本centos启动时候执行脚本，可以用作默认启动<br>/etc/profile和/etc/bashrc 属于系统的全局变量设置<br>~/profile和~/bashrc 属于给予某一个用户的变量设置</p>
<h2 id="profile和bashrc区别"><a href="#profile和bashrc区别" class="headerlink" title="profile和bashrc区别"></a>profile和bashrc区别</h2><ul>
<li>profile 是用户唯一用来设置环境变量的地方，因为用户可能有多种shell（bash、sh、zsh），环境变量没有必要在每种shell都初始化，只需要统一初始化就行，很显然，profile就是这样的地方</li>
<li>bashrc 是专门给bash做初始化设置的，相对应来讲，其它shell会有专门的shrc、zshrc文件存放</li>
</ul>
<h2 id="开机启动脚本其它说明"><a href="#开机启动脚本其它说明" class="headerlink" title="开机启动脚本其它说明"></a>开机启动脚本其它说明</h2><p>centos7 默认是没有执行权限的，想在此处加执行脚本，执行脚本不会执行到，需要增添执行权限</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">[root@localhost rc.d]# ls -alt rc.local</div><div class="line">-rw-r--r--. 1 root root 491 Jun 13 22:24 rc.local</div><div class="line">[root@localhost rc.d]# chmod +x rc.local</div><div class="line"></div><div class="line">[root@localhost qinlong]# ls -alt /etc/rc.d/rc.local</div><div class="line">-rwxr-xr-x. 1 root root 535 Jun 13 22:48 /etc/rc.d/rc.local</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;centos脚本执行顺序&quot;&gt;&lt;a href=&quot;#centos脚本执行顺序&quot; class=&quot;headerlink&quot; title=&quot;centos脚本执行顺序&quot;&gt;&lt;/a&gt;centos脚本执行顺序&lt;/h1&gt;&lt;p&gt;通用角度分析，centos 7 系统中存在如下以下5种常用的脚本路径&lt;br&gt;/etc/rc.d/rc.local&lt;br&gt;/etc/profile&lt;br&gt;/etc/bashrc&lt;br&gt;~/.bash_profile&lt;br&gt;~/.bashrc&lt;/p&gt;
&lt;p&gt;通过在除rc外的脚本中加入echo信息，reboot虚拟机并ssh登陆用户，打印出顺序如下&lt;br&gt;I am etc profile&lt;br&gt;i am etc bashrc&lt;br&gt;i am ~ bash rc&lt;br&gt;i am ~ bash profile&lt;/p&gt;
    
    </summary>
    
      <category term="centos" scheme="https://vcpu.github.io/categories/centos/"/>
    
    
      <category term="linux" scheme="https://vcpu.github.io/tags/linux/"/>
    
      <category term="centos" scheme="https://vcpu.github.io/tags/centos/"/>
    
  </entry>
  
  <entry>
    <title>TIME_WAIT状态分析</title>
    <link href="https://vcpu.github.io/TIME_WAIT%E7%8A%B6%E6%80%81%E5%88%86%E6%9E%90/"/>
    <id>https://vcpu.github.io/TIME_WAIT状态分析/</id>
    <published>2017-06-12T10:19:10.000Z</published>
    <updated>2017-06-12T10:19:10.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="TIME-WAIT状态分析"><a href="#TIME-WAIT状态分析" class="headerlink" title="TIME_WAIT状态分析"></a>TIME_WAIT状态分析</h1><p>之所以起这样一个题目是因为很久以前我曾经写过一篇介绍TIME_WAIT的文章，不过当时基本属于浅尝辄止，并没深入说明问题的来龙去脉，碰巧这段时间反复被别人问到相关的问题，让我觉得有必要全面总结一下，以备不时之需。</p>
<p>讨论前大家可以拿手头的服务器摸摸底，记住「ss」比「netstat」快：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ss -ant | awk 'NR&gt;1 &#123;++s[$1]&#125; END &#123;for(k in s) print k,s[k]&#125;</div></pre></td></tr></table></figure></p>
<p>更简单方法：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cat /proc/net/sockstat</div></pre></td></tr></table></figure>
<a id="more"></a>
<p>我猜你一定被巨大无比的TIME_WAIT网络连接总数吓到了！以我个人的经验，对于一台繁忙的Web服务器来说，如果主要以短连接为主，那么其TIME_WAIT网络连接总数很可能会达到几万，甚至十几万。虽然一个TIME_WAIT网络连接耗费的资源无非就是一个端口、一点内存，但是架不住基数大，所以这始终是一个需要面对的问题。</p>
<h2 id="TIMEWAIT是什么"><a href="#TIMEWAIT是什么" class="headerlink" title="TIMEWAIT是什么"></a>TIMEWAIT是什么</h2><p>因为TCP连接是双向的，所以在关闭连接的时候，两个方向各自都需要关闭。先发FIN包的一方执行的是主动关闭；后发FIN包的一方执行的是被动关闭。主动关闭的一方会进入TIME_WAIT状态，并且在此状态停留两倍的MSL时长。<br>穿插一点MSL的知识：MSL指的是报文段的最大生存时间，如果报文段在网络活动了MSL时间，还没有被接收，那么会被丢弃。关于MSL的大小，RFC 793协议中给出的建议是两分钟，不过实际上不同的操作系统可能有不同的设置，以Linux为例，通常是半分钟，两倍的MSL就是一分钟，也就是60秒，并且这个数值是硬编码在内核中的，也就是说除非你重新编译内核，否则没法修改它：</p>
<pre><code>#define TCP_TIMEWAIT_LEN (60*HZ)
</code></pre><p>如果每秒的连接数是一千的话，那么一分钟就可能会产生六万个TIME_WAIT。<br>为什么主动关闭的一方不直接进入CLOSED状态，而是进入TIME_WAIT状态，并且停留两倍的MSL时长呢？这是因为TCP是建立在不可靠网络上的可靠的协议。例子：主动关闭的一方收到被动关闭的一方发出的FIN包后，回应ACK包，同时进入TIME_WAIT状态，但是因为网络原因，主动关闭的一方发送的这个ACK包很可能延迟，从而触发被动连接一方重传FIN包。极端情况下，这一去一回，就是两倍的MSL时长。如果主动关闭的一方跳过TIME_WAIT直接进入CLOSED，或者在TIME_WAIT停留的时长不足两倍的MSL，那么当被动关闭的一方早先发出的延迟包到达后，就可能出现类似下面的问题：<br>    ▪    旧的TCP连接已经不存在了，系统此时只能返回RST包<br>    ▪    新的TCP连接被建立起来了，延迟包可能干扰新的连接<br>不管是哪种情况都会让TCP不再可靠，所以TIME_WAIT状态有存在的必要性。</p>
<h2 id="如何控制TIME-WAIT的数量？"><a href="#如何控制TIME-WAIT的数量？" class="headerlink" title="如何控制TIME_WAIT的数量？"></a>如何控制TIME_WAIT的数量？</h2><p>从前面的描述我们可以得出这样的结论：TIME_WAIT这东西没有的话不行，不过太多可能也是个麻烦事。下面让我们看看有哪些方法可以控制TIME_WAIT数量，这里只说一些常规方法，另外一些诸如SO_LINGER之类的方法太过偏门，略过不谈。<br>ip_conntrack：顾名思义就是跟踪连接。一旦激活了此模块，就能在系统参数里发现很多用来控制网络连接状态超时的设置，其中自然也包括TIME_WAIT：<br>shell&gt; modprobe ip_conntrack<br>shell&gt; sysctl net.ipv4.netfilter.ip_conntrack_tcp_timeout_time_wait<br>我们可以尝试缩小它的设置，比如十秒，甚至一秒，具体设置成多少合适取决于网络情况而定，当然也可以参考相关的案例。不过就我的个人意见来说，ip_conntrack引入的问题比解决的还多，比如性能会大幅下降，所以不建议使用。</p>
<h3 id="tcp-tw-recycle："><a href="#tcp-tw-recycle：" class="headerlink" title="tcp_tw_recycle："></a>tcp_tw_recycle：</h3><p>顾名思义就是回收TIME_WAIT连接。可以说这个内核参数已经变成了大众处理TIME_WAIT的万金油，如果你在网络上搜索TIME_WAIT的解决方案，十有八九会推荐设置它，不过这里隐藏着一个不易察觉的陷阱：<br>当多个客户端通过NAT方式联网并与服务端交互时，服务端看到的是同一个IP，也就是说对服务端而言这些客户端实际上等同于一个，可惜由于这些客户端的时间戳可能存在差异，于是乎从服务端的视角看，便可能出现时间戳错乱的现象，进而直接导致时间戳小的数据包被丢弃。（tcp_tw_recycle和tcp_timestamps导致connect失败问题。同时开启情况下，60s内同一源ip主机socket 请求中timestamp必须是递增的）</p>
<h3 id="tcp-tw-reuse："><a href="#tcp-tw-reuse：" class="headerlink" title="tcp_tw_reuse："></a>tcp_tw_reuse：</h3><p>顾名思义就是复用TIME_WAIT连接。当创建新连接的时候，如果可能的话会考虑复用相应的TIME_WAIT连接。通常认为「tcp_tw_reuse」比「tcp_tw_recycle」安全一些，这是因为一来TIME_WAIT创建时间必须超过一秒才可能会被复用；二来只有连接的时间戳是递增的时候才会被复用。官方文档里是这样说的：如果从协议视角看它是安全的，那么就可以使用。这简直就是外交辞令啊！按我的看法，如果网络比较稳定，比如都是内网连接，那么就可以尝试使用。<br>不过需要注意的是在哪里使用，既然我们要复用连接，那么当然应该在连接的发起方使用，而不能在被连接方使用。举例来说：客户端向服务端发起HTTP请求，服务端响应后主动关闭连接，于是TIME_WAIT便留在了服务端，此类情况使用「tcp_tw_reuse」是无效的，因为服务端是被连接方，所以不存在复用连接一说。让我们延伸一点来看，比如说服务端是PHP，它查询另一个MySQL服务端，然后主动断开连接，于是TIME_WAIT就落在了PHP一侧，此类情况下使用「tcp_tw_reuse」是有效的，因为此时PHP相对于MySQL而言是客户端，它是连接的发起方，所以可以复用连接。<br>说明：如果使用tcp_tw_reuse，请激活tcp_timestamps，否则无效。</p>
<h3 id="tcp-max-tw-buckets："><a href="#tcp-max-tw-buckets：" class="headerlink" title="tcp_max_tw_buckets："></a>tcp_max_tw_buckets：</h3><p>顾名思义就是控制TIME_WAIT总数。官网文档说这个选项只是为了阻止一些简单的DoS攻击，平常不要人为的降低它。如果缩小了它，那么系统会将多余的TIME_WAIT删除掉，日志里会显示：「TCP: time wait bucket table overflow」。<br>需要提醒大家的是物极必反，曾经看到有人把「tcp_max_tw_buckets」设置成0，也就是说完全抛弃TIME_WAIT，这就有些冒险了，用一句围棋谚语来说：入界宜缓。<br>…<br>有时候，如果我们换个角度去看问题，往往能得到四两拨千斤的效果。前面提到的例子：客户端向服务端发起HTTP请求，服务端响应后主动关闭连接，于是TIME_WAIT便留在了服务端。这里的关键在于主动关闭连接的是服务端！在关闭TCP连接的时候，先出手的一方注定逃不开TIME_WAIT的宿命，套用一句歌词：把我的悲伤留给自己，你的美丽让你带走。如果客户端可控的话，那么在服务端打开KeepAlive，尽可能不让服务端主动关闭连接，而让客户端主动关闭连接，如此一来问题便迎刃而解了。</p>
<p>原文连接于<a href="https://huoding.com/2013/12/31/316" target="_blank" rel="external">https://huoding.com/2013/12/31/316</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;TIME-WAIT状态分析&quot;&gt;&lt;a href=&quot;#TIME-WAIT状态分析&quot; class=&quot;headerlink&quot; title=&quot;TIME_WAIT状态分析&quot;&gt;&lt;/a&gt;TIME_WAIT状态分析&lt;/h1&gt;&lt;p&gt;之所以起这样一个题目是因为很久以前我曾经写过一篇介绍TIME_WAIT的文章，不过当时基本属于浅尝辄止，并没深入说明问题的来龙去脉，碰巧这段时间反复被别人问到相关的问题，让我觉得有必要全面总结一下，以备不时之需。&lt;/p&gt;
&lt;p&gt;讨论前大家可以拿手头的服务器摸摸底，记住「ss」比「netstat」快：&lt;br&gt;&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;ss -ant | awk &#39;NR&amp;gt;1 &amp;#123;++s[$1]&amp;#125; END &amp;#123;for(k in s) print k,s[k]&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;更简单方法：&lt;/p&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;cat /proc/net/sockstat&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="TCP" scheme="https://vcpu.github.io/categories/TCP/"/>
    
    
      <category term="tcp/ip" scheme="https://vcpu.github.io/tags/tcp-ip/"/>
    
  </entry>
  
  <entry>
    <title>bind()实现源码分析</title>
    <link href="https://vcpu.github.io/bind/"/>
    <id>https://vcpu.github.io/bind/</id>
    <published>2017-06-12T09:35:01.000Z</published>
    <updated>2017-06-12T09:35:01.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="bind"><a href="#bind" class="headerlink" title="bind()"></a>bind()</h1><p>内核版本：3.10.0-514.16.1.el7.x86_64<br>下述源码分析均以tcp socket为背景</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">bind</span><span class="params">(<span class="keyword">int</span> sockfd, struct sockaddr *my_addr, <span class="keyword">socklen_t</span> addrlen)</span></span>;</div></pre></td></tr></table></figure>
<ul>
<li>socket文件描述符</li>
<li>要绑定的承载地址和端口的结构体 struct sockaddr</li>
<li>第二个参数struct sockaddr的长度</li>
</ul>
<blockquote>
<p>该函数负责绑定套接字的地址和端口，按照绑定者身份来分，会存在两种情况</p>
<blockquote>
<p>情况1:绑定者为客户端，主动发起请求方，绑定地址和端口成功后，会使用该地址和端口进行发包<br>一般情况下，客户端的地址和端口都是其自动选择的，不需要绑定动作。<br>情况2:绑定者为服务端，被动连接接收方，绑定地址和端口成功后，客户端只能向该地址和端口发送连接请求。服务端往往需要绑定地址和端口。如果服务端存在多网卡情况，其只需要绑定服务端口即可，其目的地址就是客户端访问的目的地址。<br><a id="more"></a></p>
</blockquote>
</blockquote>
<h2 id="sys-bind"><a href="#sys-bind" class="headerlink" title="sys_bind"></a>sys_bind</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">SYSCALL_DEFINE3(bind, <span class="keyword">int</span>, fd, struct sockaddr __user *, umyaddr, <span class="keyword">int</span>, addrlen)</div><div class="line">&#123;</div><div class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">socket</span> *<span class="title">sock</span>;</span></div><div class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_storage</span> <span class="title">address</span>;</span></div><div class="line">	<span class="keyword">int</span> err, fput_needed;</div><div class="line"></div><div class="line">	sock = sockfd_lookup_light(fd, &amp;err, &amp;fput_needed);</div><div class="line">	<span class="keyword">if</span> (sock) &#123;</div><div class="line">		err = move_addr_to_kernel(umyaddr, addrlen, &amp;address);</div><div class="line">		<span class="keyword">if</span> (err &gt;= <span class="number">0</span>) &#123;</div><div class="line">			err = security_socket_bind(sock,</div><div class="line">						   (struct sockaddr *)&amp;address,</div><div class="line">						   addrlen);</div><div class="line">			<span class="keyword">if</span> (!err)</div><div class="line">				err = sock-&gt;ops-&gt;bind(sock,</div><div class="line">						      (struct sockaddr *)</div><div class="line">						      &amp;address, addrlen);<span class="comment">//inet_bind</span></div><div class="line">		&#125;</div><div class="line">		fput_light(sock-&gt;file, fput_needed);</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> err;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>sockfd_lookup_light 和move_addr_to_kernel分别为根据fd从当前进程取出socket和把参数从用户空间考入地址空间</li>
<li>bind系统调用最重要函数为sock-&gt;ops-&gt;bind</li>
<li>在TCP协议情况下inet_stream_ops中bind成员函数为inet_bind</li>
<li>后续为对此函数的分析</li>
</ul>
<h2 id="inet-bind"><a href="#inet-bind" class="headerlink" title="inet_bind"></a>inet_bind</h2><p>实现较为复杂，现在版本和原始版本相比，支持端口复用了<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">inet_bind</span><span class="params">(struct socket *sock, struct sockaddr *uaddr, <span class="keyword">int</span> addr_len)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> *<span class="title">addr</span> = (<span class="title">struct</span> <span class="title">sockaddr_in</span> *)<span class="title">uaddr</span>;</span></div><div class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *<span class="title">sk</span> = <span class="title">sock</span>-&gt;<span class="title">sk</span>;</span></div><div class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inet_sock</span> *<span class="title">inet</span> = <span class="title">inet_sk</span>(<span class="title">sk</span>);</span></div><div class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">net</span> *<span class="title">net</span> = <span class="title">sock_net</span>(<span class="title">sk</span>);</span></div><div class="line">	<span class="keyword">unsigned</span> <span class="keyword">short</span> snum;</div><div class="line">	<span class="keyword">int</span> chk_addr_ret;</div><div class="line">	<span class="keyword">int</span> err;</div><div class="line"></div><div class="line">	<span class="comment">/* If the socket has its own bind function then use it. (RAW) */</span></div><div class="line">	<span class="comment">/*raw socket才会用到，tcp_proc无此函数*/</span></div><div class="line">	<span class="keyword">if</span> (sk-&gt;sk_prot-&gt;bind) &#123;</div><div class="line">		err = sk-&gt;sk_prot-&gt;bind(sk, uaddr, addr_len);</div><div class="line">		<span class="keyword">goto</span> out;</div><div class="line">	&#125;</div><div class="line">	err = -EINVAL;</div><div class="line">	<span class="comment">/*地址长度检验*/</span></div><div class="line">	<span class="keyword">if</span> (addr_len &lt; <span class="keyword">sizeof</span>(struct sockaddr_in))</div><div class="line">		<span class="keyword">goto</span> out;</div><div class="line"></div><div class="line">	<span class="comment">/*bind地址中协议检查，必须是下面两种情况</span></div><div class="line">	* 1.绑定的地址协议为AF_INET</div><div class="line">	* 2.绑定协议为0（AF_UNSPEC）同时地址也为0</div><div class="line">	* 否则直接退出inet_bind ,返回地址不支持错误码</div><div class="line">	*/</div><div class="line">	<span class="keyword">if</span> (addr-&gt;sin_family != AF_INET) &#123;</div><div class="line">		<span class="comment">/* Compatibility games : accept AF_UNSPEC (mapped to AF_INET)</span></div><div class="line">		 * only if s_addr is INADDR_ANY.</div><div class="line">		 */</div><div class="line">		err = -EAFNOSUPPORT;</div><div class="line">		<span class="keyword">if</span> (addr-&gt;sin_family != AF_UNSPEC ||</div><div class="line">		    addr-&gt;sin_addr.s_addr != htonl(INADDR_ANY))</div><div class="line">			<span class="keyword">goto</span> out;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">/*获取根据IP地址得出地址类型</span></div><div class="line">		RTN_LOCAL 本机地址</div><div class="line">		RTN_MULTICAST 多播</div><div class="line">		RTN_BROADCAST 广播</div><div class="line">		RTN_UNICAST</div><div class="line">	*/</div><div class="line">	chk_addr_ret = inet_addr_type(net, addr-&gt;sin_addr.s_addr);</div><div class="line"></div><div class="line">	<span class="comment">/* Not specified by any standard per-se, however it breaks too</span></div><div class="line">	 * many applications when removed.  It is unfortunate since</div><div class="line">	 * allowing applications to make a non-local bind solves</div><div class="line">	 * several problems with systems using dynamic addressing.</div><div class="line">	 * (ie. your servers still start up even if your ISDN link</div><div class="line">	 *  is temporarily down)</div><div class="line">	 */</div><div class="line">	err = -EADDRNOTAVAIL;</div><div class="line">   <span class="comment">/*	 地址类型必须是本机，多播，组播中的一个，否则直接返回，报地址参数异常</span></div><div class="line">	 * </div><div class="line">	 */</div><div class="line">	<span class="keyword">if</span> (!net-&gt;ipv4_sysctl_ip_nonlocal_bind &amp;&amp;</div><div class="line">	    !(inet-&gt;freebind || inet-&gt;transparent) &amp;&amp;</div><div class="line">	    addr-&gt;sin_addr.s_addr != htonl(INADDR_ANY) &amp;&amp;</div><div class="line">	    chk_addr_ret != RTN_LOCAL &amp;&amp;</div><div class="line">	    chk_addr_ret != RTN_MULTICAST &amp;&amp;</div><div class="line">	    chk_addr_ret != RTN_BROADCAST)</div><div class="line">		<span class="keyword">goto</span> out;</div><div class="line"></div><div class="line">	snum = ntohs(addr-&gt;sin_port);</div><div class="line">	err = -EACCES;</div><div class="line">	<span class="comment">/*</span></div><div class="line">	* 要绑定的端口小于1024时候，要求运行该应用程序的为超级权限</div><div class="line">	* 否则返回并报权限不运行的错误</div><div class="line">	*/</div><div class="line">	<span class="keyword">if</span> (snum &amp;&amp; snum &lt; PROT_SOCK &amp;&amp;</div><div class="line">	    !ns_capable(net-&gt;user_ns, CAP_NET_BIND_SERVICE))</div><div class="line">		<span class="keyword">goto</span> out;</div><div class="line"></div><div class="line">	<span class="comment">/*      We keep a pair of addresses. rcv_saddr is the one</span></div><div class="line">	 *      used by hash lookups, and saddr is used for transmit.</div><div class="line">	 *</div><div class="line">	 *      In the BSD API these are the same except where it</div><div class="line">	 *      would be illegal to use them (multicast/broadcast) in</div><div class="line">	 *      which case the sending device address is used.</div><div class="line">	 */</div><div class="line">	lock_sock(sk);</div><div class="line"></div><div class="line">	<span class="comment">/* Check these errors (active socket, double bind). */</span></div><div class="line">	err = -EINVAL;</div><div class="line">	<span class="comment">/*bind动作发生在最初状态，其TCP状态是CLOSE且没有绑定过</span></div><div class="line">	*	否则直接判别为异常</div><div class="line">	*/</div><div class="line">	<span class="keyword">if</span> (sk-&gt;sk_state != TCP_CLOSE || inet-&gt;inet_num)</div><div class="line">		<span class="keyword">goto</span> out_release_sock;</div><div class="line">	<span class="comment">/*inet_rcv_saddr 用作hash表查找使用</span></div><div class="line">	*inet_saddr作为发包源地址</div><div class="line">	*当为广播和组播时候发送地址为0</div><div class="line">	*/</div><div class="line">	inet-&gt;inet_rcv_saddr = inet-&gt;inet_saddr = addr-&gt;sin_addr.s_addr;</div><div class="line">	<span class="keyword">if</span> (chk_addr_ret == RTN_MULTICAST || chk_addr_ret == RTN_BROADCAST)</div><div class="line">		inet-&gt;inet_saddr = <span class="number">0</span>;  <span class="comment">/* Use device */</span></div><div class="line"></div><div class="line">	<span class="comment">/* Make sure we are allowed to bind here. */</span></div><div class="line">	<span class="comment">/* TCP时候该函数负责查询该端口是否被使用，没有被使用返回0，否则返回非0</span></div><div class="line">	*如果已经被使用，则退出bind函数，并返回地址和端口已经被使用错误-EADDRINUSE</div><div class="line">	*sk-&gt;sk_prot-&gt;get_port= inet_csk_get_port</div><div class="line">	*/</div><div class="line">	<span class="keyword">if</span> (sk-&gt;sk_prot-&gt;get_port(sk, snum)) &#123;</div><div class="line">		inet-&gt;inet_saddr = inet-&gt;inet_rcv_saddr = <span class="number">0</span>;</div><div class="line">		err = -EADDRINUSE;</div><div class="line">		<span class="keyword">goto</span> out_release_sock;</div><div class="line">	&#125;</div><div class="line">	<span class="comment">/*</span></div><div class="line">	* 更新sk-&gt;sk_userlocks标记，表明本地地址和端口已经绑定</div><div class="line">	*/</div><div class="line">	<span class="keyword">if</span> (inet-&gt;inet_rcv_saddr)</div><div class="line">		sk-&gt;sk_userlocks |= SOCK_BINDADDR_LOCK;</div><div class="line">	<span class="keyword">if</span> (snum)</div><div class="line">		sk-&gt;sk_userlocks |= SOCK_BINDPORT_LOCK;</div><div class="line">	inet-&gt;inet_sport = htons(inet-&gt;inet_num);</div><div class="line">	inet-&gt;inet_daddr = <span class="number">0</span>;</div><div class="line">	inet-&gt;inet_dport = <span class="number">0</span>;</div><div class="line">	sk_dst_reset(sk);</div><div class="line">	err = <span class="number">0</span>;</div><div class="line">out_release_sock:</div><div class="line">	release_sock(sk);</div><div class="line">out:</div><div class="line">	<span class="keyword">return</span> err;</div><div class="line">&#125;</div><div class="line">EXPORT_SYMBOL(inet_bind);</div></pre></td></tr></table></figure></p>
<ul>
<li>绑定地址长度和协议检查 长度异常返回-EINVAL 表示参数异常，协议不支持 -EAFNOSUPPORT</li>
<li>对绑定地址进行类型检查inet_addr_type，必须是本机地址，组播和广播地址类型 -EADDRNOTAVAIL 否则报地址参数异常</li>
<li>如果端口小于1024 ，必须为超级权限ns_capable 否则 err = -EACCES 权限不允许</li>
<li>sk-&gt;sk_prot-&gt;get_port = inet_csk_get_port 四层端口检查，看是否被使用</li>
<li>更新sk-&gt;skuserlocks标记，代表地址和端口已经被绑定</li>
</ul>
<p>扩展函数：<br>   inet_csk_get_port TCP四层端口检查<br>   inet_addr_type    地址类型判别<br>   ns_capable        超级权限检查</p>
<h2 id="inet-csk-get-port"><a href="#inet-csk-get-port" class="headerlink" title="inet_csk_get_port"></a>inet_csk_get_port</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">inet_csk_get_port</span><span class="params">(struct sock *sk, <span class="keyword">unsigned</span> <span class="keyword">short</span> snum)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inet_hashinfo</span> *<span class="title">hashinfo</span> = <span class="title">sk</span>-&gt;<span class="title">sk_prot</span>-&gt;<span class="title">h</span>.<span class="title">hashinfo</span>;</span></div><div class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inet_bind_hashbucket</span> *<span class="title">head</span>;</span></div><div class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inet_bind_bucket</span> *<span class="title">tb</span>;</span></div><div class="line">	<span class="keyword">int</span> ret, attempts = <span class="number">5</span>;</div><div class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">net</span> *<span class="title">net</span> = <span class="title">sock_net</span>(<span class="title">sk</span>);</span></div><div class="line">	<span class="keyword">int</span> smallest_size = <span class="number">-1</span>, smallest_rover;</div><div class="line">	<span class="keyword">kuid_t</span> uid = sock_i_uid(sk);</div><div class="line">	<span class="keyword">int</span> attempt_half = (sk-&gt;sk_reuse == SK_CAN_REUSE) ? <span class="number">1</span> : <span class="number">0</span>;</div><div class="line"></div><div class="line">	<span class="comment">/*禁止上下半部，防止进程冲突*/</span></div><div class="line">	local_bh_disable();</div><div class="line">	<span class="comment">/*</span></div><div class="line">	* 如果没有bind端口</div><div class="line">	*/</div><div class="line">	<span class="keyword">if</span> (!snum) &#123;<span class="comment">/*没有指定端口会自动选择端口*/</span></div><div class="line">		<span class="keyword">int</span> remaining, rover, low, high;</div><div class="line"></div><div class="line">again:</div><div class="line">		<span class="comment">/*获取端口的取值范围*/</span></div><div class="line">		inet_get_local_port_range(net, &amp;low, &amp;high);<span class="comment">/*后文辉对其进行分析*/</span></div><div class="line">		<span class="keyword">if</span> (attempt_half) &#123;</div><div class="line">			<span class="keyword">int</span> half = low + ((high - low) &gt;&gt; <span class="number">1</span>);</div><div class="line"></div><div class="line">			<span class="keyword">if</span> (attempt_half == <span class="number">1</span>)</div><div class="line">				high = half;</div><div class="line">			<span class="keyword">else</span></div><div class="line">				low = half;</div><div class="line">		&#125;</div><div class="line">		<span class="comment">/*取值范围内端口数*/</span></div><div class="line">		remaining = (high - low) + <span class="number">1</span>;</div><div class="line">		<span class="comment">/*随机选择端口*/</span></div><div class="line">		smallest_rover = rover = net_random() % remaining + low;</div><div class="line"></div><div class="line">		smallest_size = <span class="number">-1</span>;</div><div class="line">		<span class="keyword">do</span> &#123;</div><div class="line">			<span class="comment">/*保留端口检查,服务端可以设置 /proc/sys/net/ipv4/ip_local_reserved_ports */</span></div><div class="line">			<span class="keyword">if</span> (inet_is_reserved_local_port(rover))</div><div class="line">				<span class="keyword">goto</span> next_nolock;<span class="comment">/*端口加1继续*/</span></div><div class="line">				</div><div class="line">			<span class="comment">/*根据端口号和HASHsize从确定hash桶，并锁住它，后续便利查找*/</span></div><div class="line">			head = &amp;hashinfo-&gt;bhash[inet_bhashfn(net, rover,</div><div class="line">					hashinfo-&gt;bhash_size)];</div><div class="line">			spin_lock(&amp;head-&gt;lock);</div><div class="line">			inet_bind_bucket_for_each(tb, &amp;head-&gt;chain)</div><div class="line">				<span class="keyword">if</span> (net_eq(ib_net(tb), net) &amp;&amp; tb-&gt;port == rover) &#123;</div><div class="line">				</div><div class="line">					<span class="comment">/*判断端口是否可以复用，如果可以复用即使在链表中也一样复用*/</span></div><div class="line">					<span class="keyword">if</span> (((tb-&gt;fastreuse &gt; <span class="number">0</span> &amp;&amp;</div><div class="line">					      sk-&gt;sk_reuse &amp;&amp;</div><div class="line">					      sk-&gt;sk_state != TCP_LISTEN) ||</div><div class="line">					     (tb-&gt;fastreuseport &gt; <span class="number">0</span> &amp;&amp;</div><div class="line">					      sk-&gt;sk_reuseport &amp;&amp;</div><div class="line">					      uid_eq(tb-&gt;fastuid, uid))) &amp;&amp;</div><div class="line">					    (tb-&gt;num_owners &lt; smallest_size || smallest_size == <span class="number">-1</span>)) &#123;</div><div class="line">					    </div><div class="line">					    <span class="comment">/*记录下端口的使用个数和端口*/</span></div><div class="line">						smallest_size = tb-&gt;num_owners;</div><div class="line">						smallest_rover = rover;</div><div class="line">						</div><div class="line">						<span class="comment">/*系统绑定端口已经超过最大端口数了，要去检查inet_csk_bind_conflict绑定是否存在冲突*/</span></div><div class="line">						<span class="keyword">if</span> (atomic_read(&amp;hashinfo-&gt;bsockets) &gt; (high - low) + <span class="number">1</span> &amp;&amp;</div><div class="line">						    !inet_csk(sk)-&gt;icsk_af_ops-&gt;bind_conflict(sk, tb, <span class="literal">false</span>)) &#123;</div><div class="line">						   </div><div class="line">						   <span class="comment">/*ok，绑定没有冲突*/</span></div><div class="line">							snum = smallest_rover;</div><div class="line">							<span class="keyword">goto</span> tb_found;</div><div class="line">						&#125;</div><div class="line">					&#125;</div><div class="line">					</div><div class="line">					<span class="comment">/*端口冲突检查*/</span></div><div class="line">					<span class="keyword">if</span> (!inet_csk(sk)-&gt;icsk_af_ops-&gt;bind_conflict(sk, tb, <span class="literal">false</span>)) &#123;</div><div class="line">						snum = rover;</div><div class="line">						<span class="keyword">goto</span> tb_found;</div><div class="line">					&#125;</div><div class="line">					<span class="comment">/*此端口在链表中但是不能复用，继续下一个*/</span></div><div class="line">					<span class="keyword">goto</span> next;</div><div class="line">				&#125;</div><div class="line">			<span class="keyword">break</span>;<span class="comment">/*不在bind表中，端口可以使用，直接跳出循环*/</span></div><div class="line">		next:</div><div class="line">			spin_unlock(&amp;head-&gt;lock);</div><div class="line">		next_nolock:</div><div class="line">			<span class="comment">/*已经找到最大端口了，从最小开始找*/</span></div><div class="line">			<span class="keyword">if</span> (++rover &gt; high)</div><div class="line">				rover = low;</div><div class="line">		&#125; <span class="keyword">while</span> (--remaining &gt; <span class="number">0</span>);<span class="comment">/*en,最大5次查找机会*/</span></div><div class="line"></div><div class="line">		<span class="comment">/* Exhausted local port range during search?  It is not</span></div><div class="line">		 * possible for us to be holding one of the bind hash</div><div class="line">		 * locks if this test triggers, because if 'remaining'</div><div class="line">		 * drops to zero, we broke out of the do/while loop at</div><div class="line">		 * the top level, not from the 'break;' statement.</div><div class="line">		 */</div><div class="line">		ret = <span class="number">1</span>;</div><div class="line">		<span class="comment">/*没有找到端口，那就最后一次机会*/</span></div><div class="line">		<span class="keyword">if</span> (remaining &lt;= <span class="number">0</span>) &#123;</div><div class="line">			<span class="keyword">if</span> (smallest_size != <span class="number">-1</span>) &#123;</div><div class="line">				snum = smallest_rover;</div><div class="line">				<span class="keyword">goto</span> have_snum;</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">if</span> (attempt_half == <span class="number">1</span>) &#123;</div><div class="line">				<span class="comment">/* OK we now try the upper half of the range */</span></div><div class="line">				attempt_half = <span class="number">2</span>;</div><div class="line">				<span class="keyword">goto</span> again;</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">goto</span> fail;</div><div class="line">		&#125;</div><div class="line">		<span class="comment">/* OK, here is the one we will use.  HEAD is</span></div><div class="line">		 * non-NULL and we hold it's mutex.</div><div class="line">		 */</div><div class="line">		<span class="comment">/*找到可用的端口了*/</span></div><div class="line">		snum = rover;</div><div class="line">	&#125; <span class="keyword">else</span> &#123;</div><div class="line">	<span class="comment">/*指定绑定了端口，在绑定的链表中查找，如果查找到，代表已经被绑定*/</span></div><div class="line">have_snum:</div><div class="line">		head = &amp;hashinfo-&gt;bhash[inet_bhashfn(net, snum,</div><div class="line">				hashinfo-&gt;bhash_size)];</div><div class="line">		spin_lock(&amp;head-&gt;lock);</div><div class="line">		inet_bind_bucket_for_each(tb, &amp;head-&gt;chain)</div><div class="line">			<span class="keyword">if</span> (net_eq(ib_net(tb), net) &amp;&amp; tb-&gt;port == snum)</div><div class="line">				<span class="keyword">goto</span> tb_found;<span class="comment">/*端口已经被绑定*/</span></div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="comment">/*在绑定链表中没有发现，后续会创建*/</span></div><div class="line">	tb = <span class="literal">NULL</span>;</div><div class="line">	<span class="keyword">goto</span> tb_not_found;</div><div class="line">	</div><div class="line">tb_found:</div><div class="line">	<span class="keyword">if</span> (!hlist_empty(&amp;tb-&gt;owners)) &#123;</div><div class="line">	</div><div class="line">		<span class="comment">/*要bind的sk标记SK_FORCE_REUSE可以强制复用*/</span></div><div class="line">		<span class="keyword">if</span> (sk-&gt;sk_reuse == SK_FORCE_REUSE)</div><div class="line">			<span class="keyword">goto</span> success;</div><div class="line"></div><div class="line">		<span class="keyword">if</span> (((tb-&gt;fastreuse &gt; <span class="number">0</span> &amp;&amp;</div><div class="line">		      sk-&gt;sk_reuse &amp;&amp; sk-&gt;sk_state != TCP_LISTEN) ||</div><div class="line">		     (tb-&gt;fastreuseport &gt; <span class="number">0</span> &amp;&amp;</div><div class="line">		      sk-&gt;sk_reuseport &amp;&amp; uid_eq(tb-&gt;fastuid, uid))) &amp;&amp;</div><div class="line">		    smallest_size == <span class="number">-1</span>) &#123;</div><div class="line">	<span class="comment">/* 是否可以复用的判别</span></div><div class="line">	* fastreuseport Google添加选项&amp;&amp; 已经开启端口复用 &amp;&amp; 当前socket uid和查找到的uid相符合</div><div class="line">	* 当前socket也可以放到bind hash中，后续会将其加入</div><div class="line">	*/   </div><div class="line">			<span class="keyword">goto</span> success;</div><div class="line">		&#125; <span class="keyword">else</span> &#123;</div><div class="line">			ret = <span class="number">1</span>;</div><div class="line">			<span class="comment">/*端口绑定冲突，自动分配端口绑定冲突会走到此处，在自动分配端口时候进行了下列类似判别</span></div><div class="line">			*所以此判断基本不会执行知道跳到tb_not_found这个时候tb不为null的</div><div class="line">			*/</div><div class="line">			<span class="keyword">if</span> (inet_csk(sk)-&gt;icsk_af_ops-&gt;bind_conflict(sk, tb, <span class="literal">true</span>)) &#123;</div><div class="line">				<span class="keyword">if</span> (((sk-&gt;sk_reuse &amp;&amp; sk-&gt;sk_state != TCP_LISTEN) ||</div><div class="line">				     (tb-&gt;fastreuseport &gt; <span class="number">0</span> &amp;&amp;</div><div class="line">				      sk-&gt;sk_reuseport &amp;&amp; uid_eq(tb-&gt;fastuid, uid))) &amp;&amp;</div><div class="line">				    smallest_size != <span class="number">-1</span> &amp;&amp; --attempts &gt;= <span class="number">0</span>) &#123;</div><div class="line">					spin_unlock(&amp;head-&gt;lock);</div><div class="line">					<span class="keyword">goto</span> again;</div><div class="line">				&#125;</div><div class="line"></div><div class="line">				<span class="keyword">goto</span> fail_unlock;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">tb_not_found:</div><div class="line">	ret = <span class="number">1</span>;</div><div class="line">	<span class="comment">/*绑定时没有发现过tb，直接创建一个*/</span></div><div class="line">	<span class="keyword">if</span> (!tb &amp;&amp; (tb = inet_bind_bucket_create(hashinfo-&gt;bind_bucket_cachep,</div><div class="line">					net, head, snum)) == <span class="literal">NULL</span>)</div><div class="line">		<span class="keyword">goto</span> fail_unlock;</div><div class="line">	<span class="keyword">if</span> (hlist_empty(&amp;tb-&gt;owners)) &#123;<span class="comment">/*没有绑定过socket*/</span></div><div class="line">		<span class="keyword">if</span> (sk-&gt;sk_reuse &amp;&amp; sk-&gt;sk_state != TCP_LISTEN)</div><div class="line">			tb-&gt;fastreuse = <span class="number">1</span>;</div><div class="line">		<span class="keyword">else</span></div><div class="line">			tb-&gt;fastreuse = <span class="number">0</span>;</div><div class="line">			</div><div class="line">		<span class="comment">/*设置了SO_REUSEPORT选项*/</span></div><div class="line">		<span class="keyword">if</span> (sk-&gt;sk_reuseport) &#123;</div><div class="line">			tb-&gt;fastreuseport = <span class="number">1</span>;</div><div class="line">			tb-&gt;fastuid = uid;</div><div class="line">		&#125; <span class="keyword">else</span></div><div class="line">			tb-&gt;fastreuseport = <span class="number">0</span>;</div><div class="line">	&#125; <span class="keyword">else</span> &#123;<span class="comment">/*如果绑定过socket*/</span></div><div class="line">		<span class="keyword">if</span> (tb-&gt;fastreuse &amp;&amp;</div><div class="line">		    (!sk-&gt;sk_reuse || sk-&gt;sk_state == TCP_LISTEN))</div><div class="line">			tb-&gt;fastreuse = <span class="number">0</span>;</div><div class="line">		<span class="keyword">if</span> (tb-&gt;fastreuseport &amp;&amp;</div><div class="line">		    (!sk-&gt;sk_reuseport || !uid_eq(tb-&gt;fastuid, uid)))</div><div class="line">			tb-&gt;fastreuseport = <span class="number">0</span>;</div><div class="line">	&#125;</div><div class="line">success:</div><div class="line"><span class="comment">/*找到可用端口，添加绑定表*/</span></div><div class="line">	<span class="keyword">if</span> (!inet_csk(sk)-&gt;icsk_bind_hash)</div><div class="line">		inet_bind_hash(sk, tb, snum);<span class="comment">/*sk被放到tb-&gt;owners中*/</span></div><div class="line">	WARN_ON(inet_csk(sk)-&gt;icsk_bind_hash != tb);</div><div class="line">	ret = <span class="number">0</span>;</div><div class="line"></div><div class="line">fail_unlock:</div><div class="line">	spin_unlock(&amp;head-&gt;lock);</div><div class="line">fail:</div><div class="line">	local_bh_enable();</div><div class="line">	<span class="keyword">return</span> ret;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果端口为0；则自动选取端口选择过程如下：</p>
<blockquote>
<p>先在[low,half] or [half,high]中随机选取一个端口，作为循环获取端口的起始端口，开始以下流程</p>
</blockquote>
<pre><code>步骤1: 保留端口检查，不满足，端口加1，重试次数减1，继续从步骤1开始

步骤2: 从当前端口映射的hash桶中取出列表头，遍历检查该端口是否被使用
        步骤2-1:没有被使用，直接退出循环，tb为NULL，创建tb，跳转到tb_not_found将该端口连同创建的tb加入该hash桶的链表中，sk也被放到tb-&gt;owners中管理，结束退出
        步骤2-2: 端口被使用了，检查端口使用是否冲突
        步骤2-2-1:没有冲突，推出循环，跳转到tb_found,复用检查成功，sk被放到tb-&gt;owners中，结束退出
        步骤2-2-2:存在冲突，直接端口+1，继续循环查找

步骤3:如果上半部分已经查找完毕，继续[half,high]中选择一个端口，进行步骤1
</code></pre><h3 id="attempt-half"><a href="#attempt-half" class="headerlink" title="attempt_half"></a>attempt_half</h3><p>sk-&gt;sk_reuse == SK_CAN_REUSE<br> 取端口范围 [low ,half]<br>否则<br> 取端口范围 [half,high]</p>
<ul>
<li>该值会影响上述选择端口的流程从上半端还是从下半端选择端口</li>
<li>如果sk-&gt;sk_reuse被置SK_CAN_REUSE标记则先从下半端开始选择端口</li>
<li>否则直接从上半端选择端口</li>
</ul>
<h3 id="small-size和small-rover"><a href="#small-size和small-rover" class="headerlink" title="small_size和small_rover"></a>small_size和small_rover</h3><blockquote>
<p>what’s the fuck!!! 疑惑了好久<br>small_size和small_rover在3.10的版本中根本就没有使用基本用不到<br>3.10版本的端口查找原则是确定端口查找区间，随机选择端口，只要该端口能复用就直接使用，已经完全去除了优先选择复用端口数较小的端口这一原则了（3.2kernel）<br>So amazing！这两个变量可以去除了</p>
</blockquote>
<h2 id="inet-get-local-port-range"><a href="#inet-get-local-port-range" class="headerlink" title="inet_get_local_port_range"></a>inet_get_local_port_range</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">inet_get_local_port_range</span><span class="params">(struct net *net, <span class="keyword">int</span> *low, <span class="keyword">int</span> *high)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> seq;</div><div class="line"></div><div class="line">	<span class="keyword">do</span> &#123;</div><div class="line">		seq = read_seqbegin(&amp;net-&gt;ipv4_sysctl_local_ports.lock);</div><div class="line"></div><div class="line">		*low = net-&gt;ipv4_sysctl_local_ports.range[<span class="number">0</span>];</div><div class="line">		*high = net-&gt;ipv4_sysctl_local_ports.range[<span class="number">1</span>];</div><div class="line">	&#125; <span class="keyword">while</span> (read_seqretry(&amp;net-&gt;ipv4_sysctl_local_ports.lock, seq));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sysctl -a|grep ip_local_port_range</div><div class="line">net.ipv4.ip_local_port_range = 32768 60999</div></pre></td></tr></table></figure>
<ul>
<li>上述读取端口范围是用户态的ip_local_port_range，默认是3w多以后的，可以调整此参数扩大端口范围</li>
<li>上述read_seqbegin这种方式读取数据，是一种顺序锁，适用于读多写少的方式用方式，后续专门处博文研究</li>
</ul>
<h2 id="tcp端口冲突检查"><a href="#tcp端口冲突检查" class="headerlink" title="tcp端口冲突检查"></a>tcp端口冲突检查</h2><p>inet_csk(sk)-&gt;icsk_af_ops-&gt;bind_conflict<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">inet_connection_sock_af_ops</span> <span class="title">ipv4_specific</span> = &#123;</span></div><div class="line">	.queue_xmit	   = ip_queue_xmit,</div><div class="line">	.send_check	   = tcp_v4_send_check,</div><div class="line">	.rebuild_header	   = inet_sk_rebuild_header,</div><div class="line">	.sk_rx_dst_set	   = inet_sk_rx_dst_set,</div><div class="line">	.conn_request	   = tcp_v4_conn_request,</div><div class="line">	.syn_recv_sock	   = tcp_v4_syn_recv_sock,</div><div class="line">	.net_header_len	   = <span class="keyword">sizeof</span>(struct iphdr),</div><div class="line">	.setsockopt	   = ip_setsockopt,</div><div class="line">	.getsockopt	   = ip_getsockopt,</div><div class="line">	.addr2sockaddr	   = inet_csk_addr2sockaddr,</div><div class="line">	.sockaddr_len	   = <span class="keyword">sizeof</span>(struct sockaddr_in),</div><div class="line">	.bind_conflict	   = inet_csk_bind_conflict,</div><div class="line">#ifdef CONFIG_COMPAT</div><div class="line">	.compat_setsockopt = compat_ip_setsockopt,</div><div class="line">	.compat_getsockopt = compat_ip_getsockopt,</div><div class="line">#endif</div><div class="line">	.mtu_reduced	   = tcp_v4_mtu_reduced,</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">tcp_v4_init_sock</span><span class="params">(struct sock *sk)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inet_connection_sock</span> *<span class="title">icsk</span> = <span class="title">inet_csk</span>(<span class="title">sk</span>);</span></div><div class="line"></div><div class="line">	tcp_init_sock(sk);</div><div class="line"></div><div class="line">	icsk-&gt;icsk_af_ops = &amp;ipv4_specific;</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_TCP_MD5SIG</span></div><div class="line">	tcp_sk(sk)-&gt;af_specific = &amp;tcp_sock_ipv4_specific;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"></div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>从上文得知inet_csk(sk)-&gt;icsk_af_ops-&gt;bind_conflict 函数是inet_csk_bind_conflict</li>
<li>af_ops在tcp_v4_init_sock初始化</li>
</ul>
<h3 id="inet-csk-bind-conflict分析"><a href="#inet-csk-bind-conflict分析" class="headerlink" title="inet_csk_bind_conflict分析"></a>inet_csk_bind_conflict分析</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">inet_csk_bind_conflict</span><span class="params">(<span class="keyword">const</span> struct sock *sk,</span></span></div><div class="line">			   <span class="keyword">const</span> struct inet_bind_bucket *tb, <span class="keyword">bool</span> relax)</div><div class="line">&#123;</div><div class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *<span class="title">sk2</span>;</span></div><div class="line">	<span class="keyword">int</span> reuse = sk-&gt;sk_reuse;</div><div class="line">	<span class="keyword">int</span> reuseport = sk-&gt;sk_reuseport;</div><div class="line">	<span class="keyword">kuid_t</span> uid = sock_i_uid((struct sock *)sk);</div><div class="line"></div><div class="line">	<span class="comment">/*</span></div><div class="line">	 * Unlike other sk lookup places we do not check</div><div class="line">	 * for sk_net here, since _all_ the socks listed</div><div class="line">	 * in tb-&gt;owners list belong to the same net - the</div><div class="line">	 * one this bucket belongs to.</div><div class="line">	 */</div><div class="line"></div><div class="line">	sk_for_each_bound(sk2, &amp;tb-&gt;owners) &#123;</div><div class="line">	</div><div class="line">		<span class="comment">/*不会冲突情况1:socket绑定设备不同*/</span></div><div class="line">		<span class="keyword">if</span> (sk != sk2 &amp;&amp;</div><div class="line">		    !inet_v6_ipv6only(sk2) &amp;&amp;</div><div class="line">		    (!sk-&gt;sk_bound_dev_if ||</div><div class="line">		     !sk2-&gt;sk_bound_dev_if ||</div><div class="line">		     sk-&gt;sk_bound_dev_if == sk2-&gt;sk_bound_dev_if)) &#123;</div><div class="line">		     <span class="comment">/*</span></div><div class="line">		     *不会冲突情况2:地址不同</div><div class="line">		     */</div><div class="line">			<span class="keyword">if</span> ((!reuse || !sk2-&gt;sk_reuse ||</div><div class="line">			    sk2-&gt;sk_state == TCP_LISTEN) &amp;&amp;</div><div class="line">			    (!reuseport || !sk2-&gt;sk_reuseport ||</div><div class="line">			    (sk2-&gt;sk_state != TCP_TIME_WAIT &amp;&amp;</div><div class="line">			     !uid_eq(uid, sock_i_uid(sk2))))) &#123;</div><div class="line">			<span class="comment">/*</span></div><div class="line">			* 不会冲突情况3:</div><div class="line">			* 条件A: (reuse &amp;&amp; sk2-&gt;sk_reuse &amp;&amp; sk2-&gt;sk_state ！= TCP_LISTEN) </div><div class="line">			* 条件B：(reuseport </div><div class="line">			*       &amp;&amp; sk2-&gt;sk_reuseport </div><div class="line">			*       &amp;&amp;(sk2-&gt;sk_state == TCP_TIME_WAIT || uid_eq(uid, sock_i_uid(sk2))))</div><div class="line">			* 条件A和条件B只要有一个成立，就不会冲突</div><div class="line">			* 条件A成立条件：</div><div class="line">			* 	链上sock和待检查sock开启地址复用且链上状态不是监听状态</div><div class="line">			* 条件B成立条件：</div><div class="line">			*      链上sock和待检查sock开启端口复用且链表上状态为TW</div><div class="line">			*      链上sock和待检查sock开启端口复用且两个sock的uid相同</div><div class="line">			*/</div><div class="line">				<span class="keyword">if</span> (!sk2-&gt;sk_rcv_saddr || !sk-&gt;sk_rcv_saddr ||</div><div class="line">				    sk2-&gt;sk_rcv_saddr == sk-&gt;sk_rcv_saddr)</div><div class="line">					<span class="keyword">break</span>;</div><div class="line">			&#125;</div><div class="line">			<span class="comment">/*没有开启relax，要绑定方不能复用，已绑定方不能复用，以绑定方处理监听状态*/</span></div><div class="line">			<span class="keyword">if</span> (!relax &amp;&amp; reuse &amp;&amp; sk2-&gt;sk_reuse &amp;&amp;</div><div class="line">			    sk2-&gt;sk_state != TCP_LISTEN) &#123;</div><div class="line"></div><div class="line">				<span class="keyword">if</span> (!sk2-&gt;sk_rcv_saddr || !sk-&gt;sk_rcv_saddr ||</div><div class="line">				    sk2-&gt;sk_rcv_saddr == sk-&gt;sk_rcv_saddr)</div><div class="line">					<span class="keyword">break</span>;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> sk2 != <span class="literal">NULL</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>在端口自动选择时可以重用端口条件为：</p>
<p>a设备不同<br>b绑定ip地址不同<br>c要绑定sock和已绑定sock地址允许重用，且已绑定socket不处于监听状态<br>d 链上sock和待检查sock开启端口复用且链表上状态为TW<br>e 链上sock和待检查sock开启端口复用且两个sock的uid相同</p>
</blockquote>
<p> 关于条件c的补充条件：即使c满足，也需要看relax的值确定，relax为TRUE时可复用，为fase时候不能复用<br> 自动端口时候relax为false，所以条件c消失，仅仅剩下a、b、d、e四个条件</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;bind&quot;&gt;&lt;a href=&quot;#bind&quot; class=&quot;headerlink&quot; title=&quot;bind()&quot;&gt;&lt;/a&gt;bind()&lt;/h1&gt;&lt;p&gt;内核版本：3.10.0-514.16.1.el7.x86_64&lt;br&gt;下述源码分析均以tcp socket为背景&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;sys/types.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;sys/socket.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;bind&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; sockfd, struct sockaddr *my_addr, &lt;span class=&quot;keyword&quot;&gt;socklen_t&lt;/span&gt; addrlen)&lt;/span&gt;&lt;/span&gt;;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;socket文件描述符&lt;/li&gt;
&lt;li&gt;要绑定的承载地址和端口的结构体 struct sockaddr&lt;/li&gt;
&lt;li&gt;第二个参数struct sockaddr的长度&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;该函数负责绑定套接字的地址和端口，按照绑定者身份来分，会存在两种情况&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;情况1:绑定者为客户端，主动发起请求方，绑定地址和端口成功后，会使用该地址和端口进行发包&lt;br&gt;一般情况下，客户端的地址和端口都是其自动选择的，不需要绑定动作。&lt;br&gt;情况2:绑定者为服务端，被动连接接收方，绑定地址和端口成功后，客户端只能向该地址和端口发送连接请求。服务端往往需要绑定地址和端口。如果服务端存在多网卡情况，其只需要绑定服务端口即可，其目的地址就是客户端访问的目的地址。&lt;br&gt;
    
    </summary>
    
      <category term="socket" scheme="https://vcpu.github.io/categories/socket/"/>
    
    
      <category term="bind" scheme="https://vcpu.github.io/tags/bind/"/>
    
      <category term="tcp/ip" scheme="https://vcpu.github.io/tags/tcp-ip/"/>
    
      <category term="kernel3.10.0-514.16.1" scheme="https://vcpu.github.io/tags/kernel3-10-0-514-16-1/"/>
    
  </entry>
  
  <entry>
    <title>connect()实现源码分析</title>
    <link href="https://vcpu.github.io/connect/"/>
    <id>https://vcpu.github.io/connect/</id>
    <published>2017-06-09T10:59:10.000Z</published>
    <updated>2017-06-09T10:59:10.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="connect"><a href="#connect" class="headerlink" title="connect()"></a>connect()</h1><p>内核版本：3.10.0-514.16.1.el7.x86_64<br>下述源码分析均以tcp socket为背景</p>
<h2 id="用户态函数"><a href="#用户态函数" class="headerlink" title="用户态函数"></a>用户态函数</h2><p>int connect(int sockfd, const struct sockaddr *addr,socklen_t addrlen);<br>参数：</p>
<blockquote>
<p>socketfd socket文件描述索引下标<br>addr 要连接的服务端的地址<br>addrlen addr的长度</p>
</blockquote>
<p>实例:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">remote_addr</span>;</span></div><div class="line"><span class="built_in">memset</span>(&amp;remote_addr,<span class="number">0</span>,<span class="keyword">sizeof</span>(remote_addr));</div><div class="line">remote_addr.sin_family=AF_INET;</div><div class="line">remote_addr.sin_addr.s_addr=inet_addr(<span class="string">"180.97.33.108"</span>);</div><div class="line">remote_addr.sin_port = htons(<span class="number">80</span>);</div><div class="line">connect(fd,(struct sockaddr*)&amp;remote_addr,<span class="keyword">sizeof</span>(struct sockaddr)</div></pre></td></tr></table></figure></p>
<a id="more"></a>
<h2 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">SYSCALL_DEFINE2(socketcall, <span class="keyword">int</span>, call, <span class="keyword">unsigned</span> <span class="keyword">long</span> __user *, args)</div><div class="line">&#123;</div><div class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> a[AUDITSC_ARGS];</div><div class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> a0, a1;</div><div class="line">	<span class="keyword">int</span> err;</div><div class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> len;</div><div class="line"></div><div class="line">	<span class="keyword">if</span> (call &lt; <span class="number">1</span> || call &gt; SYS_SENDMMSG)</div><div class="line">		<span class="keyword">return</span> -EINVAL;</div><div class="line"></div><div class="line">	len = nargs[call];</div><div class="line">	<span class="keyword">if</span> (len &gt; <span class="keyword">sizeof</span>(a))</div><div class="line">		<span class="keyword">return</span> -EINVAL;</div><div class="line"></div><div class="line">	<span class="comment">/* copy_from_user should be SMP safe. */</span></div><div class="line">	<span class="keyword">if</span> (copy_from_user(a, args, len))</div><div class="line">		<span class="keyword">return</span> -EFAULT;</div><div class="line"></div><div class="line">	err = audit_socketcall(nargs[call] / <span class="keyword">sizeof</span>(<span class="keyword">unsigned</span> <span class="keyword">long</span>), a);</div><div class="line">	<span class="keyword">if</span> (err)</div><div class="line">		<span class="keyword">return</span> err;</div><div class="line"></div><div class="line">	a0 = a[<span class="number">0</span>];</div><div class="line">	a1 = a[<span class="number">1</span>];</div><div class="line"></div><div class="line">	<span class="keyword">switch</span> (call) &#123;</div><div class="line">	<span class="keyword">case</span> SYS_SOCKET:</div><div class="line">		err = sys_socket(a0, a1, a[<span class="number">2</span>]);</div><div class="line">		<span class="keyword">break</span>;</div><div class="line">	<span class="keyword">case</span> SYS_BIND:</div><div class="line">		err = sys_bind(a0, (struct sockaddr __user *)a1, a[<span class="number">2</span>]);</div><div class="line">		<span class="keyword">break</span>;</div><div class="line">	<span class="keyword">case</span> SYS_CONNECT:</div><div class="line">		err = sys_connect(a0, (struct sockaddr __user *)a1, a[<span class="number">2</span>]);</div><div class="line">		<span class="keyword">break</span>;</div><div class="line">	...</div><div class="line">	</div><div class="line">	<span class="keyword">default</span>:</div><div class="line">		err = -EINVAL;</div><div class="line">		<span class="keyword">break</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> err;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>系统调用sys_socketcall会携带（fd,serveraddr,serveraddrlen）参数</li>
<li>系统中断处理函数sys_socketcall会将参数从用户态考入到内核态局部变量a中</li>
<li>调用sys_connect函数 sys_connect(a0, (struct sockaddr __user *)a1, a[2]);</li>
</ul>
<h2 id="sys-connect执行入口分析"><a href="#sys-connect执行入口分析" class="headerlink" title="sys_connect执行入口分析"></a>sys_connect执行入口分析</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">SYSCALL_DEFINE3(connect, <span class="keyword">int</span>, fd, struct sockaddr __user *, uservaddr,<span class="keyword">int</span>,addrlen)</div><div class="line">&#123;</div><div class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">socket</span> *<span class="title">sock</span>;</span></div><div class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_storage</span> <span class="title">address</span>;</span></div><div class="line">	<span class="keyword">int</span> err, fput_needed;</div><div class="line"></div><div class="line">	sock = sockfd_lookup_light(fd, &amp;err, &amp;fput_needed);</div><div class="line">	<span class="keyword">if</span> (!sock)</div><div class="line">		<span class="keyword">goto</span> out;</div><div class="line">	err = move_addr_to_kernel(uservaddr, addrlen, &amp;address);</div><div class="line">	<span class="keyword">if</span> (err &lt; <span class="number">0</span>)</div><div class="line">		<span class="keyword">goto</span> out_put;</div><div class="line"></div><div class="line">	err =</div><div class="line">	    security_socket_connect(sock, (struct sockaddr *)&amp;address, addrlen);</div><div class="line">	<span class="keyword">if</span> (err)</div><div class="line">		<span class="keyword">goto</span> out_put;</div><div class="line"></div><div class="line">	err = sock-&gt;ops-&gt;connect(sock, (struct sockaddr *)&amp;address, addrlen,</div><div class="line">				 sock-&gt;file-&gt;f_flags);</div><div class="line">out_put:</div><div class="line">	fput_light(sock-&gt;file, fput_needed);</div><div class="line">out:</div><div class="line">	<span class="keyword">return</span> err;</div></pre></td></tr></table></figure>
<ul>
<li>根据fd描述符号从当前进程current的files指针中的struct fd_table中的fd成员取出file</li>
<li>fdt-&gt;fd是一个数组用来管理当前进程的file指针</li>
<li>从file中privatedata中获取到socket变量</li>
<li>把connect连接的服务端地址存入内核空间中move_addr_to_kernel</li>
<li>sock-&gt;ops-&gt;connect 以tco为例，此处会调用inet_stream_connect 函数集合中的inet_stream_connect</li>
</ul>
<h3 id="inet-stream-connect分析"><a href="#inet-stream-connect分析" class="headerlink" title="inet_stream_connect分析"></a>inet_stream_connect分析</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">inet_stream_connect</span><span class="params">(struct socket *sock, struct sockaddr *uaddr,</span></span></div><div class="line">			<span class="keyword">int</span> addr_len, <span class="keyword">int</span> flags)</div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span> err;</div><div class="line"></div><div class="line">	lock_sock(sock-&gt;sk);</div><div class="line">	err = __inet_stream_connect(sock, uaddr, addr_len, flags);</div><div class="line">	release_sock(sock-&gt;sk);</div><div class="line">	<span class="keyword">return</span> err;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>inet_stream_connect() 为tcp socket时候connect动作调用的函数<br>改函数会调用__inet_stream_connect函数</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> __inet_stream_connect(struct socket *sock, struct sockaddr *uaddr,</div><div class="line">			  <span class="keyword">int</span> addr_len, <span class="keyword">int</span> flags)</div><div class="line">&#123;</div><div class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *<span class="title">sk</span> = <span class="title">sock</span>-&gt;<span class="title">sk</span>;</span></div><div class="line">	<span class="keyword">int</span> err;</div><div class="line">	<span class="keyword">long</span> timeo;</div><div class="line"></div><div class="line">	<span class="comment">//socket地址长度检查，不合法返回</span></div><div class="line">	<span class="keyword">if</span> (addr_len &lt; <span class="keyword">sizeof</span>(uaddr-&gt;sa_family))</div><div class="line">		<span class="keyword">return</span> -EINVAL;</div><div class="line">   <span class="comment">// 地址协议族检查，如果不合法则关闭连接</span></div><div class="line">	<span class="keyword">if</span> (uaddr-&gt;sa_family == AF_UNSPEC) &#123;</div><div class="line">		err = sk-&gt;sk_prot-&gt;disconnect(sk, flags);</div><div class="line">		sock-&gt;state = err ? SS_DISCONNECTING : SS_UNCONNECTED;</div><div class="line">		<span class="keyword">goto</span> out;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	</div><div class="line">	<span class="keyword">switch</span> (sock-&gt;state) &#123;</div><div class="line">	<span class="comment">//非法参数</span></div><div class="line">	<span class="keyword">default</span>:</div><div class="line">		err = -EINVAL;</div><div class="line">		<span class="keyword">goto</span> out;</div><div class="line">	<span class="comment">//该socket和对端连接已经建立</span></div><div class="line">	<span class="keyword">case</span> SS_CONNECTED:</div><div class="line">		err = -EISCONN;</div><div class="line">		<span class="keyword">goto</span> out;</div><div class="line">	<span class="comment">//该socket和对端连接建立中</span></div><div class="line">	<span class="keyword">case</span> SS_CONNECTING:</div><div class="line">		err = -EALREADY;</div><div class="line">		<span class="comment">/* Fall out of switch with err, set for this state */</span></div><div class="line">		<span class="keyword">break</span>;</div><div class="line">	<span class="comment">//该socket和对未连接</span></div><div class="line">	<span class="keyword">case</span> SS_UNCONNECTED:</div><div class="line">		err = -EISCONN;</div><div class="line">		<span class="comment">//如果未连接，但是socket还不是TCP_CLOSE状态错误返回</span></div><div class="line">		<span class="keyword">if</span> (sk-&gt;sk_state != TCP_CLOSE)</div><div class="line">			<span class="keyword">goto</span> out;</div><div class="line">		<span class="comment">//tcp调用tcp_v4_connect，发送syn</span></div><div class="line">		err = sk-&gt;sk_prot-&gt;connect(sk, uaddr, addr_len);</div><div class="line">		<span class="keyword">if</span> (err &lt; <span class="number">0</span>)</div><div class="line">			<span class="keyword">goto</span> out;</div><div class="line"></div><div class="line">		<span class="comment">//发送syn后sock状态从未连接更新为连接中</span></div><div class="line">		sock-&gt;state = SS_CONNECTING;</div><div class="line"></div><div class="line">		<span class="comment">/* Just entered SS_CONNECTING state; the only</span></div><div class="line">		 * difference is that return value in non-blocking</div><div class="line">		 * case is EINPROGRESS, rather than EALREADY.</div><div class="line">		 */</div><div class="line">		err = -EINPROGRESS;</div><div class="line">		<span class="keyword">break</span>;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">//默认情况下未设置非阻塞socket标志，timeo不为0，设置非阻塞，该值为0</span></div><div class="line">	timeo = sock_sndtimeo(sk, flags &amp; O_NONBLOCK);</div><div class="line"></div><div class="line">	<span class="comment">//发送syn后等待后续握手完成</span></div><div class="line">	<span class="comment">/*</span></div><div class="line">	* 阻塞socket</div><div class="line">	* inet_wait_for_connect 会等待协议栈层的处理</div><div class="line">	* 1.等待超过timeo，connect返回EINPROGRESS 表明正在处理</div><div class="line">	* 2.收到信号 </div><div class="line">	* 3.正常完成握手，返回0</div><div class="line">	* 非阻塞socket</div><div class="line">	* 直接退出connect函数并返回EINPROGRESS，表明协议栈正在处理</div><div class="line">	*/</div><div class="line">	<span class="keyword">if</span> ((<span class="number">1</span> &lt;&lt; sk-&gt;sk_state) &amp; (TCPF_SYN_SENT | TCPF_SYN_RECV)) &#123;</div><div class="line">		<span class="keyword">int</span> writebias = (sk-&gt;sk_protocol == IPPROTO_TCP) &amp;&amp;</div><div class="line">				tcp_sk(sk)-&gt;fastopen_req &amp;&amp;</div><div class="line">				tcp_sk(sk)-&gt;fastopen_req-&gt;data ? <span class="number">1</span> : <span class="number">0</span>;</div><div class="line"></div><div class="line">		<span class="comment">/* Error code is set above */</span></div><div class="line">		<span class="keyword">if</span> (!timeo || !inet_wait_for_connect(sk, timeo, writebias))</div><div class="line">			<span class="keyword">goto</span> out;</div><div class="line"></div><div class="line">		err = sock_intr_errno(timeo);</div><div class="line">		<span class="keyword">if</span> (signal_pending(current))</div><div class="line">			<span class="keyword">goto</span> out;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">/* Connection was closed by RST, timeout, ICMP error</span></div><div class="line">	 * or another process disconnected us.</div><div class="line">	 */</div><div class="line">	<span class="keyword">if</span> (sk-&gt;sk_state == TCP_CLOSE)</div><div class="line">		<span class="keyword">goto</span> sock_error;</div><div class="line"></div><div class="line">	<span class="comment">/* sk-&gt;sk_err may be not zero now, if RECVERR was ordered by user</span></div><div class="line">	 * and error was received after socket entered established state.</div><div class="line">	 * Hence, it is handled normally after connect() return successfully.</div><div class="line">	 */</div><div class="line">	<span class="comment">//TCP握手完成，连接已经建立</span></div><div class="line">	sock-&gt;state = SS_CONNECTED;</div><div class="line">	err = <span class="number">0</span>;</div><div class="line">out:</div><div class="line">	<span class="keyword">return</span> err;</div><div class="line"></div><div class="line"><span class="comment">//异常处理，关闭连接</span></div><div class="line">sock_error:</div><div class="line">	err = sock_error(sk) ? : -ECONNABORTED;</div><div class="line">	sock-&gt;state = SS_UNCONNECTED;</div><div class="line">	<span class="keyword">if</span> (sk-&gt;sk_prot-&gt;disconnect(sk, flags))</div><div class="line">		sock-&gt;state = SS_DISCONNECTING;</div><div class="line">	<span class="keyword">goto</span> out;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>__inet_stream_connect检查地址长度和协议族</li>
<li>检查sock状态，正常情况下状态为SS_UNCONNECTED</li>
<li>sk-&gt;sk_prot-&gt;connect tcp_v4_connect来发送syn</li>
<li>在syn包发完以后会有两种处理情况</li>
</ul>
<blockquote>
<p>情况1:立即返回，针对于非阻塞socket，此时协议栈正在处理握手connect会返回-EINPROGRESS<br>情况2:阻塞运行</p>
<blockquote>
<p>阻塞时间超时后，connect返回-EINPROGRESS<br>收到信号，connect返回-ERESTARTSYS,-EINTR</p>
</blockquote>
</blockquote>
<h3 id="inet-wait-for-connect函数分析"><a href="#inet-wait-for-connect函数分析" class="headerlink" title="inet_wait_for_connect函数分析"></a>inet_wait_for_connect函数分析</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">long</span> <span class="title">inet_wait_for_connect</span><span class="params">(struct sock *sk, <span class="keyword">long</span> timeo, <span class="keyword">int</span> writebias)</span></span></div><div class="line">&#123;</div><div class="line">	DEFINE_WAIT(wait);</div><div class="line"></div><div class="line">	prepare_to_wait(sk_sleep(sk), &amp;wait, TASK_INTERRUPTIBLE);</div><div class="line">	sk-&gt;sk_write_pending += writebias;</div><div class="line"></div><div class="line">	<span class="comment">/* Basic assumption: if someone sets sk-&gt;sk_err, he _must_</span></div><div class="line">	 * change state of the socket from TCP_SYN_*.</div><div class="line">	 * Connect() does not allow to get error notifications</div><div class="line">	 * without closing the socket.</div><div class="line">	 */</div><div class="line">	<span class="keyword">while</span> ((<span class="number">1</span> &lt;&lt; sk-&gt;sk_state) &amp; (TCPF_SYN_SENT | TCPF_SYN_RECV)) &#123;</div><div class="line">		release_sock(sk);<span class="comment">/*等下要睡眠了释放sk锁*/</span></div><div class="line">		</div><div class="line">		</div><div class="line">		timeo = schedule_timeout(timeo);</div><div class="line">		<span class="comment">/*</span></div><div class="line">		* 调用schedule_timeout sleep until timeout</div><div class="line">		* 收到信号后，timeout值返回剩余等待时间</div><div class="line">		* 超时timeout后，返回0</div><div class="line">		*/</div><div class="line">		</div><div class="line">		<span class="comment">/*进程被唤醒后新上sk锁*/</span></div><div class="line">		lock_sock(sk);</div><div class="line">		</div><div class="line">		<span class="comment">/*进程有带处理信号，或者睡眠超时，推出循环*/</span></div><div class="line">		<span class="keyword">if</span> (signal_pending(current) || !timeo)</div><div class="line">			<span class="keyword">break</span>;</div><div class="line">		prepare_to_wait(sk_sleep(sk), &amp;wait, TASK_INTERRUPTIBLE);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="comment">/*等待结束后，将进程从等待队列删除，标记为TASK_RUNNING*/</span></div><div class="line">	finish_wait(sk_sleep(sk), &amp;wait);</div><div class="line">	sk-&gt;sk_write_pending -= writebias;</div><div class="line">	<span class="keyword">return</span> timeo;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>睡眠前进程被设置成TASK_INTERRUPTIBLE状态</li>
<li>SO_SNDTIMEO选项对上述的睡眠非常重要</li>
<li>SO_SNDTIMEO被设置，则睡眠时间会安装设置值</li>
<li>SO_SNDTIMEO没有被设置，则在没有收到信号前一只阻塞</li>
<li>睡眠结束，进程从睡眠队列中删除，并标记为TASK_RUNNING</li>
</ul>
<h3 id="prepare-to-wait实现分析"><a href="#prepare-to-wait实现分析" class="headerlink" title="prepare_to_wait实现分析"></a>prepare_to_wait实现分析</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">prepare_to_wait</span><span class="params">(<span class="keyword">wait_queue_head_t</span> *q, <span class="keyword">wait_queue_t</span> *wait, <span class="keyword">int</span> state)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</div><div class="line"></div><div class="line">	wait-&gt;flags &amp;= ~WQ_FLAG_EXCLUSIVE;</div><div class="line">	spin_lock_irqsave(&amp;q-&gt;lock, flags);</div><div class="line">	<span class="keyword">if</span> (list_empty(&amp;wait-&gt;task_list))</div><div class="line">		__add_wait_queue(q, wait);</div><div class="line">	set_current_state(state);</div><div class="line">	spin_unlock_irqrestore(&amp;q-&gt;lock, flags);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>prepare_to_wait(sk_sleep(sk), &amp;wait, TASK_INTERRUPTIBLE);</li>
<li>把wait放入q队列中，设置当前进程状态为TASK_INTERRUPTIBLE</li>
<li>TASK_INTERRUPTIBLE 是一种睡眠信号</li>
<li>标记TASK_INTERRUPTIBLE的信号会被唤醒并处理信号</li>
</ul>
<h3 id="阻塞socket唤醒机制"><a href="#阻塞socket唤醒机制" class="headerlink" title="阻塞socket唤醒机制"></a>阻塞socket唤醒机制</h3><p>[root@localhost stp]# stap bt.stp sock_def_wakeup</p>
<blockquote>
<p>WARNING: Missing unwind data for a module, rerun with ‘stap -d e1000’<br>—————-START————————-<br>In process [swapper/2]<br>RIP: ffffffff81558150<br>RSP: ffff88003fd03970  EFLAGS: 00000246<br>RAX: 0000000000004308 RBX: ffff88003a82a6c0 RCX: 0000000000000000<br>RDX: 0000000050000000 RSI: 0000000000ca00c8 RDI: ffff88003a82a6c0<br>RBP: ffff88003fd03988 R08: ffff88003db89708 R09: ffff88003e001800<br>R10: ffffffff815dabca R11: 0000000000000000 R12: ffff88001bfa3700<br>R13: ffff880002db6762 R14: 0000000000000218 R15: ffff880002db675a<br>FS:  0000000000000000(0000) GS:ffff88003fd00000(0000) knlGS:0000000000000000<br>CS:  0010 DS: 0000 ES: 0000 CR0: 000000008005003b<br>CR2: 00007ffaf3049072 CR3: 000000003b0b7000 CR4: 00000000000406e0<br> 0xffffffff81558150 : sock_def_wakeup+0x0/0x40 [kernel]<br> 0xffffffff815cbc09 : tcp_finish_connect+0xc9/0x120 [kernel]<br> 0xffffffff815cc297 : tcp_rcv_state_process+0x637/0xf20 [kernel]<br> 0xffffffff815d5ffb : tcp_v4_do_rcv+0x17b/0x340 [kernel]<br> 0xffffffff815d76d9 : tcp_v4_rcv+0x799/0x9a0 [kernel]<br> 0xffffffff815b1094 : ip_local_deliver_finish+0xb4/0x1f0 [kernel]<br> 0xffffffff815b1379 : ip_local_deliver+0x59/0xd0 [kernel]<br> 0xffffffff815b0d1a : ip_rcv_finish+0x8a/0x350 [kernel]<br> 0xffffffff815b16a6 : ip_rcv+0x2b6/0x410 [kernel]<br> 0xffffffff815700d2 : <strong>netif_receive_skb_core+0x582/0x800 [kernel]<br> 0xffffffff81570368 : </strong>netif_receive_skb+0x18/0x60 [kernel]<br> 0xffffffff815703f0 : netif_receive_skb_internal+0x40/0xc0 [kernel]<br> 0xffffffff81571578 : napi_gro_receive+0xd8/0x130 [kernel]<br> 0xffffffffa00472fc [e1000]<br>—————-END————————-</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">tcp_finish_connect</span><span class="params">(struct sock *sk, struct sk_buff *skb)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tcp_sock</span> *<span class="title">tp</span> = <span class="title">tcp_sk</span>(<span class="title">sk</span>);</span></div><div class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inet_connection_sock</span> *<span class="title">icsk</span> = <span class="title">inet_csk</span>(<span class="title">sk</span>);</span></div><div class="line"></div><div class="line">	tcp_set_state(sk, TCP_ESTABLISHED);</div><div class="line"></div><div class="line">	<span class="keyword">if</span> (skb != <span class="literal">NULL</span>) &#123;</div><div class="line">		icsk-&gt;icsk_af_ops-&gt;sk_rx_dst_set(sk, skb);</div><div class="line">		security_inet_conn_established(sk, skb);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">/* Make sure socket is routed, for correct metrics.  */</span></div><div class="line">	icsk-&gt;icsk_af_ops-&gt;rebuild_header(sk);</div><div class="line"></div><div class="line">	tcp_init_metrics(sk);</div><div class="line"></div><div class="line">	tcp_init_congestion_control(sk);</div><div class="line"></div><div class="line">	<span class="comment">/* Prevent spurious tcp_cwnd_restart() on first data</span></div><div class="line">	 * packet.</div><div class="line">	 */</div><div class="line">	tp-&gt;lsndtime = tcp_time_stamp;</div><div class="line"></div><div class="line">	tcp_init_buffer_space(sk);</div><div class="line"></div><div class="line">	<span class="keyword">if</span> (sock_flag(sk, SOCK_KEEPOPEN))</div><div class="line">		inet_csk_reset_keepalive_timer(sk, keepalive_time_when(tp));</div><div class="line"></div><div class="line">	<span class="keyword">if</span> (!tp-&gt;rx_opt.snd_wscale)</div><div class="line">		__tcp_fast_path_on(tp, tp-&gt;snd_wnd);</div><div class="line">	<span class="keyword">else</span></div><div class="line">		tp-&gt;pred_flags = <span class="number">0</span>;</div><div class="line"></div><div class="line">	<span class="keyword">if</span> (!sock_flag(sk, SOCK_DEAD)) &#123;</div><div class="line">		<span class="comment">/*握手完成唤醒所有进程*/</span></div><div class="line">		sk-&gt;sk_state_change(sk);</div><div class="line">		sk_wake_async(sk, SOCK_WAKE_IO, POLL_OUT);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>sock_def_wakeup -&gt;wake_up_interruptible_all </li>
<li>上述过程发声在三次握手完成后，TCP从syn send或者syn rcv切换到establish状态时候发生</li>
<li>tcp_finish_connect-&gt;sk-&gt;sk_state_change[sock_def_wakeup]</li>
<li>此次唤醒是全部唤醒sk上等待队列的进程</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;connect&quot;&gt;&lt;a href=&quot;#connect&quot; class=&quot;headerlink&quot; title=&quot;connect()&quot;&gt;&lt;/a&gt;connect()&lt;/h1&gt;&lt;p&gt;内核版本：3.10.0-514.16.1.el7.x86_64&lt;br&gt;下述源码分析均以tcp socket为背景&lt;/p&gt;
&lt;h2 id=&quot;用户态函数&quot;&gt;&lt;a href=&quot;#用户态函数&quot; class=&quot;headerlink&quot; title=&quot;用户态函数&quot;&gt;&lt;/a&gt;用户态函数&lt;/h2&gt;&lt;p&gt;int connect(int sockfd, const struct sockaddr *addr,socklen_t addrlen);&lt;br&gt;参数：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;socketfd socket文件描述索引下标&lt;br&gt;addr 要连接的服务端的地址&lt;br&gt;addrlen addr的长度&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;实例:&lt;br&gt;&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;sockaddr_in&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;remote_addr&lt;/span&gt;;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;memset&lt;/span&gt;(&amp;amp;remote_addr,&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,&lt;span class=&quot;keyword&quot;&gt;sizeof&lt;/span&gt;(remote_addr));&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;remote_addr.sin_family=AF_INET;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;remote_addr.sin_addr.s_addr=inet_addr(&lt;span class=&quot;string&quot;&gt;&quot;180.97.33.108&quot;&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;remote_addr.sin_port = htons(&lt;span class=&quot;number&quot;&gt;80&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;connect(fd,(struct sockaddr*)&amp;amp;remote_addr,&lt;span class=&quot;keyword&quot;&gt;sizeof&lt;/span&gt;(struct sockaddr)&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="socket" scheme="https://vcpu.github.io/categories/socket/"/>
    
    
      <category term="tcp/ip" scheme="https://vcpu.github.io/tags/tcp-ip/"/>
    
      <category term="kernel3.10.0-514.16.1" scheme="https://vcpu.github.io/tags/kernel3-10-0-514-16-1/"/>
    
      <category term="socket" scheme="https://vcpu.github.io/tags/socket/"/>
    
  </entry>
  
  <entry>
    <title>socket()实现源码分析</title>
    <link href="https://vcpu.github.io/socket/"/>
    <id>https://vcpu.github.io/socket/</id>
    <published>2017-06-09T09:22:34.000Z</published>
    <updated>2017-06-22T10:13:08.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="socket"><a href="#socket" class="headerlink" title="socket()"></a>socket()</h1><p>内核版本：3.10.0-514.16.1.el7.x86_64</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;          /* See NOTES */</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">socket</span><span class="params">(<span class="keyword">int</span> domain, <span class="keyword">int</span> type, <span class="keyword">int</span> protocol)</span></span>;</div><div class="line">fd=socket(PF_INET,SOCK_STREAM,<span class="number">0</span></div></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="1-接口说明："><a href="#1-接口说明：" class="headerlink" title="(1).接口说明："></a>(1).接口说明：</h2><h3 id="按照顺序可传入如下参数："><a href="#按照顺序可传入如下参数：" class="headerlink" title="按照顺序可传入如下参数："></a>按照顺序可传入如下参数：</h3><ul>
<li>PF_INEAT</li>
<li>SOCK_STREAM,SOCK_DGRAM,SOCK_RAW</li>
<li>IPPROTO_TCP,IPPROTO_UDP,IPPROTO_IP</li>
</ul>
<h3 id="返回值说明"><a href="#返回值说明" class="headerlink" title="返回值说明"></a>返回值说明</h3><ul>
<li>EAFNOSUPPORT 不支持地址类型</li>
<li>EMFILE     进程文件表溢出</li>
<li>ENFILE 核心内存不足无法建立新的socket</li>
<li>EINVAL 参数domain/type/protocol不合法</li>
<li>EACCES 权限不允许</li>
<li>ENOBUFS/ENOMEM 内存不足</li>
<li>EPROTONOSUPPORT domain指定的类型不支持参数type或者protocol</li>
</ul>
<h2 id="2-内核调用栈"><a href="#2-内核调用栈" class="headerlink" title="(2).内核调用栈"></a>(2).内核调用栈</h2><p><img src="/myimages/socket.png" alt="socket"></p>
<h2 id="3-结构体说明"><a href="#3-结构体说明" class="headerlink" title="(3).结构体说明"></a>(3).结构体说明</h2><blockquote>
<p>struct socket</p>
<blockquote>
<p>面向用户态的结构体<br>基于虚拟文件系统创建<br>创建socket时最先创建的结构体</p>
</blockquote>
<p>struct sock </p>
<blockquote>
<p>网络层socket</p>
</blockquote>
<p>struct inet_sock</p>
<blockquote>
<p>INET域socket表示<br>提供INET域的一些属性，TTL、 组播、 地址 、端口</p>
</blockquote>
<p>struct raw_socket、struct udp—sock、 struct inet_connection_sock </p>
<blockquote>
<p>是对struct inet_sock的扩展<br>struct raw_socket要处理ICMP<br>struct udp_sock udp协议socket<br>struct inet_connection_sock面向连接socket<br>struct tcp_sock TCP协议socket ，对inet_connection_sock扩展，增加了滑动窗口等拥塞控制属性<br>struct inet_timewait_sock网络层超时控制使用<br>struct tcp_timewait_sock TCP协议超时控制使用</p>
</blockquote>
</blockquote>
<h2 id="4-struct-socket创建源码分析"><a href="#4-struct-socket创建源码分析" class="headerlink" title="(4).struct socket创建源码分析"></a>(4).struct socket创建源码分析</h2><h3 id="4-1-sock-alloc函数"><a href="#4-1-sock-alloc函数" class="headerlink" title="(4.1).sock_alloc函数"></a>(4.1).sock_alloc函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> struct socket *<span class="title">sock_alloc</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span>;</span></div><div class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">socket</span> *<span class="title">sock</span>;</span></div><div class="line"></div><div class="line">	inode = new_inode_pseudo(sock_mnt-&gt;mnt_sb);</div><div class="line">	<span class="keyword">if</span> (!inode)</div><div class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line"></div><div class="line">	sock = SOCKET_I(inode);</div><div class="line"></div><div class="line">	kmemcheck_annotate_bitfield(sock, type);</div><div class="line">	inode-&gt;i_ino = get_next_ino();</div><div class="line">	inode-&gt;i_mode = S_IFSOCK | S_IRWXUGO;</div><div class="line">	inode-&gt;i_uid = current_fsuid();</div><div class="line">	inode-&gt;i_gid = current_fsgid();</div><div class="line">	inode-&gt;i_op = &amp;sockfs_inode_ops;</div><div class="line"></div><div class="line">	this_cpu_add(sockets_in_use, <span class="number">1</span>);</div><div class="line">	<span class="keyword">return</span> sock;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>一起申请两块内存struct socket和struct inode</li>
<li>两块内存用struct socket_alloc联系起来</li>
<li>inode是linux用来刻画一个存放在内存中的文件的</li>
<li>socket是一种网络文件类型，可以通过文件描述符使用read和write等文件操作函数操作socket</li>
<li>有了inode就支持了虚拟文件系统的操作</li>
</ul>
<h3 id="4-2-sock-alloc-gt-new-inode-pseudo-gt-alloc-inode"><a href="#4-2-sock-alloc-gt-new-inode-pseudo-gt-alloc-inode" class="headerlink" title="(4.2).sock_alloc-&gt;new_inode_pseudo-&gt;alloc_inode"></a>(4.2).sock_alloc-&gt;new_inode_pseudo-&gt;alloc_inode</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="function">struct inode *<span class="title">new_inode_pseudo</span><span class="params">(struct super_block *sb)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span> = <span class="title">alloc_inode</span>(<span class="title">sb</span>);</span></div><div class="line"></div><div class="line">	<span class="keyword">if</span> (inode) &#123;</div><div class="line">		spin_lock(&amp;inode-&gt;i_lock);</div><div class="line">		inode-&gt;i_state = <span class="number">0</span>;</div><div class="line">		spin_unlock(&amp;inode-&gt;i_lock);</div><div class="line">		INIT_LIST_HEAD(&amp;inode-&gt;i_sb_list);</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> inode;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">static</span> struct inode *<span class="title">alloc_inode</span><span class="params">(struct super_block *sb)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span>;</span></div><div class="line"></div><div class="line">	<span class="keyword">if</span> (sb-&gt;s_op-&gt;alloc_inode)</div><div class="line">		inode = sb-&gt;s_op-&gt;alloc_inode(sb);</div><div class="line">	<span class="keyword">else</span></div><div class="line">		inode = kmem_cache_alloc(inode_cachep, GFP_KERNEL);</div><div class="line"></div><div class="line">	<span class="keyword">if</span> (!inode)</div><div class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line"></div><div class="line">	<span class="keyword">if</span> (unlikely(inode_init_always(sb, inode))) &#123;</div><div class="line">		<span class="keyword">if</span> (inode-&gt;i_sb-&gt;s_op-&gt;destroy_inode)</div><div class="line">			inode-&gt;i_sb-&gt;s_op-&gt;destroy_inode(inode);</div><div class="line">		<span class="keyword">else</span></div><div class="line">			kmem_cache_free(inode_cachep, inode);</div><div class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">return</span> inode;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>alloc_inode获取内存有两种方式 1.通过自己alloc_inode分配 2.从高速缓存中分配</li>
</ul>
<h3 id="4-3-alloc-inode-gt-sock-alloc-inode"><a href="#4-3-alloc-inode-gt-sock-alloc-inode" class="headerlink" title="(4.3).alloc_inode -&gt; sock_alloc_inode"></a>(4.3).alloc_inode -&gt; sock_alloc_inode</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> struct inode *<span class="title">sock_alloc_inode</span><span class="params">(struct super_block *sb)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">socket_alloc</span> *<span class="title">ei</span>;</span></div><div class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">socket_wq</span> *<span class="title">wq</span>;</span></div><div class="line"></div><div class="line">	ei = kmem_cache_alloc(sock_inode_cachep, GFP_KERNEL);</div><div class="line">	<span class="keyword">if</span> (!ei)</div><div class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">	wq = kmalloc(<span class="keyword">sizeof</span>(*wq), GFP_KERNEL);</div><div class="line">	<span class="keyword">if</span> (!wq) &#123;</div><div class="line">		kmem_cache_free(sock_inode_cachep, ei);</div><div class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">	&#125;</div><div class="line">	init_waitqueue_head(&amp;wq-&gt;wait);</div><div class="line">	wq-&gt;fasync_list = <span class="literal">NULL</span>;</div><div class="line">	RCU_INIT_POINTER(ei-&gt;socket.wq, wq);</div><div class="line"></div><div class="line">	ei-&gt;socket.state = SS_UNCONNECTED;</div><div class="line">	ei-&gt;socket.flags = <span class="number">0</span>;</div><div class="line">	ei-&gt;socket.ops = <span class="literal">NULL</span>;</div><div class="line">	ei-&gt;socket.sk = <span class="literal">NULL</span>;</div><div class="line">	ei-&gt;socket.file = <span class="literal">NULL</span>;</div><div class="line"></div><div class="line">	<span class="keyword">return</span> &amp;ei-&gt;vfs_inode;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>socket结构体最终会调用上述函数申请内存</li>
<li>该函数会在sock_init中被注册和挂载到系统上</li>
</ul>
<h3 id="4-4-sock-init-中sock-allok-inode挂载过程"><a href="#4-4-sock-init-中sock-allok-inode挂载过程" class="headerlink" title="(4.4).sock_init 中sock_allok_inode挂载过程"></a>(4.4).sock_init 中sock_allok_inode挂载过程</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">err = register_filesystem(&amp;sock_fs_type);</div><div class="line">	<span class="keyword">if</span> (err)</div><div class="line">		<span class="keyword">goto</span> out_fs;</div><div class="line">	sock_mnt = kern_mount(&amp;sock_fs_type);</div><div class="line">	<span class="keyword">if</span> (IS_ERR(sock_mnt)) &#123;</div><div class="line">		err = PTR_ERR(sock_mnt);</div><div class="line">		<span class="keyword">goto</span> out_mount;</div><div class="line">	...</div><div class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_system_type</span> <span class="title">sock_fs_type</span> = &#123;</span></div><div class="line">	.name =		<span class="string">"sockfs"</span>,</div><div class="line">	.mount =	sockfs_mount,</div><div class="line">	.kill_sb =	kill_anon_super,</div><div class="line">&#125;;</div><div class="line"><span class="function"><span class="keyword">static</span> struct dentry *<span class="title">sockfs_mount</span><span class="params">(struct file_system_type *fs_type,</span></span></div><div class="line">			 <span class="keyword">int</span> flags, <span class="keyword">const</span> <span class="keyword">char</span> *dev_name, <span class="keyword">void</span> *data)</div><div class="line">&#123;</div><div class="line">	<span class="keyword">return</span> mount_pseudo(fs_type, <span class="string">"socket:"</span>, &amp;sockfs_ops,</div><div class="line">		&amp;sockfs_dentry_operations, SOCKFS_MAGIC);</div><div class="line">&#125;</div><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">super_operations</span> <span class="title">sockfs_ops</span> = &#123;</span></div><div class="line">	.alloc_inode	= sock_alloc_inode,</div><div class="line">	.destroy_inode	= sock_destroy_inode,</div><div class="line">	.statfs		= simple_statfs,</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<ul>
<li>sock_init -&gt; register mount -&gt; sock_fs_type-&gt;sockfs_mount-&gt;sockfs_ops-&gt;sock_alloc_node</li>
</ul>
<h3 id="4-5-pf-gt-create-即TCP／IP协议族的创建函数inet-create初始化步骤"><a href="#4-5-pf-gt-create-即TCP／IP协议族的创建函数inet-create初始化步骤" class="headerlink" title="(4.5).pf-&gt;create 即TCP／IP协议族的创建函数inet_create初始化步骤"></a>(4.5).pf-&gt;create 即TCP／IP协议族的创建函数inet_create初始化步骤</h3><h4 id="4-5-1-PF-INET协议族的create函数inet-create会被组册"><a href="#4-5-1-PF-INET协议族的create函数inet-create会被组册" class="headerlink" title="(4.5.1).PF_INET协议族的create函数inet_create会被组册"></a>(4.5.1).PF_INET协议族的create函数inet_create会被组册</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">(<span class="keyword">void</span>)sock_register(&amp;inet_family_ops);</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">net_proto_family</span> <span class="title">inet_family_ops</span> = &#123;</span></div><div class="line">	.family = PF_INET,</div><div class="line">	.create = inet_create,</div><div class="line">	.owner	= THIS_MODULE,</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h4 id="4-5-2-注册过程"><a href="#4-5-2-注册过程" class="headerlink" title="(4.5.2).注册过程"></a>(4.5.2).注册过程</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">sock_register</span><span class="params">(<span class="keyword">const</span> struct net_proto_family *ops)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span> err;</div><div class="line"></div><div class="line">	<span class="keyword">if</span> (ops-&gt;family &gt;= NPROTO) &#123;</div><div class="line">		printk(KERN_CRIT <span class="string">"protocol %d &gt;= NPROTO(%d)\n"</span>, ops-&gt;family,</div><div class="line">		       NPROTO);</div><div class="line">		<span class="keyword">return</span> -ENOBUFS;</div><div class="line">	&#125;</div><div class="line">	spin_lock(&amp;net_family_lock);</div><div class="line">	<span class="keyword">if</span> (rcu_dereference_protected(net_families[ops-&gt;family],</div><div class="line">				      lockdep_is_held(&amp;net_family_lock)))</div><div class="line">		err = -EEXIST;</div><div class="line">	<span class="keyword">else</span> &#123;</div><div class="line">		rcu_assign_pointer(net_families[ops-&gt;family], ops);</div><div class="line">		err = <span class="number">0</span>;</div><div class="line">	&#125;</div><div class="line">	spin_unlock(&amp;net_family_lock);</div><div class="line">	printk(KERN_INFO <span class="string">"NET: Registered protocol family %d\n"</span>, ops-&gt;family);</div><div class="line">	<span class="keyword">return</span> err;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>协议族选项ops会根基协议族类型PF_INET被放置到net_families系统全局变量中</li>
</ul>
<h4 id="4-5-3-sock-create使用过程"><a href="#4-5-3-sock-create使用过程" class="headerlink" title="(4.5.3).__sock_create使用过程"></a>(4.5.3).__sock_create使用过程</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">socket.c/__sock_create</div><div class="line">...</div><div class="line">rcu_read_lock();</div><div class="line">	pf = rcu_dereference(net_families[family]);</div><div class="line">	err = -EAFNOSUPPORT;</div><div class="line">	<span class="keyword">if</span> (!pf)</div><div class="line">		<span class="keyword">goto</span> out_release;</div><div class="line">	<span class="comment">/*</span></div><div class="line">	 * We will call the -&gt;create function, that possibly is in a loadable</div><div class="line">	 * module, so we have to bump that loadable module refcnt first.</div><div class="line">	 */</div><div class="line">	<span class="keyword">if</span> (!try_module_get(pf-&gt;owner))</div><div class="line">		<span class="keyword">goto</span> out_release;</div><div class="line"></div><div class="line">	<span class="comment">/* Now protected by module ref count */</span></div><div class="line">	rcu_read_unlock();</div><div class="line"></div><div class="line">	err = pf-&gt;create(net, sock, protocol, kern);</div><div class="line">	<span class="keyword">if</span> (err &lt; <span class="number">0</span>)</div><div class="line">		<span class="keyword">goto</span> out_module_put;</div></pre></td></tr></table></figure>
<ul>
<li>根据socket传输过来的协议族PF_INET查找全局变量net_families获取ops</li>
<li>通过ops-&gt;create调用inet_create根据具体协议创建网络层socket struct sock</li>
</ul>
<h3 id="4-6-inet-create都干了什么？"><a href="#4-6-inet-create都干了什么？" class="headerlink" title="(4.6).inet_create都干了什么？"></a>(4.6).inet_create都干了什么？</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">inet_create</span><span class="params">(struct net *net, struct socket *sock, <span class="keyword">int</span> protocol,</span></span></div><div class="line">		       <span class="keyword">int</span> kern)</div><div class="line">&#123;</div><div class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *<span class="title">sk</span>;</span></div><div class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inet_protosw</span> *<span class="title">answer</span>;</span></div><div class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inet_sock</span> *<span class="title">inet</span>;</span></div><div class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">proto</span> *<span class="title">answer_prot</span>;</span></div><div class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> answer_flags;</div><div class="line">	<span class="keyword">int</span> try_loading_module = <span class="number">0</span>;</div><div class="line">	<span class="keyword">int</span> err;</div><div class="line"></div><div class="line">	<span class="keyword">if</span> (protocol &lt; <span class="number">0</span> || protocol &gt;= IPPROTO_MAX)</div><div class="line">		<span class="keyword">return</span> -EINVAL;</div><div class="line"></div><div class="line">	sock-&gt;state = SS_UNCONNECTED;<span class="comment">//步骤1:设置socket状态SS_UNCONNECTED</span></div><div class="line"></div><div class="line">	<span class="comment">/* Look for the requested type/protocol pair. */</span></div><div class="line">lookup_protocol:</div><div class="line">	err = -ESOCKTNOSUPPORT;</div><div class="line">	rcu_read_lock();／／步骤<span class="number">2</span>:根据socket协议找到inet处理函数 connect、bind、accept、listen、等</div><div class="line">	list_for_each_entry_rcu(answer, &amp;inetsw[sock-&gt;type], <span class="built_in">list</span>) &#123;</div><div class="line"></div><div class="line">		err = <span class="number">0</span>;</div><div class="line">		<span class="comment">/* Check the non-wild match. */</span></div><div class="line">		<span class="keyword">if</span> (protocol == answer-&gt;protocol) &#123;</div><div class="line">			<span class="keyword">if</span> (protocol != IPPROTO_IP)</div><div class="line">				<span class="keyword">break</span>;</div><div class="line">		&#125; <span class="keyword">else</span> &#123;</div><div class="line">			<span class="comment">/* Check for the two wild cases. */</span></div><div class="line">			<span class="keyword">if</span> (IPPROTO_IP == protocol) &#123;</div><div class="line">				protocol = answer-&gt;protocol;</div><div class="line">				<span class="keyword">break</span>;</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">if</span> (IPPROTO_IP == answer-&gt;protocol)</div><div class="line">				<span class="keyword">break</span>;</div><div class="line">		&#125;</div><div class="line">		err = -EPROTONOSUPPORT;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">if</span> (unlikely(err)) &#123;</div><div class="line">		<span class="keyword">if</span> (try_loading_module &lt; <span class="number">2</span>) &#123;</div><div class="line">			rcu_read_unlock();</div><div class="line">			<span class="comment">/*</span></div><div class="line">			 * Be more specific, e.g. net-pf-2-proto-132-type-1</div><div class="line">			 * (net-pf-PF_INET-proto-IPPROTO_SCTP-type-SOCK_STREAM)</div><div class="line">			 */</div><div class="line">			<span class="keyword">if</span> (++try_loading_module == <span class="number">1</span>)</div><div class="line">				request_module(<span class="string">"net-pf-%d-proto-%d-type-%d"</span>,</div><div class="line">					       PF_INET, protocol, sock-&gt;type);</div><div class="line">			<span class="comment">/*</span></div><div class="line">			 * Fall back to generic, e.g. net-pf-2-proto-132</div><div class="line">			 * (net-pf-PF_INET-proto-IPPROTO_SCTP)</div><div class="line">			 */</div><div class="line">			<span class="keyword">else</span></div><div class="line">				request_module(<span class="string">"net-pf-%d-proto-%d"</span>,</div><div class="line">					       PF_INET, protocol);</div><div class="line">			<span class="keyword">goto</span> lookup_protocol;</div><div class="line">		&#125; <span class="keyword">else</span></div><div class="line">			<span class="keyword">goto</span> out_rcu_unlock;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	err = -EPERM;</div><div class="line">	<span class="keyword">if</span> (sock-&gt;type == SOCK_RAW &amp;&amp; !kern &amp;&amp;</div><div class="line">	    !ns_capable(net-&gt;user_ns, CAP_NET_RAW))</div><div class="line">		<span class="keyword">goto</span> out_rcu_unlock;</div><div class="line">／／步骤<span class="number">3</span>: 把协协议的inet操作集合赋值给socket结构的ops</div><div class="line">	sock-&gt;ops = answer-&gt;ops;</div><div class="line">	answer_prot = answer-&gt;prot;</div><div class="line">	answer_flags = answer-&gt;flags;</div><div class="line">	rcu_read_unlock();</div><div class="line"></div><div class="line">	WARN_ON(answer_prot-&gt;slab == <span class="literal">NULL</span>);</div><div class="line"></div><div class="line">	err = -ENOBUFS;</div><div class="line">	／／步骤<span class="number">4</span>:申请<span class="class"><span class="keyword">struct</span> <span class="title">sock</span>结构体，并切把协议操作集合赋值给<span class="title">sock</span>结构体</span></div><div class="line">	／／<span class="title">sk</span>-&gt;<span class="title">sk_prot</span> = <span class="title">sk</span>-&gt;<span class="title">sk_prot_creator</span> =协议操作集合;</div><div class="line">	sk = sk_alloc(net, PF_INET, GFP_KERNEL, answer_prot);</div><div class="line">	<span class="keyword">if</span> (sk == <span class="literal">NULL</span>)</div><div class="line">		<span class="keyword">goto</span> out;</div><div class="line"></div><div class="line">	err = <span class="number">0</span>;</div><div class="line">	<span class="keyword">if</span> (INET_PROTOSW_REUSE &amp; answer_flags)</div><div class="line">		sk-&gt;sk_reuse = SK_CAN_REUSE;</div><div class="line">／／步骤<span class="number">5</span>：inet_sock进行相关初始化</div><div class="line">	inet = inet_sk(sk);</div><div class="line">	inet-&gt;is_icsk = (INET_PROTOSW_ICSK &amp; answer_flags) != <span class="number">0</span>;</div><div class="line"></div><div class="line">	inet-&gt;nodefrag = <span class="number">0</span>;</div><div class="line"></div><div class="line">	<span class="keyword">if</span> (SOCK_RAW == sock-&gt;type) &#123;</div><div class="line">		inet-&gt;inet_num = protocol;</div><div class="line">		<span class="keyword">if</span> (IPPROTO_RAW == protocol)</div><div class="line">			inet-&gt;hdrincl = <span class="number">1</span>;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">if</span> (net-&gt;sysctl_ip_no_pmtu_disc)</div><div class="line">		inet-&gt;pmtudisc = IP_PMTUDISC_DONT;</div><div class="line">	<span class="keyword">else</span></div><div class="line">		inet-&gt;pmtudisc = IP_PMTUDISC_WANT;</div><div class="line"></div><div class="line">	inet-&gt;inet_id = <span class="number">0</span>;</div><div class="line"></div><div class="line">	sock_init_data(sock, sk);</div><div class="line"></div><div class="line">	sk-&gt;sk_destruct	   = inet_sock_destruct;</div><div class="line">	sk-&gt;sk_protocol	   = protocol;</div><div class="line">	sk-&gt;sk_backlog_rcv = sk-&gt;sk_prot-&gt;backlog_rcv;</div><div class="line"></div><div class="line">	inet-&gt;uc_ttl	= <span class="number">-1</span>;</div><div class="line">	inet-&gt;mc_loop	= <span class="number">1</span>;</div><div class="line">	inet-&gt;mc_ttl	= <span class="number">1</span>;</div><div class="line">	inet-&gt;mc_all	= <span class="number">1</span>;</div><div class="line">	inet-&gt;mc_index	= <span class="number">0</span>;</div><div class="line">	inet-&gt;mc_list	= <span class="literal">NULL</span>;</div><div class="line">	inet-&gt;rcv_tos	= <span class="number">0</span>;</div><div class="line"></div><div class="line">	sk_refcnt_debug_inc(sk);</div><div class="line"></div><div class="line">	<span class="keyword">if</span> (inet-&gt;inet_num) &#123;</div><div class="line">		<span class="comment">/* It assumes that any protocol which allows</span></div><div class="line">		 * the user to assign a number at socket</div><div class="line">		 * creation time automatically</div><div class="line">		 * shares.</div><div class="line">		 */</div><div class="line">		inet-&gt;inet_sport = htons(inet-&gt;inet_num);</div><div class="line">		<span class="comment">/* Add to protocol hash chains. */</span></div><div class="line">		sk-&gt;sk_prot-&gt;hash(sk);</div><div class="line">	&#125;</div><div class="line">／／步骤<span class="number">6</span>:调用协议层初始化函数tcp_v4_init_sock()进行始化</div><div class="line">	<span class="keyword">if</span> (sk-&gt;sk_prot-&gt;init) &#123;</div><div class="line">		err = sk-&gt;sk_prot-&gt;init(sk);</div><div class="line">		<span class="keyword">if</span> (err)</div><div class="line">			sk_common_release(sk);</div><div class="line">	&#125;</div><div class="line">out:</div><div class="line">	<span class="keyword">return</span> err;</div><div class="line">out_rcu_unlock:</div><div class="line">	rcu_read_unlock();</div><div class="line">	<span class="keyword">goto</span> out;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>设置socket状态SS_UNCONNECTED</li>
<li>根据协议类型找到具体的协议类型操作集合，例如协议处理函数tcp_proc和inet层处理函数集合inet_stream_ops</li>
<li>socket-&gt;ops 获得协议操作集合inet_stream_ops</li>
<li>申请sock，并把tcp_proc赋值给它 sk-&gt;sk_prot = sk-&gt;sk_prot_creator=tcp_proc</li>
<li>把申请的sock和inet_sock进行初始化</li>
<li>sk-&gt;sk_prot-&gt;init(sk) 调用tcp_proc深度初始化TCP相关信息</li>
</ul>
<p>尽管流程主要干了上述的事情，仍需要深入探究的问题是：<br>a. inet_protosw inet_protosw初始化过程如何？<br>b. inet_sock和sock是什么关系？<br>c. 从inet_protosw获取的prot和ops哪些结构体上会记录使用？</p>
<h4 id="4-6-1-inet-protosw初始化过程如何？"><a href="#4-6-1-inet-protosw初始化过程如何？" class="headerlink" title="(4.6.1).inet_protosw初始化过程如何？"></a>(4.6.1).inet_protosw初始化过程如何？</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">inet_protosw</span> <span class="title">inetsw_array</span>[] =</span></div><div class="line">&#123;</div><div class="line">	&#123;</div><div class="line">		.type =       SOCK_STREAM,</div><div class="line">		.protocol =   IPPROTO_TCP,</div><div class="line">		.prot =       &amp;tcp_prot,</div><div class="line">		.ops =        &amp;inet_stream_ops,</div><div class="line">		.flags =      INET_PROTOSW_PERMANENT |</div><div class="line">			      INET_PROTOSW_ICSK,</div><div class="line">	&#125;,</div><div class="line">	&#123;</div><div class="line">		.type =       SOCK_DGRAM,</div><div class="line">		.protocol =   IPPROTO_UDP,</div><div class="line">		.prot =       &amp;udp_prot,</div><div class="line">		.ops =        &amp;inet_dgram_ops,</div><div class="line">		.flags =      INET_PROTOSW_PERMANENT,</div><div class="line">       &#125;,</div><div class="line"></div><div class="line">       &#123;</div><div class="line">		.type =       SOCK_DGRAM,</div><div class="line">		.protocol =   IPPROTO_ICMP,</div><div class="line">		.prot =       &amp;ping_prot,</div><div class="line">		.ops =        &amp;inet_dgram_ops,</div><div class="line">		.flags =      INET_PROTOSW_REUSE,</div><div class="line">       &#125;,</div><div class="line">       &#123;</div><div class="line">	       .type =       SOCK_RAW,</div><div class="line">	       .protocol =   IPPROTO_IP,	<span class="comment">/* wild card */</span></div><div class="line">	       .prot =       &amp;raw_prot,</div><div class="line">	       .ops =        &amp;inet_sockraw_ops,</div><div class="line">	       .flags =      INET_PROTOSW_REUSE,</div><div class="line">       &#125;</div><div class="line">&#125;;</div><div class="line"><span class="comment">//inet_init</span></div><div class="line">	<span class="keyword">for</span> (q = inetsw_array; q &lt; &amp;inetsw_array[INETSW_ARRAY_LEN]; ++q)</div><div class="line">		inet_register_protosw(q);</div><div class="line">		</div><div class="line"><span class="comment">//inet_protosw放入全局inetsw管理</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">inet_register_protosw</span><span class="params">(struct inet_protosw *p)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">lh</span>;</span></div><div class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inet_protosw</span> *<span class="title">answer</span>;</span></div><div class="line">	<span class="keyword">int</span> protocol = p-&gt;protocol;</div><div class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">last_perm</span>;</span></div><div class="line"></div><div class="line">	spin_lock_bh(&amp;inetsw_lock);</div><div class="line"></div><div class="line">	<span class="keyword">if</span> (p-&gt;type &gt;= SOCK_MAX)</div><div class="line">		<span class="keyword">goto</span> out_illegal;</div><div class="line"></div><div class="line">	<span class="comment">/* If we are trying to override a permanent protocol, bail. */</span></div><div class="line">	answer = <span class="literal">NULL</span>;</div><div class="line">	last_perm = &amp;inetsw[p-&gt;type];</div><div class="line">	list_for_each(lh, &amp;inetsw[p-&gt;type]) &#123;</div><div class="line">		answer = list_entry(lh, struct inet_protosw, <span class="built_in">list</span>);</div><div class="line"></div><div class="line">		<span class="comment">/* Check only the non-wild match. */</span></div><div class="line">		<span class="keyword">if</span> (INET_PROTOSW_PERMANENT &amp; answer-&gt;flags) &#123;</div><div class="line">			<span class="keyword">if</span> (protocol == answer-&gt;protocol)</div><div class="line">				<span class="keyword">break</span>;</div><div class="line">			last_perm = lh;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		answer = <span class="literal">NULL</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span> (answer)</div><div class="line">		<span class="keyword">goto</span> out_permanent;</div><div class="line">	<span class="comment">/* Add the new entry after the last permanent entry if any, so that</span></div><div class="line">	 * the new entry does not override a permanent entry when matched with</div><div class="line">	 * a wild-card protocol. But it is allowed to override any existing</div><div class="line">	 * non-permanent entry.  This means that when we remove this entry, the</div><div class="line">	 * system automatically returns to the old behavior.</div><div class="line">	 */</div><div class="line">	list_add_rcu(&amp;p-&gt;<span class="built_in">list</span>, last_perm);</div><div class="line">out:</div><div class="line">	spin_unlock_bh(&amp;inetsw_lock);</div><div class="line">	<span class="keyword">return</span>;</div><div class="line">out_permanent:</div><div class="line">	pr_err(<span class="string">"Attempt to override permanent protocol %d\n"</span>, protocol);</div><div class="line">	<span class="keyword">goto</span> out;</div><div class="line">out_illegal:</div><div class="line">	pr_err(<span class="string">"Ignoring attempt to register invalid socket type %d\n"</span>,</div><div class="line">	       p-&gt;type);</div><div class="line">	<span class="keyword">goto</span> out;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>inet_init 会把inet_protosw方式inet_sw中</li>
<li>inet_protosw很重要，其含有协议的具体操作函数tcp_close,tcp_v4_connect,tcp_recvmsg等</li>
<li>inet_protosw，内还包含inet层操作函数 inet_bind,inet_accept,inet_bind,inet_listen等</li>
</ul>
<h4 id="4-6-2-inet-sock和sock是什么关系？"><a href="#4-6-2-inet-sock和sock是什么关系？" class="headerlink" title="(4.6.2). inet_sock和sock是什么关系？"></a>(4.6.2). inet_sock和sock是什么关系？</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div></pre></td><td class="code"><pre><div class="line"><span class="function">struct sock *<span class="title">sk_alloc</span><span class="params">(struct net *net, <span class="keyword">int</span> family, <span class="keyword">gfp_t</span> priority,</span></span></div><div class="line">		      struct proto *prot)</div><div class="line">&#123;</div><div class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *<span class="title">sk</span>;</span></div><div class="line"></div><div class="line">	sk = sk_prot_alloc(prot, priority | __GFP_ZERO, family);</div><div class="line">	<span class="keyword">if</span> (sk) &#123;</div><div class="line">		sk-&gt;sk_family = family;</div><div class="line">		<span class="comment">/*</span></div><div class="line">		 * See comment in struct sock definition to understand</div><div class="line">		 * why we need sk_prot_creator -acme</div><div class="line">		 */</div><div class="line">		sk-&gt;sk_prot = sk-&gt;sk_prot_creator = prot;</div><div class="line">		sock_lock_init(sk);</div><div class="line">		sock_net_set(sk, get_net(net));</div><div class="line">		atomic_set(&amp;sk-&gt;sk_wmem_alloc, <span class="number">1</span>);</div><div class="line"></div><div class="line">		sock_update_classid(sk);</div><div class="line">		sock_update_netprioidx(sk);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">return</span> sk;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">static</span> struct sock *<span class="title">sk_prot_alloc</span><span class="params">(struct proto *prot, <span class="keyword">gfp_t</span> priority,</span></span></div><div class="line">		<span class="keyword">int</span> family)</div><div class="line">&#123;</div><div class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *<span class="title">sk</span>;</span></div><div class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache</span> *<span class="title">slab</span>;</span></div><div class="line"></div><div class="line">	slab = prot-&gt;slab;</div><div class="line">	<span class="keyword">if</span> (slab != <span class="literal">NULL</span>) &#123;</div><div class="line">		sk = kmem_cache_alloc(slab, priority &amp; ~__GFP_ZERO);</div><div class="line">		<span class="keyword">if</span> (!sk)</div><div class="line">			<span class="keyword">return</span> sk;</div><div class="line">		<span class="keyword">if</span> (priority &amp; __GFP_ZERO) &#123;</div><div class="line">			<span class="keyword">if</span> (prot-&gt;clear_sk)</div><div class="line">				prot-&gt;clear_sk(sk, prot-&gt;obj_size);</div><div class="line">			<span class="keyword">else</span></div><div class="line">				sk_prot_clear_nulls(sk, prot-&gt;obj_size);</div><div class="line">		&#125;</div><div class="line">	&#125; <span class="keyword">else</span></div><div class="line">		sk = kmalloc(prot-&gt;obj_size, priority);<span class="comment">//申请内存大小为prot的objsize</span></div><div class="line"></div><div class="line">	<span class="keyword">if</span> (sk != <span class="literal">NULL</span>) &#123;</div><div class="line">		kmemcheck_annotate_bitfield(sk, flags);</div><div class="line"></div><div class="line">		<span class="keyword">if</span> (security_sk_alloc(sk, family, priority))</div><div class="line">			<span class="keyword">goto</span> out_free;</div><div class="line"></div><div class="line">		<span class="keyword">if</span> (!try_module_get(prot-&gt;owner))</div><div class="line">			<span class="keyword">goto</span> out_free_sec;</div><div class="line">		sk_tx_queue_clear(sk);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">return</span> sk;</div><div class="line"></div><div class="line">out_free_sec:</div><div class="line">	security_sk_free(sk);</div><div class="line">out_free:</div><div class="line">	<span class="keyword">if</span> (slab != <span class="literal">NULL</span>)</div><div class="line">		kmem_cache_free(slab, sk);</div><div class="line">	<span class="keyword">else</span></div><div class="line">		kfree(sk);</div><div class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><em>从上述sk_alloc  -&gt; sk_prot_alloc -&gt; obj_size</em></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proto</span> <span class="title">tcp_prot</span> = &#123;</span></div><div class="line">	.name			= <span class="string">"TCP"</span>,</div><div class="line">	.owner			= THIS_MODULE,</div><div class="line">	.close			= tcp_close,</div><div class="line">	.connect		= tcp_v4_connect,</div><div class="line">	.disconnect		= tcp_disconnect,</div><div class="line">	.accept			= inet_csk_accept,</div><div class="line">	.ioctl			= tcp_ioctl,</div><div class="line">	.init			= tcp_v4_init_sock,</div><div class="line">	.destroy		= tcp_v4_destroy_sock,</div><div class="line">	.shutdown		= tcp_shutdown,</div><div class="line">	.setsockopt		= tcp_setsockopt,</div><div class="line">	.getsockopt		= tcp_getsockopt,</div><div class="line">	.recvmsg		= tcp_recvmsg,</div><div class="line">	.sendmsg		= tcp_sendmsg,</div><div class="line">	.sendpage		= tcp_sendpage,</div><div class="line">	.backlog_rcv		= tcp_v4_do_rcv,</div><div class="line">	.release_cb		= tcp_release_cb,</div><div class="line">	.hash			= inet_hash,</div><div class="line">	.unhash			= inet_unhash,</div><div class="line">	.get_port		= inet_csk_get_port,</div><div class="line">	.enter_memory_pressure	= tcp_enter_memory_pressure,</div><div class="line">	.stream_memory_free	= tcp_stream_memory_free,</div><div class="line">	.sockets_allocated	= &amp;tcp_sockets_allocated,</div><div class="line">	.orphan_count		= &amp;tcp_orphan_count,</div><div class="line">	.memory_allocated	= &amp;tcp_memory_allocated,</div><div class="line">	.memory_pressure	= &amp;tcp_memory_pressure,</div><div class="line">	.sysctl_wmem		= sysctl_tcp_wmem,</div><div class="line">	.sysctl_rmem		= sysctl_tcp_rmem,</div><div class="line">	.max_header		= MAX_TCP_HEADER,</div><div class="line">	.obj_size		= <span class="keyword">sizeof</span>(struct tcp_sock),</div><div class="line">	.slab_flags		= SLAB_DESTROY_BY_RCU,</div><div class="line">	.twsk_prot		= &amp;tcp_timewait_sock_ops,</div><div class="line">	.rsk_prot		= &amp;tcp_request_sock_ops,</div><div class="line">	.h.hashinfo		= &amp;tcp_hashinfo,</div><div class="line">	.no_autobind		= <span class="literal">true</span>,</div><div class="line">#ifdef CONFIG_COMPAT</div><div class="line">	.compat_setsockopt	= compat_tcp_setsockopt,</div><div class="line">	.compat_getsockopt	= compat_tcp_getsockopt,</div><div class="line">#endif</div><div class="line">#ifdef CONFIG_MEMCG_KMEM</div><div class="line">	.init_cgroup		= tcp_init_cgroup,</div><div class="line">	.destroy_cgroup		= tcp_destroy_cgroup,</div><div class="line">	.proto_cgroup		= tcp_proto_cgroup,</div><div class="line">#endif</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<ul>
<li>struct tcp_sock 包含strcut inet_sock 包含 struct sock</li>
<li>上述结构体为互相包含的关系</li>
<li>实际上在申请sock时候，申请内存大小为tcp_sock大小，也就是说三个结构体共同诞生了</li>
</ul>
<h4 id="4-6-3-从inet-protosw获取的prot和ops哪些结构体上会记录使用？"><a href="#4-6-3-从inet-protosw获取的prot和ops哪些结构体上会记录使用？" class="headerlink" title="(4.6.3). 从inet_protosw获取的prot和ops哪些结构体上会记录使用？"></a>(4.6.3). 从inet_protosw获取的prot和ops哪些结构体上会记录使用？</h4><blockquote>
<p>struct socket会在inet_create函数中获取到ops<br>    sock-&gt;ops = answer-&gt;ops;<br>struct sock在sk_allloc函数中获取pro<br>  sk-&gt;sk_prot = sk-&gt;sk_prot_creator = prot;</p>
</blockquote>
<h2 id="5-socket与文件系统"><a href="#5-socket与文件系统" class="headerlink" title="(5).socket与文件系统"></a>(5).socket与文件系统</h2><p>socket与文件系统关联通过sock_map_fd完成</p>
<p>其步骤如下：</p>
<blockquote>
<p>1:获取fd get_unused_fd_flags</p>
<blockquote>
<p>该函数从当前进程管理的files获取可用的fd</p>
</blockquote>
<p>2:申请file sock_alloc_file</p>
<blockquote>
<p>将struct socket放到file的private_data管理 file-&gt;private_data = sock</p>
</blockquote>
<p>3:将file根据当前fd安装到current-&gt;files中</p>
<blockquote>
<p>files有一个指针fdt<br>fdt-&gt;fd是一个类型为file指针的数组，数组下标为fd<br>rcu_assign_pointer(fdt-&gt;fd[fd], file); 将file安装fd为数组下标放到current-&gt;files管理</p>
</blockquote>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;socket&quot;&gt;&lt;a href=&quot;#socket&quot; class=&quot;headerlink&quot; title=&quot;socket()&quot;&gt;&lt;/a&gt;socket()&lt;/h1&gt;&lt;p&gt;内核版本：3.10.0-514.16.1.el7.x86_64&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;sys/types.h&amp;gt;          /* See NOTES */&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;sys/socket.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;socket&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; domain, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; type, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; protocol)&lt;/span&gt;&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;fd=socket(PF_INET,SOCK_STREAM,&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="socket" scheme="https://vcpu.github.io/categories/socket/"/>
    
    
      <category term="tcp/ip" scheme="https://vcpu.github.io/tags/tcp-ip/"/>
    
      <category term="kernel3.10.0-514.16.1" scheme="https://vcpu.github.io/tags/kernel3-10-0-514-16-1/"/>
    
      <category term="socket" scheme="https://vcpu.github.io/tags/socket/"/>
    
  </entry>
  
  <entry>
    <title>systemtap使用调试记录（一）</title>
    <link href="https://vcpu.github.io/systemtap%E4%BD%BF%E7%94%A8%E8%B0%83%E8%AF%95%E8%AE%B0%E5%BD%95%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>https://vcpu.github.io/systemtap使用调试记录（一）/</id>
    <published>2017-06-05T10:15:52.000Z</published>
    <updated>2017-06-05T10:15:52.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="systemtap使用调试记录（一）"><a href="#systemtap使用调试记录（一）" class="headerlink" title="systemtap使用调试记录（一）"></a>systemtap使用调试记录（一）</h1><h2 id="一、调试环境介绍"><a href="#一、调试环境介绍" class="headerlink" title="一、调试环境介绍"></a>一、调试环境介绍</h2><pre><code>Linux 3.10.0-514.16.1.el7.x86_64 
kernel-devel-3.10.0-514.16.1.el7.x86_64.rpm 同版本的开发头文件
kernel-debuginfo-common-x86_64-3.10.0-514.16.1.el7.x86_64.rpm
kernel-debuginfo-3.10.0-514.16.1.el7.x86_64.rpm 同版本调试数据包
linux-3.10.0-514.16.1.el7.tar.xz 同版本的源码
</code></pre><p><a href="https://centos.pkgs.org/7/centos-updates-x86_64/kernel-devel-3.10.0-514.16.1.el7.x86_64.rpm.html" target="_blank" rel="external"><em>kernel开发头文件下载地址</em></a><br><a href="http://debuginfo.centos.org/7/x86_64/kernel-debuginfo-3.10.0-514.16.1.el7.x86_64.rpm" target="_blank" rel="external"><em>kernel调试包下载地址</em></a><br><a href="http://debuginfo.centos.org/7/x86_64/kernel-debuginfo-common-x86_64-3.10.0-514.16.1.el7.x86_64.rpm" target="_blank" rel="external"><em>kernel调试common包下载地址</em></a><br><a href="https://wiki.centos.org/zh/HowTos/I_need_the_Kernel_Source#head-963cd44439b8c10fa507fa0c90725029c060108a" target="_blank" rel="external">根据当前虚拟机获取内核代码的方法</a></p>
<a id="more"></a>
<h2 id="二、centos7安装方法"><a href="#二、centos7安装方法" class="headerlink" title="二、centos7安装方法"></a>二、centos7安装方法</h2><pre><code>yum install *.rpm  安装上述3个（debugifo,devel,debuginfo-common）rpm包
yum install systemtap
stap -ve &apos;probe begin { log(&quot;hello world&quot;) exit() }&apos;
</code></pre><p>测试正常结果如下：    </p>
<blockquote>
<p>[root@localhost qinlong]# stap -ve ‘probe begin { log(“hello world”) exit() }’<br>Pass 1: parsed user script and 120 library scripts using 227352virt/40488res/3260shr/37400data kb, in 260usr/30sys/338real ms.<br>Pass 2: analyzed script: 1 probe, 2 functions, 0 embeds, 0 globals using 228540virt/41804res/3420shr/38588data kb, in 10usr/0sys/6real ms.<br>Pass 3: translated to C into “/tmp/stap5CqHmN/stap_f7a5084b8a638f5ce64a31271684ef1f_1133_src.c” using 228672virt/42408res/3996shr/38720data kb, in 0usr/0sys/0real ms.<br>Pass 4: compiled C into “stap_f7a5084b8a638f5ce64a31271684ef1f_1133.ko” in 1000usr/330sys/1247real ms.<br>Pass 5: starting run.<br>hello world<br>Pass 5: run completed in 10usr/40sys/362real ms.</p>
</blockquote>
<h2 id="三、通用案例"><a href="#三、通用案例" class="headerlink" title="三、通用案例"></a>三、通用案例</h2><h3 id="1-函数调用栈打印"><a href="#1-函数调用栈打印" class="headerlink" title="1.函数调用栈打印"></a>1.函数调用栈打印</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">[root@localhost stp]# cat bt.stp</div><div class="line">	probe kernel.function(@1)&#123;</div><div class="line">	    print(&quot;----------------START-------------------------\n&quot;)</div><div class="line">	    printf(&quot;In process [%s]\n&quot;, execname())</div><div class="line">	    print_regs()</div><div class="line">	    print_backtrace()</div><div class="line">	    print(&quot;----------------END-------------------------\n&quot;)</div><div class="line">	    exit()</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p>打印内核函数的调用栈</p>
<blockquote>
<p>[root@localhost stp]# stap bt.stp tcp_sendmsg<br>—————-START————————-<br>In process [sshd]<br>RIP: ffffffff815c1ee0<br>RSP: ffff88003d217d28  EFLAGS: 00000202<br>RAX: ffffffff81aa20a0 RBX: ffff88003d217e38 RCX: 0000000000000024<br>RDX: ffff88003d217da8 RSI: ffff88003b3b87c0 RDI: ffff88003d217e38<br>RBP: ffff88003d217d50 R08: 0000000000000000 R09: 0000000000000000<br>R10: ffff88003d217da8 R11: 0000000000000000 R12: ffff88003d217e38<br>R13: 0000000000000001 R14: ffff88003d217e28 R15: ffff8800274d3480<br>FS:  00007f03e5514840(0000) GS:ffff88003fd00000(0000) knlGS:0000000000000000<br>CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033<br>CR2: 00007f19c6dc8000 CR3: 0000000035a5c000 CR4: 00000000000406e0<br> 0xffffffff815c1ee0 : tcp_sendmsg+0x0/0xc40 [kernel]<br> 0xffffffff815ed254 : inet_sendmsg+0x64/0xb0 [kernel]<br> 0xffffffff81554e07 : sock_aio_write+0x157/0x180 [kernel]<br> 0xffffffff811fdf3d : do_sync_write+0x8d/0xd0 [kernel]<br> 0xffffffff811fe8a5 : vfs_write+0x1b5/0x1e0 [kernel]<br> 0xffffffff811ff2cf : sys_write+0x7f/0xe0 [kernel]<br> 0xffffffff81697189 : system_call_fastpath+0x16/0x1b [kernel]<br>—————-END————————-</p>
</blockquote>
<h3 id="2-函数的调用过程"><a href="#2-函数的调用过程" class="headerlink" title="2.函数的调用过程"></a>2.函数的调用过程</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">[root@localhost stp]# cat socket-trace.stp</div><div class="line">probe kernel.function(&quot;*@net/socket.c&quot;).call&#123;</div><div class="line">	printf(&quot;%s -&gt; %s\n&quot;,thread_indent(1),ppfunc())</div><div class="line">&#125;</div><div class="line">probe kernel.function(&quot;*@net/socket.c&quot;).return&#123;</div><div class="line">	printf(&quot;%s&lt;-%s\n&quot;,thread_indent(-1),ppfunc())</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>thread_indent(1)     打印程序名称（线程id）<br>ppfunc() 打印出执行函数符号</p>
<p>kernel.function(“<em>@net/socket.c”).call<br>调用net/socket.c 文件中函数时候会触发函数体执行打印动作<br>kernel.function(“</em>@net/socket.c”).return<br>调用net/socket.c文件中函数执行完成返回后会触发函数体打印动作</p>
<blockquote>
<p>[root@localhost stp]# stap socket-trace.stp<br>  0 dndX11(3295): -&gt; SyS_recvmsg<br>  0 dndX11(3295): -&gt; <strong>sys_recvmsg<br>  0 dndX11(3295): -&gt; sockfd_lookup_light<br>  0 dndX11(3295):&lt;-sockfd_lookup<em>light<br>  1 dndX11(3295): -&gt; </em></strong>sys_recvmsg<br>  3 dndX11(3295): -&gt; sock_recvmsg<br>  7 dndX11(3295):&lt;-sock_recvmsg<br>  8 dndX11(3295):&lt;-<strong>_sys_recvmsg<br>  9 dndX11(3295):&lt;-</strong>sys_recvmsg<br> 10 dndX11(3295):&lt;-SyS_recvmsg<br>25274 dndX11(3295): -&gt; SyS_recvmsg<br>25279 dndX11(3295): -&gt; <strong>sys_recvmsg<br>25281 dndX11(3295): -&gt; sockfd_lookup_light<br>25284 dndX11(3295):&lt;-sockfd_lookup<em>light<br>25285 dndX11(3295): -&gt; </em></strong>sys_recvmsg<br>25288 dndX11(3295): -&gt; sock_recvmsg<br>25291 dndX11(3295):&lt;-sock_recvmsgx</p>
</blockquote>
<h3 id="3-打印协议栈函数中某一行数据"><a href="#3-打印协议栈函数中某一行数据" class="headerlink" title="3.打印协议栈函数中某一行数据"></a>3.打印协议栈函数中某一行数据</h3><p>/home/qinlong/rpmbuild/SOURCES/linux-3.10.0-514.16.1.el7/net/ipv4/tcp.c<br>局部源码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">1065 int tcp_sendmsg(struct kiocb *iocb, struct sock *sk, struct msghdr *msg,</div><div class="line">1066                 size_t size)</div><div class="line">1067 &#123;</div><div class="line">1068         struct iovec *iov;</div><div class="line">1069         struct tcp_sock *tp = tcp_sk(sk);</div><div class="line">1070         struct sk_buff *skb;</div><div class="line">1071         int iovlen, flags, err, copied = 0;</div><div class="line">1072         int mss_now = 0, size_goal, copied_syn = 0, offset = 0;</div><div class="line">1073         bool sg;</div><div class="line">1074         long timeo;</div><div class="line">1075</div><div class="line">1076         lock_sock(sk);</div><div class="line">1077</div><div class="line">1078         flags = msg-&gt;msg_flags;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[root@localhost ~]# stap -L &apos;kernel.statement(&quot;*@net/ipv4/tcp.c:1078&quot;)&apos;</div><div class="line">kernel.statement(&quot;tcp_sendmsg@net/ipv4/tcp.c:1078&quot;) $iocb:struct kiocb* $sk:struct sock* $msg:struct msghdr* $size:size_t $copied:int $mss_now:int $size_goal:int $copied_syn:int $offset:int $timeo:long int</div></pre></td></tr></table></figure>
<p>执行上述函数，可确代码具体的函数局部变量<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">$iocb:struct kiocb* </div><div class="line">$sk:struct sock* </div><div class="line">$msg:struct msghdr* </div><div class="line">$size:size_t </div><div class="line">$copied:int</div><div class="line">$mss_now:int </div><div class="line">$size_goal:int </div><div class="line">$copied_syn:int </div><div class="line">$offset:int </div><div class="line">$timeo:long int</div></pre></td></tr></table></figure></p>
<p>根据以上变量打印出size值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[root@localhost ~]# stap -e &apos;probe kernel.statement(&quot;*@net/ipv4/tcp.c:1078&quot;) &#123;printf(&quot;size %d \n&quot;,$size)&#125;&apos;</div><div class="line">size 36</div><div class="line">size 44</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;systemtap使用调试记录（一）&quot;&gt;&lt;a href=&quot;#systemtap使用调试记录（一）&quot; class=&quot;headerlink&quot; title=&quot;systemtap使用调试记录（一）&quot;&gt;&lt;/a&gt;systemtap使用调试记录（一）&lt;/h1&gt;&lt;h2 id=&quot;一、调试环境介绍&quot;&gt;&lt;a href=&quot;#一、调试环境介绍&quot; class=&quot;headerlink&quot; title=&quot;一、调试环境介绍&quot;&gt;&lt;/a&gt;一、调试环境介绍&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;Linux 3.10.0-514.16.1.el7.x86_64 
kernel-devel-3.10.0-514.16.1.el7.x86_64.rpm 同版本的开发头文件
kernel-debuginfo-common-x86_64-3.10.0-514.16.1.el7.x86_64.rpm
kernel-debuginfo-3.10.0-514.16.1.el7.x86_64.rpm 同版本调试数据包
linux-3.10.0-514.16.1.el7.tar.xz 同版本的源码
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;a href=&quot;https://centos.pkgs.org/7/centos-updates-x86_64/kernel-devel-3.10.0-514.16.1.el7.x86_64.rpm.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;em&gt;kernel开发头文件下载地址&lt;/em&gt;&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://debuginfo.centos.org/7/x86_64/kernel-debuginfo-3.10.0-514.16.1.el7.x86_64.rpm&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;em&gt;kernel调试包下载地址&lt;/em&gt;&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://debuginfo.centos.org/7/x86_64/kernel-debuginfo-common-x86_64-3.10.0-514.16.1.el7.x86_64.rpm&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;em&gt;kernel调试common包下载地址&lt;/em&gt;&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://wiki.centos.org/zh/HowTos/I_need_the_Kernel_Source#head-963cd44439b8c10fa507fa0c90725029c060108a&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;根据当前虚拟机获取内核代码的方法&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="linux kernel" scheme="https://vcpu.github.io/categories/linux-kernel/"/>
    
    
      <category term="systemtap" scheme="https://vcpu.github.io/tags/systemtap/"/>
    
  </entry>
  
</feed>
